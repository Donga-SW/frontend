"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_graphology_dist_graphology_mjs"],{

/***/ "(app-pages-browser)/./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\nmodule.exports.once = once;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n}\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      checkListener(listener);\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n\nfunction once(emitter, name) {\n  return new Promise(function (resolve, reject) {\n    function errorListener(err) {\n      emitter.removeListener(name, resolver);\n      reject(err);\n    }\n\n    function resolver() {\n      if (typeof emitter.removeListener === 'function') {\n        emitter.removeListener('error', errorListener);\n      }\n      resolve([].slice.call(arguments));\n    };\n\n    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });\n    if (name !== 'error') {\n      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });\n    }\n  });\n}\n\nfunction addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n  if (typeof emitter.on === 'function') {\n    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);\n  }\n}\n\nfunction eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n  if (typeof emitter.on === 'function') {\n    if (flags.once) {\n      emitter.once(name, listener);\n    } else {\n      emitter.on(name, listener);\n    }\n  } else if (typeof emitter.addEventListener === 'function') {\n    // EventTarget does not have `error` event semantics like Node\n    // EventEmitters, we do not listen for `error` events here.\n    emitter.addEventListener(name, function wrapListener(arg) {\n      // IE does not have builtin `{ once: true }` support so we\n      // have to do it manually.\n      if (flags.once) {\n        emitter.removeEventListener(name, wrapListener);\n      }\n      listener(arg);\n    });\n  } else {\n    throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudHMvZXZlbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1COztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixzQkFBc0I7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlCQUF5QjtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4REFBOEQsWUFBWTtBQUMxRTtBQUNBLDhEQUE4RCxZQUFZO0FBQzFFO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZXZlbnRzXFxldmVudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/events/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/graphology/dist/graphology.mjs":
/*!*****************************************************!*\
  !*** ./node_modules/graphology/dist/graphology.mjs ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DirectedGraph: () => (/* binding */ DirectedGraph),\n/* harmony export */   Graph: () => (/* binding */ Graph),\n/* harmony export */   InvalidArgumentsGraphError: () => (/* binding */ InvalidArgumentsGraphError),\n/* harmony export */   MultiDirectedGraph: () => (/* binding */ MultiDirectedGraph),\n/* harmony export */   MultiGraph: () => (/* binding */ MultiGraph),\n/* harmony export */   MultiUndirectedGraph: () => (/* binding */ MultiUndirectedGraph),\n/* harmony export */   NotFoundGraphError: () => (/* binding */ NotFoundGraphError),\n/* harmony export */   UndirectedGraph: () => (/* binding */ UndirectedGraph),\n/* harmony export */   UsageGraphError: () => (/* binding */ UsageGraphError),\n/* harmony export */   \"default\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"(app-pages-browser)/./node_modules/events/events.js\");\n\n\n/**\n * Graphology Utilities\n * =====================\n *\n * Collection of helpful functions used by the implementation.\n */\n\n/**\n * Object.assign-like polyfill.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nfunction assignPolyfill() {\n  const target = arguments[0];\n\n  for (let i = 1, l = arguments.length; i < l; i++) {\n    if (!arguments[i]) continue;\n\n    for (const k in arguments[i]) target[k] = arguments[i][k];\n  }\n\n  return target;\n}\n\nlet assign = assignPolyfill;\n\nif (typeof Object.assign === 'function') assign = Object.assign;\n\n/**\n * Function returning the first matching edge for given path.\n * Note: this function does not check the existence of source & target. This\n * must be performed by the caller.\n *\n * @param  {Graph}  graph  - Target graph.\n * @param  {any}    source - Source node.\n * @param  {any}    target - Target node.\n * @param  {string} type   - Type of the edge (mixed, directed or undirected).\n * @return {string|null}\n */\nfunction getMatchingEdge(graph, source, target, type) {\n  const sourceData = graph._nodes.get(source);\n\n  let edge = null;\n\n  if (!sourceData) return edge;\n\n  if (type === 'mixed') {\n    edge =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]);\n  } else if (type === 'directed') {\n    edge = sourceData.out && sourceData.out[target];\n  } else {\n    edge = sourceData.undirected && sourceData.undirected[target];\n  }\n\n  return edge;\n}\n\n/**\n * Checks whether the given value is a plain object.\n *\n * @param  {mixed}   value - Target value.\n * @return {boolean}\n */\nfunction isPlainObject(value) {\n  // NOTE: as per https://github.com/graphology/graphology/issues/149\n  // this function has been loosened not to reject object instances\n  // coming from other JavaScript contexts. It has also been chosen\n  // not to improve it to avoid obvious false positives and avoid\n  // taking a performance hit. People should really use TypeScript\n  // if they want to avoid feeding subtly irrelvant attribute objects.\n  return typeof value === 'object' && value !== null;\n}\n\n/**\n * Checks whether the given object is empty.\n *\n * @param  {object}  o - Target Object.\n * @return {boolean}\n */\nfunction isEmpty(o) {\n  let k;\n\n  for (k in o) return false;\n\n  return true;\n}\n\n/**\n * Creates a \"private\" property for the given member name by concealing it\n * using the `enumerable` option.\n *\n * @param {object} target - Target object.\n * @param {string} name   - Member name.\n */\nfunction privateProperty(target, name, value) {\n  Object.defineProperty(target, name, {\n    enumerable: false,\n    configurable: false,\n    writable: true,\n    value\n  });\n}\n\n/**\n * Creates a read-only property for the given member name & the given getter.\n *\n * @param {object}   target - Target object.\n * @param {string}   name   - Member name.\n * @param {mixed}    value  - The attached getter or fixed value.\n */\nfunction readOnlyProperty(target, name, value) {\n  const descriptor = {\n    enumerable: true,\n    configurable: true\n  };\n\n  if (typeof value === 'function') {\n    descriptor.get = value;\n  } else {\n    descriptor.value = value;\n    descriptor.writable = false;\n  }\n\n  Object.defineProperty(target, name, descriptor);\n}\n\n/**\n * Returns whether the given object constitute valid hints.\n *\n * @param {object} hints - Target object.\n */\nfunction validateHints(hints) {\n  if (!isPlainObject(hints)) return false;\n\n  if (hints.attributes && !Array.isArray(hints.attributes)) return false;\n\n  return true;\n}\n\n/**\n * Creates a function generating incremental ids for edges.\n *\n * @return {function}\n */\nfunction incrementalIdStartingFromRandomByte() {\n  let i = Math.floor(Math.random() * 256) & 0xff;\n\n  return () => {\n    return i++;\n  };\n}\n\n/**\n * Chains multiple iterators into a single iterator.\n *\n * @param {...Iterator} iterables\n * @returns {Iterator}\n */\nfunction chain() {\n  const iterables = arguments;\n  let current = null;\n  let i = -1;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step = null;\n\n      do {\n        if (current === null) {\n          i++;\n          if (i >= iterables.length) return {done: true};\n          current = iterables[i][Symbol.iterator]();\n        }\n        step = current.next();\n        if (step.done) {\n          current = null;\n          continue;\n        }\n        break;\n        // eslint-disable-next-line no-constant-condition\n      } while (true);\n\n      return step;\n    }\n  };\n}\n\nfunction emptyIterator() {\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      return {done: true};\n    }\n  };\n}\n\n/**\n * Graphology Custom Errors\n * =========================\n *\n * Defining custom errors for ease of use & easy unit tests across\n * implementations (normalized typology rather than relying on error\n * messages to check whether the correct error was found).\n */\nclass GraphError extends Error {\n  constructor(message) {\n    super();\n    this.name = 'GraphError';\n    this.message = message;\n  }\n}\n\nclass InvalidArgumentsGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'InvalidArgumentsGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(\n        this,\n        InvalidArgumentsGraphError.prototype.constructor\n      );\n  }\n}\n\nclass NotFoundGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'NotFoundGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, NotFoundGraphError.prototype.constructor);\n  }\n}\n\nclass UsageGraphError extends GraphError {\n  constructor(message) {\n    super(message);\n    this.name = 'UsageGraphError';\n\n    // This is V8 specific to enhance stack readability\n    if (typeof Error.captureStackTrace === 'function')\n      Error.captureStackTrace(this, UsageGraphError.prototype.constructor);\n  }\n}\n\n/**\n * Graphology Internal Data Classes\n * =================================\n *\n * Internal classes hopefully reduced to structs by engines & storing\n * necessary information for nodes & edges.\n *\n * Note that those classes don't rely on the `class` keyword to avoid some\n * cruft introduced by most of ES2015 transpilers.\n */\n\n/**\n * MixedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction MixedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nMixedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n  this.undirected = {};\n};\n\n/**\n * DirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction DirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nDirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.inDegree = 0;\n  this.outDegree = 0;\n  this.directedLoops = 0;\n\n  // Indices\n  this.in = {};\n  this.out = {};\n};\n\n/**\n * UndirectedNodeData class.\n *\n * @constructor\n * @param {string} string     - The node's key.\n * @param {object} attributes - Node's attributes.\n */\nfunction UndirectedNodeData(key, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n\n  this.clear();\n}\n\nUndirectedNodeData.prototype.clear = function () {\n  // Degrees\n  this.undirectedDegree = 0;\n  this.undirectedLoops = 0;\n\n  // Indices\n  this.undirected = {};\n};\n\n/**\n * EdgeData class.\n *\n * @constructor\n * @param {boolean} undirected   - Whether the edge is undirected.\n * @param {string}  string       - The edge's key.\n * @param {string}  source       - Source of the edge.\n * @param {string}  target       - Target of the edge.\n * @param {object}  attributes   - Edge's attributes.\n */\nfunction EdgeData(undirected, key, source, target, attributes) {\n  // Attributes\n  this.key = key;\n  this.attributes = attributes;\n  this.undirected = undirected;\n\n  // Extremities\n  this.source = source;\n  this.target = target;\n}\n\nEdgeData.prototype.attach = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  // Handling source\n  this.source[outKey][target] = this;\n\n  if (this.undirected && source === target) return;\n\n  // Handling target\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.attachMulti = function () {\n  let outKey = 'out';\n  let inKey = 'in';\n\n  const source = this.source.key;\n  const target = this.target.key;\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Handling source\n  const adj = this.source[outKey];\n  const head = adj[target];\n\n  if (typeof head === 'undefined') {\n    adj[target] = this;\n\n    // Self-loop optimization\n    if (!(this.undirected && source === target)) {\n      // Handling target\n      this.target[inKey][source] = this;\n    }\n\n    return;\n  }\n\n  // Prepending to doubly-linked list\n  head.previous = this;\n  this.next = head;\n\n  // Pointing to new head\n  // NOTE: use mutating swap later to avoid lookup?\n  adj[target] = this;\n  this.target[inKey][source] = this;\n};\n\nEdgeData.prototype.detach = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  delete this.source[outKey][target];\n\n  // No-op delete in case of undirected self-loop\n  delete this.target[inKey][source];\n};\n\nEdgeData.prototype.detachMulti = function () {\n  const source = this.source.key;\n  const target = this.target.key;\n\n  let outKey = 'out';\n  let inKey = 'in';\n\n  if (this.undirected) outKey = inKey = 'undirected';\n\n  // Deleting from doubly-linked list\n  if (this.previous === undefined) {\n    // We are dealing with the head\n\n    // Should we delete the adjacency entry because it is now empty?\n    if (this.next === undefined) {\n      delete this.source[outKey][target];\n\n      // No-op delete in case of undirected self-loop\n      delete this.target[inKey][source];\n    } else {\n      // Detaching\n      this.next.previous = undefined;\n\n      // NOTE: could avoid the lookups by creating a #.become mutating method\n      this.source[outKey][target] = this.next;\n\n      // No-op delete in case of undirected self-loop\n      this.target[inKey][source] = this.next;\n    }\n  } else {\n    // We are dealing with another list node\n    this.previous.next = this.next;\n\n    // If not last\n    if (this.next !== undefined) {\n      this.next.previous = this.previous;\n    }\n  }\n};\n\n/**\n * Graphology Node Attributes methods\n * ===================================\n */\n\nconst NODE = 0;\nconst SOURCE = 1;\nconst TARGET = 2;\nconst OPPOSITE = 3;\n\nfunction findRelevantNodeData(\n  graph,\n  method,\n  mode,\n  nodeOrEdge,\n  nameOrEdge,\n  add1,\n  add2\n) {\n  let nodeData, edgeData, arg1, arg2;\n\n  nodeOrEdge = '' + nodeOrEdge;\n\n  if (mode === NODE) {\n    nodeData = graph._nodes.get(nodeOrEdge);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" node in the graph.`\n      );\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  } else if (mode === OPPOSITE) {\n    nameOrEdge = '' + nameOrEdge;\n\n    edgeData = graph._edges.get(nameOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nameOrEdge}\" edge in the graph.`\n      );\n\n    const source = edgeData.source.key;\n    const target = edgeData.target.key;\n\n    if (nodeOrEdge === source) {\n      nodeData = edgeData.target;\n    } else if (nodeOrEdge === target) {\n      nodeData = edgeData.source;\n    } else {\n      throw new NotFoundGraphError(\n        `Graph.${method}: the \"${nodeOrEdge}\" node is not attached to the \"${nameOrEdge}\" edge (${source}, ${target}).`\n      );\n    }\n\n    arg1 = add1;\n    arg2 = add2;\n  } else {\n    edgeData = graph._edges.get(nodeOrEdge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.${method}: could not find the \"${nodeOrEdge}\" edge in the graph.`\n      );\n\n    if (mode === SOURCE) {\n      nodeData = edgeData.source;\n    } else {\n      nodeData = edgeData.target;\n    }\n\n    arg1 = nameOrEdge;\n    arg2 = add1;\n  }\n\n  return [nodeData, arg1, arg2];\n}\n\nfunction attachNodeAttributeGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes[name];\n  };\n}\n\nfunction attachNodeAttributesGetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge) {\n    const [data] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge\n    );\n\n    return data.attributes;\n  };\n}\n\nfunction attachNodeAttributeChecker(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\nfunction attachNodeAttributeSetter(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, value] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1, add2) {\n    const [data, name, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1,\n      add2\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    const attributes = data.attributes;\n    const value = updater(attributes[name]);\n\n    attributes[name] = value;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributeRemover(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, name] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesReplacer(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesMerger(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, attributes] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\nfunction attachNodeAttributesUpdater(Class, method, mode) {\n  Class.prototype[method] = function (nodeOrEdge, nameOrEdge, add1) {\n    const [data, updater] = findRelevantNodeData(\n      this,\n      method,\n      mode,\n      nodeOrEdge,\n      nameOrEdge,\n      add1\n    );\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('nodeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst NODE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachNodeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachNodeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachNodeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachNodeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachNodeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachNodeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachNodeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachNodeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachNodeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachNodeAttributesMethods(Graph) {\n  NODE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For nodes\n    attacher(Graph, name('Node'), NODE);\n\n    // For sources\n    attacher(Graph, name('Source'), SOURCE);\n\n    // For targets\n    attacher(Graph, name('Target'), TARGET);\n\n    // For opposites\n    attacher(Graph, name('Opposite'), OPPOSITE);\n  });\n}\n\n/**\n * Graphology Edge Attributes methods\n * ===================================\n */\n\n/**\n * Attach an attribute getter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeGetter(Class, method, type) {\n  /**\n   * Get the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {mixed}          - The attribute's value.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes[name];\n  };\n}\n\n/**\n * Attach an attributes getter method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributesGetter(Class, method, type) {\n  /**\n   * Retrieves all the target element's attributes.\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   *\n   * @return {object}          - The element's attributes.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 1) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + arguments[1];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes;\n  };\n}\n\n/**\n * Attach an attribute checker method onto the provided class.\n *\n * @param {function} Class       - Target class.\n * @param {string}   method      - Method name.\n * @param {string}   type        - Type of the edge to find.\n */\nfunction attachEdgeAttributeChecker(Class, method, type) {\n  /**\n   * Checks whether the desired attribute is set for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    return data.attributes.hasOwnProperty(name);\n  };\n}\n\n/**\n * Attach an attribute setter method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeSetter(Class, method, type) {\n  /**\n   * Set the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   * @param  {mixed}  value   - New attribute value.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, value) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      value = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    data.attributes[name] = value;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeUpdater(Class, method, type) {\n  /**\n   * Update the desired attribute for the given element (node or edge) using\n   * the provided function.\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {string}   name    - Attribute's name.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 3) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n      updater = arguments[3];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: updater should be a function.`\n      );\n\n    data.attributes[name] = updater(data.attributes[name]);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'set',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute remover method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributeRemover(Class, method, type) {\n  /**\n   * Remove the desired attribute for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element - Target element.\n   * @param  {string} name    - Attribute's name.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source - Source element.\n   * @param  {any}     target - Target element.\n   * @param  {string}  name   - Attribute's name.\n   *\n   * @return {Graph}          - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, name) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element;\n      const target = '' + name;\n\n      name = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    delete data.attributes[name];\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'remove',\n      attributes: data.attributes,\n      name\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute replacer method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesReplacer(Class, method, type) {\n  /**\n   * Replace the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - New attributes.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - New attributes.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    data.attributes = attributes;\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'replace',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute merger method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesMerger(Class, method, type) {\n  /**\n   * Merge the attributes for the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}    element    - Target element.\n   * @param  {object} attributes - Attributes to merge.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}     source     - Source element.\n   * @param  {any}     target     - Target element.\n   * @param  {object}  attributes - Attributes to merge.\n   *\n   * @return {Graph}              - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, attributes) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + attributes;\n\n      attributes = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided attributes are not a plain object.`\n      );\n\n    assign(data.attributes, attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'merge',\n      attributes: data.attributes,\n      data: attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * Attach an attribute updater method onto the provided class.\n *\n * @param {function} Class         - Target class.\n * @param {string}   method        - Method name.\n * @param {string}   type          - Type of the edge to find.\n */\nfunction attachEdgeAttributesUpdater(Class, method, type) {\n  /**\n   * Update the attributes of the given element (node or edge).\n   *\n   * Arity 2:\n   * @param  {any}      element - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * Arity 3 (only for edges):\n   * @param  {any}      source  - Source element.\n   * @param  {any}      target  - Target element.\n   * @param  {function} updater - Updater function.\n   *\n   * @return {Graph}            - Returns itself for chaining.\n   *\n   * @throws {Error} - Will throw if too many arguments are provided.\n   * @throws {Error} - Will throw if any of the elements is not found.\n   */\n  Class.prototype[method] = function (element, updater) {\n    let data;\n\n    if (this.type !== 'mixed' && type !== 'mixed' && type !== this.type)\n      throw new UsageGraphError(\n        `Graph.${method}: cannot find this type of edges in your ${this.type} graph.`\n      );\n\n    if (arguments.length > 2) {\n      if (this.multi)\n        throw new UsageGraphError(\n          `Graph.${method}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`\n        );\n\n      const source = '' + element,\n        target = '' + updater;\n\n      updater = arguments[2];\n\n      data = getMatchingEdge(this, source, target, type);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find an edge for the given path (\"${source}\" - \"${target}\").`\n        );\n    } else {\n      if (type !== 'mixed')\n        throw new UsageGraphError(\n          `Graph.${method}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`\n        );\n\n      element = '' + element;\n      data = this._edges.get(element);\n\n      if (!data)\n        throw new NotFoundGraphError(\n          `Graph.${method}: could not find the \"${element}\" edge in the graph.`\n        );\n    }\n\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.${method}: provided updater is not a function.`\n      );\n\n    data.attributes = updater(data.attributes);\n\n    // Emitting\n    this.emit('edgeAttributesUpdated', {\n      key: data.key,\n      type: 'update',\n      attributes: data.attributes\n    });\n\n    return this;\n  };\n}\n\n/**\n * List of methods to attach.\n */\nconst EDGE_ATTRIBUTES_METHODS = [\n  {\n    name: element => `get${element}Attribute`,\n    attacher: attachEdgeAttributeGetter\n  },\n  {\n    name: element => `get${element}Attributes`,\n    attacher: attachEdgeAttributesGetter\n  },\n  {\n    name: element => `has${element}Attribute`,\n    attacher: attachEdgeAttributeChecker\n  },\n  {\n    name: element => `set${element}Attribute`,\n    attacher: attachEdgeAttributeSetter\n  },\n  {\n    name: element => `update${element}Attribute`,\n    attacher: attachEdgeAttributeUpdater\n  },\n  {\n    name: element => `remove${element}Attribute`,\n    attacher: attachEdgeAttributeRemover\n  },\n  {\n    name: element => `replace${element}Attributes`,\n    attacher: attachEdgeAttributesReplacer\n  },\n  {\n    name: element => `merge${element}Attributes`,\n    attacher: attachEdgeAttributesMerger\n  },\n  {\n    name: element => `update${element}Attributes`,\n    attacher: attachEdgeAttributesUpdater\n  }\n];\n\n/**\n * Attach every attributes-related methods to a Graph class.\n *\n * @param {function} Graph - Target class.\n */\nfunction attachEdgeAttributesMethods(Graph) {\n  EDGE_ATTRIBUTES_METHODS.forEach(function ({name, attacher}) {\n    // For edges\n    attacher(Graph, name('Edge'), 'mixed');\n\n    // For directed edges\n    attacher(Graph, name('DirectedEdge'), 'directed');\n\n    // For undirected edges\n    attacher(Graph, name('UndirectedEdge'), 'undirected');\n  });\n}\n\n/**\n * Graphology Edge Iteration\n * ==========================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's edges.\n */\n\n/**\n * Definitions.\n */\nconst EDGES_ITERATION = [\n  {\n    name: 'edges',\n    type: 'mixed'\n  },\n  {\n    name: 'inEdges',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outEdges',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundEdges',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundEdges',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedEdges',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedEdges',\n    type: 'undirected'\n  }\n];\n\n/**\n * Function iterating over edges from the given object to match one of them.\n *\n * @param {object}   object   - Target object.\n * @param {function} callback - Function to call.\n */\nfunction forEachSimple(breakable, object, callback, avoid) {\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    const edgeData = object[k];\n\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n  }\n\n  return;\n}\n\nfunction forEachMulti(breakable, object, callback, avoid) {\n  let edgeData, source, target;\n\n  let shouldBreak = false;\n\n  for (const k in object) {\n    if (k === avoid) continue;\n\n    edgeData = object[k];\n\n    do {\n      source = edgeData.source;\n      target = edgeData.target;\n\n      shouldBreak = callback(\n        edgeData.key,\n        edgeData.attributes,\n        source.key,\n        target.key,\n        source.attributes,\n        target.attributes,\n        edgeData.undirected\n      );\n\n      if (breakable && shouldBreak) return edgeData.key;\n\n      edgeData = edgeData.next;\n    } while (edgeData !== undefined);\n  }\n\n  return;\n}\n\n/**\n * Function returning an iterator over edges from the given object.\n *\n * @param  {object}   object - Target object.\n * @return {Iterator}\n */\nfunction createIterator(object, avoid) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let edgeData;\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      do {\n        if (!edgeData) {\n          if (i >= l) return {done: true};\n\n          const k = keys[i++];\n\n          if (k === avoid) {\n            edgeData = undefined;\n            continue;\n          }\n\n          edgeData = object[k];\n        } else {\n          edgeData = edgeData.next;\n        }\n      } while (!edgeData);\n\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function iterating over the egdes from the object at given key to match\n * one of them.\n *\n * @param {object}   object   - Target object.\n * @param {mixed}    k        - Neighbor key.\n * @param {function} callback - Callback to use.\n */\nfunction forEachForKeySimple(breakable, object, k, callback) {\n  const edgeData = object[k];\n\n  if (!edgeData) return;\n\n  const sourceData = edgeData.source;\n  const targetData = edgeData.target;\n\n  if (\n    callback(\n      edgeData.key,\n      edgeData.attributes,\n      sourceData.key,\n      targetData.key,\n      sourceData.attributes,\n      targetData.attributes,\n      edgeData.undirected\n    ) &&\n    breakable\n  )\n    return edgeData.key;\n}\n\nfunction forEachForKeyMulti(breakable, object, k, callback) {\n  let edgeData = object[k];\n\n  if (!edgeData) return;\n\n  let shouldBreak = false;\n\n  do {\n    shouldBreak = callback(\n      edgeData.key,\n      edgeData.attributes,\n      edgeData.source.key,\n      edgeData.target.key,\n      edgeData.source.attributes,\n      edgeData.target.attributes,\n      edgeData.undirected\n    );\n\n    if (breakable && shouldBreak) return edgeData.key;\n\n    edgeData = edgeData.next;\n  } while (edgeData !== undefined);\n\n  return;\n}\n\n/**\n * Function returning an iterator over the egdes from the object at given key.\n *\n * @param  {object}   object   - Target object.\n * @param  {mixed}    k        - Neighbor key.\n * @return {Iterator}\n */\nfunction createIteratorForKey(object, k) {\n  let edgeData = object[k];\n\n  if (edgeData.next !== undefined) {\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        if (!edgeData) return {done: true};\n\n        const value = {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        };\n\n        edgeData = edgeData.next;\n\n        return {\n          done: false,\n          value\n        };\n      }\n    };\n  }\n\n  let done = false;\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      if (done === true) return {done: true};\n      done = true;\n      return {\n        done: false,\n        value: {\n          edge: edgeData.key,\n          attributes: edgeData.attributes,\n          source: edgeData.source.key,\n          target: edgeData.target.key,\n          sourceAttributes: edgeData.source.attributes,\n          targetAttributes: edgeData.target.attributes,\n          undirected: edgeData.undirected\n        }\n      };\n    }\n  };\n}\n\n/**\n * Function creating an array of edges for the given type.\n *\n * @param  {Graph}   graph - Target Graph instance.\n * @param  {string}  type  - Type of edges to retrieve.\n * @return {array}         - Array of edges.\n */\nfunction createEdgeArray(graph, type) {\n  if (graph.size === 0) return [];\n\n  if (type === 'mixed' || type === graph.type) {\n    return Array.from(graph._edges.keys());\n  }\n\n  const size =\n    type === 'undirected' ? graph.undirectedSize : graph.directedSize;\n\n  const list = new Array(size),\n    mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  let i = 0;\n  let step, data;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (data.undirected === mask) list[i++] = data.key;\n  }\n\n  return list;\n}\n\n/**\n * Function iterating over a graph's edges using a callback to match one of\n * them.\n *\n * @param  {Graph}    graph    - Target Graph instance.\n * @param  {string}   type     - Type of edges to retrieve.\n * @param  {function} callback - Function to call.\n */\nfunction forEachEdge(breakable, graph, type, callback) {\n  if (graph.size === 0) return;\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  let step, data;\n  let shouldBreak = false;\n  const iterator = graph._edges.values();\n\n  while (((step = iterator.next()), step.done !== true)) {\n    data = step.value;\n\n    if (shouldFilter && data.undirected !== mask) continue;\n\n    const {key, attributes, source, target} = data;\n\n    shouldBreak = callback(\n      key,\n      attributes,\n      source.key,\n      target.key,\n      source.attributes,\n      target.attributes,\n      data.undirected\n    );\n\n    if (breakable && shouldBreak) return key;\n  }\n\n  return;\n}\n\n/**\n * Function creating an iterator of edges for the given type.\n *\n * @param  {Graph}    graph - Target Graph instance.\n * @param  {string}   type  - Type of edges to retrieve.\n * @return {Iterator}\n */\nfunction createEdgeIterator(graph, type) {\n  if (graph.size === 0) return emptyIterator();\n\n  const shouldFilter = type !== 'mixed' && type !== graph.type;\n  const mask = type === 'undirected';\n\n  const iterator = graph._edges.values();\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let step, data;\n\n      // eslint-disable-next-line no-constant-condition\n      while (true) {\n        step = iterator.next();\n\n        if (step.done) return step;\n\n        data = step.value;\n\n        if (shouldFilter && data.undirected !== mask) continue;\n\n        break;\n      }\n\n      const value = {\n        edge: data.key,\n        attributes: data.attributes,\n        source: data.source.key,\n        target: data.target.key,\n        sourceAttributes: data.source.attributes,\n        targetAttributes: data.target.attributes,\n        undirected: data.undirected\n      };\n\n      return {value, done: false};\n    }\n  };\n}\n\n/**\n * Function iterating over a node's edges using a callback to match one of them.\n *\n * @param  {boolean}  multi     - Whether the graph is multi or not.\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Function to call.\n */\nfunction forEachEdgeForNode(\n  breakable,\n  multi,\n  type,\n  direction,\n  nodeData,\n  callback\n) {\n  const fn = multi ? forEachMulti : forEachSimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = fn(breakable, nodeData.in, callback);\n\n      if (breakable && found) return found;\n    }\n    if (direction !== 'in') {\n      found = fn(\n        breakable,\n        nodeData.out,\n        callback,\n        !direction ? nodeData.key : undefined\n      );\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    found = fn(breakable, nodeData.undirected, callback);\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given type & the given node.\n *\n * @param  {boolean} multi     - Whether the graph is multi or not.\n * @param  {string}  type      - Type of edges to retrieve.\n * @param  {string}  direction - In or out?\n * @param  {any}     nodeData  - Target node's data.\n * @return {array}             - Array of edges.\n */\nfunction createEdgeArrayForNode(multi, type, direction, nodeData) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForNode(false, multi, type, direction, nodeData, function (key) {\n    edges.push(key);\n  });\n\n  return edges;\n}\n\n/**\n * Function iterating over a node's edges using a callback.\n *\n * @param  {string}   type      - Type of edges to retrieve.\n * @param  {string}   direction - In or out?\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createEdgeIteratorForNode(type, direction, nodeData) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out' && typeof nodeData.in !== 'undefined')\n      iterator = chain(iterator, createIterator(nodeData.in));\n    if (direction !== 'in' && typeof nodeData.out !== 'undefined')\n      iterator = chain(\n        iterator,\n        createIterator(nodeData.out, !direction ? nodeData.key : undefined)\n      );\n  }\n\n  if (type !== 'directed' && typeof nodeData.undirected !== 'undefined') {\n    iterator = chain(iterator, createIterator(nodeData.undirected));\n  }\n\n  return iterator;\n}\n\n/**\n * Function iterating over edges for the given path using a callback to match\n * one of them.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction forEachEdgeForPath(\n  breakable,\n  type,\n  multi,\n  direction,\n  sourceData,\n  target,\n  callback\n) {\n  const fn = multi ? forEachForKeyMulti : forEachForKeySimple;\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (typeof sourceData.in !== 'undefined' && direction !== 'out') {\n      found = fn(breakable, sourceData.in, target, callback);\n\n      if (breakable && found) return found;\n    }\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      (direction || sourceData.key !== target)\n    ) {\n      found = fn(breakable, sourceData.out, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  if (type !== 'directed') {\n    if (typeof sourceData.undirected !== 'undefined') {\n      found = fn(breakable, sourceData.undirected, target, callback);\n\n      if (breakable && found) return found;\n    }\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {boolean}  multi      - Whether the graph is multi.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {any}      target     - Target node.\n * @return {array}               - Array of edges.\n */\nfunction createEdgeArrayForPath(type, multi, direction, sourceData, target) {\n  const edges = []; // TODO: possibility to know size beforehand or factorize with map\n\n  forEachEdgeForPath(\n    false,\n    type,\n    multi,\n    direction,\n    sourceData,\n    target,\n    function (key) {\n      edges.push(key);\n    }\n  );\n\n  return edges;\n}\n\n/**\n * Function returning an iterator over edges for the given path.\n *\n * @param  {string}   type       - Type of edges to retrieve.\n * @param  {string}   direction  - In or out?\n * @param  {NodeData} sourceData - Source node's data.\n * @param  {string}   target     - Target node.\n * @param  {function} callback   - Function to call.\n */\nfunction createEdgeIteratorForPath(type, direction, sourceData, target) {\n  let iterator = emptyIterator();\n\n  if (type !== 'undirected') {\n    if (\n      typeof sourceData.in !== 'undefined' &&\n      direction !== 'out' &&\n      target in sourceData.in\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.in, target));\n\n    if (\n      typeof sourceData.out !== 'undefined' &&\n      direction !== 'in' &&\n      target in sourceData.out &&\n      (direction || sourceData.key !== target)\n    )\n      iterator = chain(iterator, createIteratorForKey(sourceData.out, target));\n  }\n\n  if (type !== 'directed') {\n    if (\n      typeof sourceData.undirected !== 'undefined' &&\n      target in sourceData.undirected\n    )\n      iterator = chain(\n        iterator,\n        createIteratorForKey(sourceData.undirected, target)\n      );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching an edge array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain edges.\n   *\n   * Arity 0: Return all the relevant edges.\n   *\n   * Arity 1: Return all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Return the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    if (!arguments.length) return createEdgeArray(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeArrayForNode(\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData\n      );\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeArrayForPath(\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching a edge callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(false, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        false,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${forEachName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        false,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${forEachName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function mapping the graph's relevant edges by applying the given\n   * callback.\n   *\n   * Arity 1: Map all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Map all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Map the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    let result;\n\n    // We know the result length beforehand\n    if (args.length === 0) {\n      let length = 0;\n\n      if (type !== 'directed') length += this.undirectedSize;\n      if (type !== 'undirected') length += this.directedSize;\n\n      result = new Array(length);\n\n      let i = 0;\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result[i++] = callback(e, ea, s, t, sa, ta, u);\n      });\n    }\n\n    // We don't know the result length beforehand\n    // TODO: we can in some instances of simple graphs, knowing degree\n    else {\n      result = [];\n\n      args.push((e, ea, s, t, sa, ta, u) => {\n        result.push(callback(e, ea, s, t, sa, ta, u));\n      });\n    }\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function filtering the graph's relevant edges using the provided predicate\n   * function.\n   *\n   * Arity 1: Filter all the relevant edges.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 2: Filter all of a node's relevant edges.\n   * @param  {any}      node      - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * Arity 3: Filter the relevant edges across the given path.\n   * @param  {any}      source    - Source node.\n   * @param  {any}      target    - Target node.\n   * @param  {function} predicate - Predicate to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    const result = [];\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      if (callback(e, ea, s, t, sa, ta, u)) result.push(e);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return result;\n  };\n\n  /**\n   * Function reducing the graph's relevant edges using the provided accumulator\n   * function.\n   *\n   * Arity 1: Reduce all the relevant edges.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 2: Reduce all of a node's relevant edges.\n   * @param  {any}      node         - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * Arity 3: Reduce the relevant edges across the given path.\n   * @param  {any}      source       - Source node.\n   * @param  {any}      target       - Target node.\n   * @param  {function} accumulator  - Accumulator to use.\n   * @param  {any}      initialValue - Initial value.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function () {\n    let args = Array.prototype.slice.call(arguments);\n\n    if (args.length < 2 || args.length > 4) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: invalid number of arguments (expecting 2, 3 or 4 and got ${args.length}).`\n      );\n    }\n\n    if (\n      typeof args[args.length - 1] === 'function' &&\n      typeof args[args.length - 2] !== 'function'\n    ) {\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n    }\n\n    let callback;\n    let initialValue;\n\n    if (args.length === 2) {\n      callback = args[0];\n      initialValue = args[1];\n      args = [];\n    } else if (args.length === 3) {\n      callback = args[1];\n      initialValue = args[2];\n      args = [args[0]];\n    } else if (args.length === 4) {\n      callback = args[2];\n      initialValue = args[3];\n      args = [args[0], args[1]];\n    }\n\n    let accumulator = initialValue;\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      accumulator = callback(accumulator, e, ea, s, t, sa, ta, u);\n    });\n\n    this[forEachName].apply(this, args);\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable edge callback iterator method to the Graph\n * prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindEdge(Class, description) {\n  const {name, type, direction} = description;\n\n  const findEdgeName = 'find' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over the graph's relevant edges in order to match\n   * one of them using the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findEdgeName] = function (source, target, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return false;\n\n    if (arguments.length === 1) {\n      callback = source;\n      return forEachEdge(true, this, type, callback);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      callback = target;\n\n      const nodeData = this._nodes.get(source);\n\n      if (typeof nodeData === 'undefined')\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      // TODO: maybe attach the sub method to the instance dynamically?\n      return forEachEdgeForNode(\n        true,\n        this.multi,\n        type === 'mixed' ? this.type : type,\n        direction,\n        nodeData,\n        callback\n      );\n    }\n\n    if (arguments.length === 3) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${findEdgeName}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return forEachEdgeForPath(\n        true,\n        type,\n        this.multi,\n        direction,\n        sourceData,\n        target,\n        callback\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${findEdgeName}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`\n    );\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether any one of them matches the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[someName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over the graph's relevant edges in order to assert\n   * whether all of them matche the provided predicate function.\n   *\n   * Arity 1: Iterate over all the relevant edges.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 2: Iterate over all of a node's relevant edges.\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * Arity 3: Iterate over the relevant edges across the given path.\n   * @param  {any}      source   - Source node.\n   * @param  {any}      target   - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + name[0].toUpperCase() + name.slice(1, -1);\n\n  Class.prototype[everyName] = function () {\n    const args = Array.prototype.slice.call(arguments);\n    const callback = args.pop();\n\n    args.push((e, ea, s, t, sa, ta, u) => {\n      return !callback(e, ea, s, t, sa, ta, u);\n    });\n\n    const found = this[findEdgeName].apply(this, args);\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching an edge iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachEdgeIteratorCreator(Class, description) {\n  const {name: originalName, type, direction} = description;\n\n  const name = originalName.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over the graph's edges.\n   *\n   * Arity 0: Iterate over all the relevant edges.\n   *\n   * Arity 1: Iterate over all of a node's relevant edges.\n   * @param  {any}   node   - Target node.\n   *\n   * Arity 2: Iterate over the relevant edges across the given path.\n   * @param  {any}   source - Source node.\n   * @param  {any}   target - Target node.\n   *\n   * @return {array|number} - The edges or the number of edges.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[name] = function (source, target) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    if (!arguments.length) return createEdgeIterator(this, type);\n\n    if (arguments.length === 1) {\n      source = '' + source;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}: could not find the \"${source}\" node in the graph.`\n        );\n\n      // Iterating over a node's edges\n      return createEdgeIteratorForNode(type, direction, sourceData);\n    }\n\n    if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      const sourceData = this._nodes.get(source);\n\n      if (!sourceData)\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${source}\" source node in the graph.`\n        );\n\n      if (!this._nodes.has(target))\n        throw new NotFoundGraphError(\n          `Graph.${name}:  could not find the \"${target}\" target node in the graph.`\n        );\n\n      // Iterating over the edges between source & target\n      return createEdgeIteratorForPath(type, direction, sourceData, target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`\n    );\n  };\n}\n\n/**\n * Function attaching every edge iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachEdgeIterationMethods(Graph) {\n  EDGES_ITERATION.forEach(description => {\n    attachEdgeArrayCreator(Graph, description);\n    attachForEachEdge(Graph, description);\n    attachFindEdge(Graph, description);\n    attachEdgeIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Neighbor Iteration\n * ==============================\n *\n * Attaching some methods to the Graph class to be able to iterate over\n * neighbors.\n */\n\n/**\n * Definitions.\n */\nconst NEIGHBORS_ITERATION = [\n  {\n    name: 'neighbors',\n    type: 'mixed'\n  },\n  {\n    name: 'inNeighbors',\n    type: 'directed',\n    direction: 'in'\n  },\n  {\n    name: 'outNeighbors',\n    type: 'directed',\n    direction: 'out'\n  },\n  {\n    name: 'inboundNeighbors',\n    type: 'mixed',\n    direction: 'in'\n  },\n  {\n    name: 'outboundNeighbors',\n    type: 'mixed',\n    direction: 'out'\n  },\n  {\n    name: 'directedNeighbors',\n    type: 'directed'\n  },\n  {\n    name: 'undirectedNeighbors',\n    type: 'undirected'\n  }\n];\n\n/**\n * Helpers.\n */\nfunction CompositeSetWrapper() {\n  this.A = null;\n  this.B = null;\n}\n\nCompositeSetWrapper.prototype.wrap = function (set) {\n  if (this.A === null) this.A = set;\n  else if (this.B === null) this.B = set;\n};\n\nCompositeSetWrapper.prototype.has = function (key) {\n  if (this.A !== null && key in this.A) return true;\n  if (this.B !== null && key in this.B) return true;\n  return false;\n};\n\n/**\n * Function iterating over the given node's relevant neighbors to match\n * one of them using a predicated function.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @param  {function} callback  - Callback to use.\n */\nfunction forEachInObjectOnce(breakable, visited, nodeData, object, callback) {\n  for (const k in object) {\n    const edgeData = object[k];\n\n    const sourceData = edgeData.source;\n    const targetData = edgeData.target;\n\n    const neighborData = sourceData === nodeData ? targetData : sourceData;\n\n    if (visited && visited.has(neighborData.key)) continue;\n\n    const shouldBreak = callback(neighborData.key, neighborData.attributes);\n\n    if (breakable && shouldBreak) return neighborData.key;\n  }\n\n  return;\n}\n\nfunction forEachNeighbor(breakable, type, direction, nodeData, callback) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.undirected,\n        callback\n      );\n\n    if (typeof direction === 'string')\n      return forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData[direction],\n        callback\n      );\n  }\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  let found;\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      found = forEachInObjectOnce(\n        breakable,\n        null,\n        nodeData,\n        nodeData.in,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.in);\n    }\n    if (direction !== 'in') {\n      found = forEachInObjectOnce(\n        breakable,\n        visited,\n        nodeData,\n        nodeData.out,\n        callback\n      );\n\n      if (breakable && found) return found;\n\n      visited.wrap(nodeData.out);\n    }\n  }\n\n  if (type !== 'directed') {\n    found = forEachInObjectOnce(\n      breakable,\n      visited,\n      nodeData,\n      nodeData.undirected,\n      callback\n    );\n\n    if (breakable && found) return found;\n  }\n\n  return;\n}\n\n/**\n * Function creating an array of relevant neighbors for the given node.\n *\n * @param  {string}       type      - Type of neighbors.\n * @param  {string}       direction - Direction.\n * @param  {any}          nodeData  - Target node's data.\n * @return {Array}                  - The list of neighbors.\n */\nfunction createNeighborArrayForNode(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected') return Object.keys(nodeData.undirected);\n\n    if (typeof direction === 'string') return Object.keys(nodeData[direction]);\n  }\n\n  const neighbors = [];\n\n  forEachNeighbor(false, type, direction, nodeData, function (key) {\n    neighbors.push(key);\n  });\n\n  return neighbors;\n}\n\n/**\n * Function returning an iterator over the given node's relevant neighbors.\n *\n * @param  {string}   type      - Type of neighbors.\n * @param  {string}   direction - Direction.\n * @param  {any}      nodeData  - Target node's data.\n * @return {Iterator}\n */\nfunction createDedupedObjectIterator(visited, nodeData, object) {\n  const keys = Object.keys(object);\n  const l = keys.length;\n\n  let i = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      let neighborData = null;\n\n      do {\n        if (i >= l) {\n          if (visited) visited.wrap(object);\n          return {done: true};\n        }\n\n        const edgeData = object[keys[i++]];\n\n        const sourceData = edgeData.source;\n        const targetData = edgeData.target;\n\n        neighborData = sourceData === nodeData ? targetData : sourceData;\n\n        if (visited && visited.has(neighborData.key)) {\n          neighborData = null;\n          continue;\n        }\n      } while (neighborData === null);\n\n      return {\n        done: false,\n        value: {neighbor: neighborData.key, attributes: neighborData.attributes}\n      };\n    }\n  };\n}\n\nfunction createNeighborIterator(type, direction, nodeData) {\n  // If we want only undirected or in or out, we can roll some optimizations\n  if (type !== 'mixed') {\n    if (type === 'undirected')\n      return createDedupedObjectIterator(null, nodeData, nodeData.undirected);\n\n    if (typeof direction === 'string')\n      return createDedupedObjectIterator(null, nodeData, nodeData[direction]);\n  }\n\n  let iterator = emptyIterator();\n\n  // Else we need to keep a set of neighbors not to return duplicates\n  // We cheat by querying the other adjacencies\n  const visited = new CompositeSetWrapper();\n\n  if (type !== 'undirected') {\n    if (direction !== 'out') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.in)\n      );\n    }\n    if (direction !== 'in') {\n      iterator = chain(\n        iterator,\n        createDedupedObjectIterator(visited, nodeData, nodeData.out)\n      );\n    }\n  }\n\n  if (type !== 'directed') {\n    iterator = chain(\n      iterator,\n      createDedupedObjectIterator(visited, nodeData, nodeData.undirected)\n    );\n  }\n\n  return iterator;\n}\n\n/**\n * Function attaching a neighbors array creator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborArrayCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  /**\n   * Function returning an array of certain neighbors.\n   *\n   * @param  {any}   node   - Target node.\n   * @return {array} - The neighbors of neighbors.\n   *\n   * @throws {Error} - Will throw if node is not found in the graph.\n   */\n  Class.prototype[name] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return [];\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${name}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborArrayForNode(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachForEachNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const forEachName = 'forEach' + name[0].toUpperCase() + name.slice(1, -1);\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[forEachName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${forEachName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    forEachNeighbor(\n      false,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function mapping the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const mapName = 'map' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[mapName] = function (node, callback) {\n    // TODO: optimize when size is known beforehand\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      result.push(callback(n, a));\n    });\n\n    return result;\n  };\n\n  /**\n   * Function filtering the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const filterName = 'filter' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[filterName] = function (node, callback) {\n    const result = [];\n\n    this[forEachName](node, (n, a) => {\n      if (callback(n, a)) result.push(n);\n    });\n\n    return result;\n  };\n\n  /**\n   * Function reducing the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const reduceName = 'reduce' + name[0].toUpperCase() + name.slice(1);\n\n  Class.prototype[reduceName] = function (node, callback, initialValue) {\n    if (arguments.length < 3)\n      throw new InvalidArgumentsGraphError(\n        `Graph.${reduceName}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`\n      );\n\n    let accumulator = initialValue;\n\n    this[forEachName](node, (n, a) => {\n      accumulator = callback(accumulator, n, a);\n    });\n\n    return accumulator;\n  };\n}\n\n/**\n * Function attaching a breakable neighbors callback iterator method to the\n * Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachFindNeighbor(Class, description) {\n  const {name, type, direction} = description;\n\n  const capitalizedSingular = name[0].toUpperCase() + name.slice(1, -1);\n\n  const findName = 'find' + capitalizedSingular;\n\n  /**\n   * Function iterating over all the relevant neighbors using a callback.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {undefined}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[findName] = function (node, callback) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type) return;\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${findName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return forEachNeighbor(\n      true,\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData,\n      callback\n    );\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if any of them\n   * matches the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const someName = 'some' + capitalizedSingular;\n\n  Class.prototype[someName] = function (node, callback) {\n    const found = this[findName](node, callback);\n\n    if (found) return true;\n\n    return false;\n  };\n\n  /**\n   * Function iterating over all the relevant neighbors to find if all of them\n   * matche the given predicate.\n   *\n   * @param  {any}      node     - Target node.\n   * @param  {function} callback - Callback to use.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  const everyName = 'every' + capitalizedSingular;\n\n  Class.prototype[everyName] = function (node, callback) {\n    const found = this[findName](node, (n, a) => {\n      return !callback(n, a);\n    });\n\n    if (found) return false;\n\n    return true;\n  };\n}\n\n/**\n * Function attaching a neighbors callback iterator method to the Graph prototype.\n *\n * @param {function} Class       - Target class.\n * @param {object}   description - Method description.\n */\nfunction attachNeighborIteratorCreator(Class, description) {\n  const {name, type, direction} = description;\n\n  const iteratorName = name.slice(0, -1) + 'Entries';\n\n  /**\n   * Function returning an iterator over all the relevant neighbors.\n   *\n   * @param  {any}      node     - Target node.\n   * @return {Iterator}\n   *\n   * @throws {Error} - Will throw if there are too many arguments.\n   */\n  Class.prototype[iteratorName] = function (node) {\n    // Early termination\n    if (type !== 'mixed' && this.type !== 'mixed' && type !== this.type)\n      return emptyIterator();\n\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (typeof nodeData === 'undefined')\n      throw new NotFoundGraphError(\n        `Graph.${iteratorName}: could not find the \"${node}\" node in the graph.`\n      );\n\n    // Here, we want to iterate over a node's relevant neighbors\n    return createNeighborIterator(\n      type === 'mixed' ? this.type : type,\n      direction,\n      nodeData\n    );\n  };\n}\n\n/**\n * Function attaching every neighbor iteration method to the Graph class.\n *\n * @param {function} Graph - Graph class.\n */\nfunction attachNeighborIterationMethods(Graph) {\n  NEIGHBORS_ITERATION.forEach(description => {\n    attachNeighborArrayCreator(Graph, description);\n    attachForEachNeighbor(Graph, description);\n    attachFindNeighbor(Graph, description);\n    attachNeighborIteratorCreator(Graph, description);\n  });\n}\n\n/**\n * Graphology Adjacency Iteration\n * ===============================\n *\n * Attaching some methods to the Graph class to be able to iterate over a\n * graph's adjacency.\n */\n\n/**\n * Function iterating over a simple graph's adjacency using a callback.\n *\n * @param {boolean}  breakable         - Can we break?\n * @param {boolean}  assymetric        - Whether to emit undirected edges only once.\n * @param {boolean}  disconnectedNodes - Whether to emit disconnected nodes.\n * @param {Graph}    graph             - Target Graph instance.\n * @param {callback} function          - Iteration callback.\n */\nfunction forEachAdjacency(\n  breakable,\n  assymetric,\n  disconnectedNodes,\n  graph,\n  callback\n) {\n  const iterator = graph._nodes.values();\n\n  const type = graph.type;\n\n  let step, sourceData, neighbor, adj, edgeData, targetData, shouldBreak;\n\n  while (((step = iterator.next()), step.done !== true)) {\n    let hasEdges = false;\n\n    sourceData = step.value;\n\n    if (type !== 'undirected') {\n      adj = sourceData.out;\n\n      for (neighbor in adj) {\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (type !== 'directed') {\n      adj = sourceData.undirected;\n\n      for (neighbor in adj) {\n        if (assymetric && sourceData.key > neighbor) continue;\n\n        edgeData = adj[neighbor];\n\n        do {\n          targetData = edgeData.target;\n\n          if (targetData.key !== neighbor) targetData = edgeData.source;\n\n          hasEdges = true;\n          shouldBreak = callback(\n            sourceData.key,\n            targetData.key,\n            sourceData.attributes,\n            targetData.attributes,\n            edgeData.key,\n            edgeData.attributes,\n            edgeData.undirected\n          );\n\n          if (breakable && shouldBreak) return edgeData;\n\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (disconnectedNodes && !hasEdges) {\n      shouldBreak = callback(\n        sourceData.key,\n        null,\n        sourceData.attributes,\n        null,\n        null,\n        null,\n        null\n      );\n\n      if (breakable && shouldBreak) return null;\n    }\n  }\n\n  return;\n}\n\n/**\n * Graphology Serialization Utilities\n * ===================================\n *\n * Collection of functions used by the graph serialization schemes.\n */\n\n/**\n * Formats internal node data into a serialized node.\n *\n * @param  {any}    key  - The node's key.\n * @param  {object} data - Internal node's data.\n * @return {array}       - The serialized node.\n */\nfunction serializeNode(key, data) {\n  const serialized = {key};\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  return serialized;\n}\n\n/**\n * Formats internal edge data into a serialized edge.\n *\n * @param  {string} type - The graph's type.\n * @param  {any}    key  - The edge's key.\n * @param  {object} data - Internal edge's data.\n * @return {array}       - The serialized edge.\n */\nfunction serializeEdge(type, key, data) {\n  const serialized = {\n    key,\n    source: data.source.key,\n    target: data.target.key\n  };\n\n  if (!isEmpty(data.attributes))\n    serialized.attributes = assign({}, data.attributes);\n\n  if (type === 'mixed' && data.undirected) serialized.undirected = true;\n\n  return serialized;\n}\n\n/**\n * Checks whether the given value is a serialized node.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedNode(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized node. A serialized node should be a plain object with at least a \"key\" property.'\n    );\n\n  if (!('key' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized node is missing its key.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n}\n\n/**\n * Checks whether the given value is a serialized edge.\n *\n * @param  {mixed} value - Target value.\n * @return {string|null}\n */\nfunction validateSerializedEdge(value) {\n  if (!isPlainObject(value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a \"source\" & \"target\" property.'\n    );\n\n  if (!('source' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its source.'\n    );\n\n  if (!('target' in value))\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: serialized edge is missing its target.'\n    );\n\n  if (\n    'attributes' in value &&\n    (!isPlainObject(value.attributes) || value.attributes === null)\n  )\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.'\n    );\n\n  if ('undirected' in value && typeof value.undirected !== 'boolean')\n    throw new InvalidArgumentsGraphError(\n      'Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.'\n    );\n}\n\n/* eslint no-nested-ternary: 0 */\n\n/**\n * Constants.\n */\nconst INSTANCE_ID = incrementalIdStartingFromRandomByte();\n\n/**\n * Enums.\n */\nconst TYPES = new Set(['directed', 'undirected', 'mixed']);\n\nconst EMITTER_PROPS = new Set([\n  'domain',\n  '_events',\n  '_eventsCount',\n  '_maxListeners'\n]);\n\nconst EDGE_ADD_METHODS = [\n  {\n    name: verb => `${verb}Edge`,\n    generateKey: true\n  },\n  {\n    name: verb => `${verb}DirectedEdge`,\n    generateKey: true,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdge`,\n    generateKey: true,\n    type: 'undirected'\n  },\n  {\n    name: verb => `${verb}EdgeWithKey`\n  },\n  {\n    name: verb => `${verb}DirectedEdgeWithKey`,\n    type: 'directed'\n  },\n  {\n    name: verb => `${verb}UndirectedEdgeWithKey`,\n    type: 'undirected'\n  }\n];\n\n/**\n * Default options.\n */\nconst DEFAULTS = {\n  allowSelfLoops: true,\n  multi: false,\n  type: 'mixed'\n};\n\n/**\n * Abstract functions used by the Graph class for various methods.\n */\n\n/**\n * Internal method used to add a node to the given graph\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {any}     node            - The node's key.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {NodeData}                - Created node data.\n */\nfunction addNode(graph, node, attributes) {\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.addNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // String coercion\n  node = '' + node;\n  attributes = attributes || {};\n\n  if (graph._nodes.has(node))\n    throw new UsageGraphError(\n      `Graph.addNode: the \"${node}\" node already exist in the graph.`\n    );\n\n  const data = new graph.NodeDataClass(node, attributes);\n\n  // Adding the node to internal register\n  graph._nodes.set(node, data);\n\n  // Emitting\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Same as the above but without sanity checks because we call this in contexts\n * where necessary checks were already done.\n */\nfunction unsafeAddNode(graph, node, attributes) {\n  const data = new graph.NodeDataClass(node, attributes);\n\n  graph._nodes.set(node, data);\n\n  graph.emit('nodeAdded', {\n    key: node,\n    attributes\n  });\n\n  return data;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction addEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes && !isPlainObject(attributes))\n    throw new InvalidArgumentsGraphError(\n      `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n    );\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n  attributes = attributes || {};\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  const sourceData = graph._nodes.get(source),\n    targetData = graph._nodes.get(target);\n\n  if (!sourceData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: source node \"${source}\" not found.`\n    );\n\n  if (!targetData)\n    throw new NotFoundGraphError(\n      `Graph.${name}: target node \"${target}\" not found.`\n    );\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  // Here, we might have a source / target collision\n  if (\n    !graph.multi &&\n    (undirected\n      ? typeof sourceData.undirected[target] !== 'undefined'\n      : typeof sourceData.out[target] !== 'undefined')\n  ) {\n    throw new UsageGraphError(\n      `Graph.${name}: an edge linking \"${source}\" to \"${target}\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`\n    );\n  }\n\n  // Storing some data\n  const edgeData = new EdgeData(\n    undirected,\n    edge,\n    sourceData,\n    targetData,\n    attributes\n  );\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return edge;\n}\n\n/**\n * Internal method used to add an arbitrary edge to the given graph.\n *\n * @param  {Graph}   graph           - Target graph.\n * @param  {string}  name            - Name of the child method for errors.\n * @param  {boolean} mustGenerateKey - Should the graph generate an id?\n * @param  {boolean} undirected      - Whether the edge is undirected.\n * @param  {any}     edge            - The edge's key.\n * @param  {any}     source          - The source node.\n * @param  {any}     target          - The target node.\n * @param  {object}  [attributes]    - Optional attributes.\n * @param  {boolean} [asUpdater]       - Are we updating or merging?\n * @return {any}                     - The edge.\n *\n * @throws {Error} - Will throw if the graph is of the wrong type.\n * @throws {Error} - Will throw if the given attributes are not an object.\n * @throws {Error} - Will throw if source or target doesn't exist.\n * @throws {Error} - Will throw if the edge already exist.\n */\nfunction mergeEdge(\n  graph,\n  name,\n  mustGenerateKey,\n  undirected,\n  edge,\n  source,\n  target,\n  attributes,\n  asUpdater\n) {\n  // Checking validity of operation\n  if (!undirected && graph.type === 'undirected')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`\n    );\n\n  if (undirected && graph.type === 'directed')\n    throw new UsageGraphError(\n      `Graph.${name}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`\n    );\n\n  if (attributes) {\n    if (asUpdater) {\n      if (typeof attributes !== 'function')\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid updater function. Expecting a function but got \"${attributes}\"`\n        );\n    } else {\n      if (!isPlainObject(attributes))\n        throw new InvalidArgumentsGraphError(\n          `Graph.${name}: invalid attributes. Expecting an object but got \"${attributes}\"`\n        );\n    }\n  }\n\n  // Coercion of source & target:\n  source = '' + source;\n  target = '' + target;\n\n  let updater;\n\n  if (asUpdater) {\n    updater = attributes;\n    attributes = undefined;\n  }\n\n  if (!graph.allowSelfLoops && source === target)\n    throw new UsageGraphError(\n      `Graph.${name}: source & target are the same (\"${source}\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`\n    );\n\n  let sourceData = graph._nodes.get(source);\n  let targetData = graph._nodes.get(target);\n  let edgeData;\n\n  // Do we need to handle duplicate?\n  let alreadyExistingEdgeData;\n\n  if (!mustGenerateKey) {\n    edgeData = graph._edges.get(edge);\n\n    if (edgeData) {\n      // Here, we need to ensure, if the user gave a key, that source & target\n      // are consistent\n      if (edgeData.source.key !== source || edgeData.target.key !== target) {\n        // If source or target inconsistent\n        if (\n          !undirected ||\n          edgeData.source.key !== target ||\n          edgeData.target.key !== source\n        ) {\n          // If directed, or source/target aren't flipped\n          throw new UsageGraphError(\n            `Graph.${name}: inconsistency detected when attempting to merge the \"${edge}\" edge with \"${source}\" source & \"${target}\" target vs. (\"${edgeData.source.key}\", \"${edgeData.target.key}\").`\n          );\n        }\n      }\n\n      alreadyExistingEdgeData = edgeData;\n    }\n  }\n\n  // Here, we might have a source / target collision\n  if (!alreadyExistingEdgeData && !graph.multi && sourceData) {\n    alreadyExistingEdgeData = undirected\n      ? sourceData.undirected[target]\n      : sourceData.out[target];\n  }\n\n  // Handling duplicates\n  if (alreadyExistingEdgeData) {\n    const info = [alreadyExistingEdgeData.key, false, false, false];\n\n    // We can skip the attribute merging part if the user did not provide them\n    if (asUpdater ? !updater : !attributes) return info;\n\n    // Updating the attributes\n    if (asUpdater) {\n      const oldAttributes = alreadyExistingEdgeData.attributes;\n      alreadyExistingEdgeData.attributes = updater(oldAttributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'replace',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes\n      });\n    }\n\n    // Merging the attributes\n    else {\n      assign(alreadyExistingEdgeData.attributes, attributes);\n\n      graph.emit('edgeAttributesUpdated', {\n        type: 'merge',\n        key: alreadyExistingEdgeData.key,\n        attributes: alreadyExistingEdgeData.attributes,\n        data: attributes\n      });\n    }\n\n    return info;\n  }\n\n  attributes = attributes || {};\n\n  if (asUpdater && updater) attributes = updater(attributes);\n\n  // Must the graph generate an id for this edge?\n  const eventData = {\n    key: null,\n    undirected,\n    source,\n    target,\n    attributes\n  };\n\n  if (mustGenerateKey) {\n    // NOTE: in this case we can guarantee that the key does not already\n    // exist and is already correctly casted as a string\n    edge = graph._edgeKeyGenerator();\n  } else {\n    // Coercion of edge key\n    edge = '' + edge;\n\n    // Here, we have a key collision\n    if (graph._edges.has(edge))\n      throw new UsageGraphError(\n        `Graph.${name}: the \"${edge}\" edge already exists in the graph.`\n      );\n  }\n\n  let sourceWasAdded = false;\n  let targetWasAdded = false;\n\n  if (!sourceData) {\n    sourceData = unsafeAddNode(graph, source, {});\n    sourceWasAdded = true;\n\n    if (source === target) {\n      targetData = sourceData;\n      targetWasAdded = true;\n    }\n  }\n  if (!targetData) {\n    targetData = unsafeAddNode(graph, target, {});\n    targetWasAdded = true;\n  }\n\n  // Storing some data\n  edgeData = new EdgeData(undirected, edge, sourceData, targetData, attributes);\n\n  // Adding the edge to the internal register\n  graph._edges.set(edge, edgeData);\n\n  // Incrementing node degree counters\n  const isSelfLoop = source === target;\n\n  if (undirected) {\n    sourceData.undirectedDegree++;\n    targetData.undirectedDegree++;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops++;\n      graph._undirectedSelfLoopCount++;\n    }\n  } else {\n    sourceData.outDegree++;\n    targetData.inDegree++;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops++;\n      graph._directedSelfLoopCount++;\n    }\n  }\n\n  // Updating relevant index\n  if (graph.multi) edgeData.attachMulti();\n  else edgeData.attach();\n\n  if (undirected) graph._undirectedSize++;\n  else graph._directedSize++;\n\n  // Emitting\n  eventData.key = edge;\n\n  graph.emit('edgeAdded', eventData);\n\n  return [edge, true, sourceWasAdded, targetWasAdded];\n}\n\n/**\n * Internal method used to drop an edge.\n *\n * @param  {Graph}    graph    - Target graph.\n * @param  {EdgeData} edgeData - Data of the edge to drop.\n */\nfunction dropEdgeFromData(graph, edgeData) {\n  // Dropping the edge from the register\n  graph._edges.delete(edgeData.key);\n\n  // Updating related degrees\n  const {source: sourceData, target: targetData, attributes} = edgeData;\n\n  const undirected = edgeData.undirected;\n\n  const isSelfLoop = sourceData === targetData;\n\n  if (undirected) {\n    sourceData.undirectedDegree--;\n    targetData.undirectedDegree--;\n\n    if (isSelfLoop) {\n      sourceData.undirectedLoops--;\n      graph._undirectedSelfLoopCount--;\n    }\n  } else {\n    sourceData.outDegree--;\n    targetData.inDegree--;\n\n    if (isSelfLoop) {\n      sourceData.directedLoops--;\n      graph._directedSelfLoopCount--;\n    }\n  }\n\n  // Clearing index\n  if (graph.multi) edgeData.detachMulti();\n  else edgeData.detach();\n\n  if (undirected) graph._undirectedSize--;\n  else graph._directedSize--;\n\n  // Emitting\n  graph.emit('edgeDropped', {\n    key: edgeData.key,\n    attributes,\n    source: sourceData.key,\n    target: targetData.key,\n    undirected\n  });\n}\n\n/**\n * Graph class\n *\n * @constructor\n * @param  {object}  [options] - Options:\n * @param  {boolean}   [allowSelfLoops] - Allow self loops?\n * @param  {string}    [type]           - Type of the graph.\n * @param  {boolean}   [map]            - Allow references as keys?\n * @param  {boolean}   [multi]          - Allow parallel edges?\n *\n * @throws {Error} - Will throw if the arguments are not valid.\n */\nclass Graph extends events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter {\n  constructor(options) {\n    super();\n\n    //-- Solving options\n    options = assign({}, DEFAULTS, options);\n\n    // Enforcing options validity\n    if (typeof options.multi !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"${options.multi}\".`\n      );\n\n    if (!TYPES.has(options.type))\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'type' option. Should be one of \"mixed\", \"directed\" or \"undirected\" but got \"${options.type}\".`\n      );\n\n    if (typeof options.allowSelfLoops !== 'boolean')\n      throw new InvalidArgumentsGraphError(\n        `Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"${options.allowSelfLoops}\".`\n      );\n\n    //-- Private properties\n\n    // Utilities\n    const NodeDataClass =\n      options.type === 'mixed'\n        ? MixedNodeData\n        : options.type === 'directed'\n        ? DirectedNodeData\n        : UndirectedNodeData;\n\n    privateProperty(this, 'NodeDataClass', NodeDataClass);\n\n    // Internal edge key generator\n\n    // NOTE: this internal generator produce keys that are strings\n    // composed of a weird prefix, an incremental instance id starting from\n    // a random byte and finally an internal instance incremental id.\n    // All this to avoid intra-frame and cross-frame adversarial inputs\n    // that can force a single #.addEdge call to degenerate into a O(n)\n    // available key search loop.\n\n    // It also ensures that automatically generated edge keys are unlikely\n    // to produce collisions with arbitrary keys given by users.\n    const instancePrefix = 'geid_' + INSTANCE_ID() + '_';\n    let edgeId = 0;\n\n    const edgeKeyGenerator = () => {\n      let availableEdgeKey;\n\n      do {\n        availableEdgeKey = instancePrefix + edgeId++;\n      } while (this._edges.has(availableEdgeKey));\n\n      return availableEdgeKey;\n    };\n\n    // Indexes\n    privateProperty(this, '_attributes', {});\n    privateProperty(this, '_nodes', new Map());\n    privateProperty(this, '_edges', new Map());\n    privateProperty(this, '_directedSize', 0);\n    privateProperty(this, '_undirectedSize', 0);\n    privateProperty(this, '_directedSelfLoopCount', 0);\n    privateProperty(this, '_undirectedSelfLoopCount', 0);\n    privateProperty(this, '_edgeKeyGenerator', edgeKeyGenerator);\n\n    // Options\n    privateProperty(this, '_options', options);\n\n    // Emitter properties\n    EMITTER_PROPS.forEach(prop => privateProperty(this, prop, this[prop]));\n\n    //-- Properties readers\n    readOnlyProperty(this, 'order', () => this._nodes.size);\n    readOnlyProperty(this, 'size', () => this._edges.size);\n    readOnlyProperty(this, 'directedSize', () => this._directedSize);\n    readOnlyProperty(this, 'undirectedSize', () => this._undirectedSize);\n    readOnlyProperty(\n      this,\n      'selfLoopCount',\n      () => this._directedSelfLoopCount + this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'directedSelfLoopCount',\n      () => this._directedSelfLoopCount\n    );\n    readOnlyProperty(\n      this,\n      'undirectedSelfLoopCount',\n      () => this._undirectedSelfLoopCount\n    );\n    readOnlyProperty(this, 'multi', this._options.multi);\n    readOnlyProperty(this, 'type', this._options.type);\n    readOnlyProperty(this, 'allowSelfLoops', this._options.allowSelfLoops);\n    readOnlyProperty(this, 'implementation', () => 'graphology');\n  }\n\n  _resetInstanceCounters() {\n    this._directedSize = 0;\n    this._undirectedSize = 0;\n    this._directedSelfLoopCount = 0;\n    this._undirectedSelfLoopCount = 0;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Read\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning whether the given node is found in the graph.\n   *\n   * @param  {any}     node - The node.\n   * @return {boolean}\n   */\n  hasNode(node) {\n    return this._nodes.has('' + node);\n  }\n\n  /**\n   * Method returning whether the given directed edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasDirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'undirected') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && !edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.out.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given undirected edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasUndirectedEdge(source, target) {\n    // Early termination\n    if (this.type === 'directed') return false;\n\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      const edgeData = this._edges.get(edge);\n\n      return !!edgeData && edgeData.undirected;\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return nodeData.undirected.hasOwnProperty(target);\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning whether the given edge is found in the graph.\n   *\n   * Arity 1:\n   * @param  {any}     edge - The edge's key.\n   *\n   * Arity 2:\n   * @param  {any}     source - The edge's source.\n   * @param  {any}     target - The edge's target.\n   *\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the arguments are invalid.\n   */\n  hasEdge(source, target) {\n    if (arguments.length === 1) {\n      const edge = '' + source;\n\n      return this._edges.has(edge);\n    } else if (arguments.length === 2) {\n      source = '' + source;\n      target = '' + target;\n\n      // If the node source or the target is not in the graph we break\n      const nodeData = this._nodes.get(source);\n\n      if (!nodeData) return false;\n\n      // Is there a directed edge pointing toward target?\n      return (\n        (typeof nodeData.out !== 'undefined' &&\n          nodeData.out.hasOwnProperty(target)) ||\n        (typeof nodeData.undirected !== 'undefined' &&\n          nodeData.undirected.hasOwnProperty(target))\n      );\n    }\n\n    throw new InvalidArgumentsGraphError(\n      `Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`\n    );\n  }\n\n  /**\n   * Method returning the edge matching source & target in a directed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  directedEdge(source, target) {\n    if (this.type === 'undirected') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.directedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData = (sourceData.out && sourceData.out[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a undirected fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  undirectedEdge(source, target) {\n    if (this.type === 'directed') return;\n\n    source = '' + source;\n    target = '' + target;\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.'\n      );\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.undirectedEdge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.undirected && sourceData.undirected[target]) || undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning the edge matching source & target in a mixed fashion.\n   *\n   * @param  {any} source - The edge's source.\n   * @param  {any} target - The edge's target.\n   *\n   * @return {any|undefined}\n   *\n   * @throws {Error} - Will throw if the graph is multi.\n   * @throws {Error} - Will throw if source or target doesn't exist.\n   */\n  edge(source, target) {\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const sourceData = this._nodes.get(source);\n\n    if (!sourceData)\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${source}\" source node in the graph.`\n      );\n\n    if (!this._nodes.has(target))\n      throw new NotFoundGraphError(\n        `Graph.edge: could not find the \"${target}\" target node in the graph.`\n      );\n\n    const edgeData =\n      (sourceData.out && sourceData.out[target]) ||\n      (sourceData.undirected && sourceData.undirected[target]) ||\n      undefined;\n\n    if (edgeData) return edgeData.key;\n  }\n\n  /**\n   * Method returning whether two nodes are directed neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areDirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areDirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in || neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are out neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.out;\n  }\n\n  /**\n   * Method returning whether two nodes are in neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return false;\n\n    return neighbor in nodeData.in;\n  }\n\n  /**\n   * Method returning whether two nodes are undirected neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areUndirectedNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areUndirectedNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return false;\n\n    return neighbor in nodeData.undirected;\n  }\n\n  /**\n   * Method returning whether two nodes are neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in || neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are inbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areInboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areInboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.in) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether two nodes are outbound neighbors.\n   *\n   * @param  {any}     node     - The node's key.\n   * @param  {any}     neighbor - The neighbor's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  areOutboundNeighbors(node, neighbor) {\n    node = '' + node;\n    neighbor = '' + neighbor;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.areOutboundNeighbors: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type !== 'undirected') {\n      if (neighbor in nodeData.out) return true;\n    }\n\n    if (this.type !== 'directed') {\n      if (neighbor in nodeData.undirected) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning the given node's in degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree;\n  }\n\n  /**\n   * Method returning the given node's out degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree;\n  }\n\n  /**\n   * Method returning the given node's undirected degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree;\n  }\n\n  /**\n   * Method returning the given node's inbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's outbound degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's directed degree.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degree(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degree: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n    }\n\n    return degree;\n  }\n\n  /**\n   * Method returning the given node's in degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's out degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.outDegree - nodeData.directedLoops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  directedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.directedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'undirected') return 0;\n\n    return nodeData.inDegree + nodeData.outDegree - nodeData.directedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's undirected degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's in degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  undirectedDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.undirectedDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    if (this.type === 'directed') return 0;\n\n    return nodeData.undirectedDegree - nodeData.undirectedLoops * 2;\n  }\n\n  /**\n   * Method returning the given node's inbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's inbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  inboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.inboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's outbound degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's outbound degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  outboundDegreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.outboundDegreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.outDegree;\n      loops += nodeData.directedLoops;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given node's directed degree without considering self loops.\n   *\n   * @param  {any}     node - The node's key.\n   * @return {number}       - The node's degree.\n   *\n   * @throws {Error} - Will throw if the node isn't in the graph.\n   */\n  degreeWithoutSelfLoops(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.degreeWithoutSelfLoops: could not find the \"${node}\" node in the graph.`\n      );\n\n    let degree = 0;\n    let loops = 0;\n\n    if (this.type !== 'directed') {\n      degree += nodeData.undirectedDegree;\n      loops += nodeData.undirectedLoops * 2;\n    }\n\n    if (this.type !== 'undirected') {\n      degree += nodeData.inDegree + nodeData.outDegree;\n      loops += nodeData.directedLoops * 2;\n    }\n\n    return degree - loops;\n  }\n\n  /**\n   * Method returning the given edge's source.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's source.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  source(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.source: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key;\n  }\n\n  /**\n   * Method returning the given edge's target.\n   *\n   * @param  {any} edge - The edge's key.\n   * @return {any}      - The edge's target.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  target(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.target: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.target.key;\n  }\n\n  /**\n   * Method returning the given edge's extremities.\n   *\n   * @param  {any}   edge - The edge's key.\n   * @return {array}      - The edge's extremities.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  extremities(edge) {\n    edge = '' + edge;\n\n    const edgeData = this._edges.get(edge);\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.extremities: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return [edgeData.source.key, edgeData.target.key];\n  }\n\n  /**\n   * Given a node & an edge, returns the other extremity of the edge.\n   *\n   * @param  {any}   node - The node's key.\n   * @param  {any}   edge - The edge's key.\n   * @return {any}        - The related node.\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph or if the\n   *                   edge & node are not related.\n   */\n  opposite(node, edge) {\n    node = '' + node;\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.opposite: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    const source = data.source.key;\n    const target = data.target.key;\n\n    if (node === source) return target;\n    if (node === target) return source;\n\n    throw new NotFoundGraphError(\n      `Graph.opposite: the \"${node}\" node is not attached to the \"${edge}\" edge (${source}, ${target}).`\n    );\n  }\n\n  /**\n   * Returns whether the given edge has the given node as extremity.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @param  {any}     node - The node's key.\n   * @return {boolean}      - The related node.\n   *\n   * @throws {Error} - Will throw if either the node or the edge isn't in the graph.\n   */\n  hasExtremity(edge, node) {\n    edge = '' + edge;\n    node = '' + node;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.hasExtremity: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source.key === node || data.target.key === node;\n  }\n\n  /**\n   * Method returning whether the given edge is undirected.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isUndirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isUndirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is directed.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isDirected(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isDirected: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return !data.undirected;\n  }\n\n  /**\n   * Method returning whether the given edge is a self loop.\n   *\n   * @param  {any}     edge - The edge's key.\n   * @return {boolean}\n   *\n   * @throws {Error} - Will throw if the edge isn't in the graph.\n   */\n  isSelfLoop(edge) {\n    edge = '' + edge;\n\n    const data = this._edges.get(edge);\n\n    if (!data)\n      throw new NotFoundGraphError(\n        `Graph.isSelfLoop: could not find the \"${edge}\" edge in the graph.`\n      );\n\n    return data.source === data.target;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Mutation\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to add a node to the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   *\n   * @throws {Error} - Will throw if the given node already exist.\n   * @throws {Error} - Will throw if the given attributes are not an object.\n   */\n  addNode(node, attributes) {\n    const nodeData = addNode(this, node, attributes);\n\n    return nodeData.key;\n  }\n\n  /**\n   * Method used to merge a node into the graph.\n   *\n   * @param  {any}    node         - The node.\n   * @param  {object} [attributes] - Optional attributes.\n   * @return {any}                 - The node.\n   */\n  mergeNode(node, attributes) {\n    if (attributes && !isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        `Graph.mergeNode: invalid attributes. Expecting an object but got \"${attributes}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n    attributes = attributes || {};\n\n    // If the node already exists, we merge the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (attributes) {\n        assign(data.attributes, attributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'merge',\n          key: node,\n          attributes: data.attributes,\n          data: attributes\n        });\n      }\n      return [node, false];\n    }\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to add a node if it does not exist in the graph or else to\n   * update its attributes using a function.\n   *\n   * @param  {any}      node      - The node.\n   * @param  {function} [updater] - Optional updater function.\n   * @return {any}                - The node.\n   */\n  updateNode(node, updater) {\n    if (updater && typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        `Graph.updateNode: invalid updater function. Expecting a function but got \"${updater}\"`\n      );\n\n    // String coercion\n    node = '' + node;\n\n    // If the node already exists, we update the attributes\n    let data = this._nodes.get(node);\n\n    if (data) {\n      if (updater) {\n        const oldAttributes = data.attributes;\n        data.attributes = updater(oldAttributes);\n\n        this.emit('nodeAttributesUpdated', {\n          type: 'replace',\n          key: node,\n          attributes: data.attributes\n        });\n      }\n      return [node, false];\n    }\n\n    const attributes = updater ? updater({}) : {};\n\n    data = new this.NodeDataClass(node, attributes);\n\n    // Adding the node to internal register\n    this._nodes.set(node, data);\n\n    // Emitting\n    this.emit('nodeAdded', {\n      key: node,\n      attributes\n    });\n\n    return [node, true];\n  }\n\n  /**\n   * Method used to drop a single node & all its attached edges from the graph.\n   *\n   * @param  {any}    node - The node.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the node doesn't exist.\n   */\n  dropNode(node) {\n    node = '' + node;\n\n    const nodeData = this._nodes.get(node);\n\n    if (!nodeData)\n      throw new NotFoundGraphError(\n        `Graph.dropNode: could not find the \"${node}\" node in the graph.`\n      );\n\n    let edgeData;\n\n    // Removing attached edges\n    // NOTE: we could be faster here, but this is such a pain to maintain\n    if (this.type !== 'undirected') {\n      for (const neighbor in nodeData.out) {\n        edgeData = nodeData.out[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n\n      for (const neighbor in nodeData.in) {\n        edgeData = nodeData.in[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    if (this.type !== 'directed') {\n      for (const neighbor in nodeData.undirected) {\n        edgeData = nodeData.undirected[neighbor];\n\n        do {\n          dropEdgeFromData(this, edgeData);\n          edgeData = edgeData.next;\n        } while (edgeData);\n      }\n    }\n\n    // Dropping the node from the register\n    this._nodes.delete(node);\n\n    // Emitting\n    this.emit('nodeDropped', {\n      key: node,\n      attributes: nodeData.attributes\n    });\n  }\n\n  /**\n   * Method used to drop a single edge from the graph.\n   *\n   * Arity 1:\n   * @param  {any}    edge - The edge.\n   *\n   * Arity 2:\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropEdge(edge) {\n    let edgeData;\n\n    if (arguments.length > 1) {\n      const source = '' + arguments[0];\n      const target = '' + arguments[1];\n\n      edgeData = getMatchingEdge(this, source, target, this.type);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${source}\" -> \"${target}\" edge in the graph.`\n        );\n    } else {\n      edge = '' + edge;\n\n      edgeData = this._edges.get(edge);\n\n      if (!edgeData)\n        throw new NotFoundGraphError(\n          `Graph.dropEdge: could not find the \"${edge}\" edge in the graph.`\n        );\n    }\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single directed edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropDirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    source = '' + source;\n    target = '' + target;\n\n    const edgeData = getMatchingEdge(this, source, target, 'directed');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropDirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to drop a single undirected edge from the graph.\n   *\n   * @param  {any}    source - Source node.\n   * @param  {any}    target - Target node.\n   *\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if the edge doesn't exist.\n   */\n  dropUndirectedEdge(source, target) {\n    if (arguments.length < 2)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.'\n      );\n\n    if (this.multi)\n      throw new UsageGraphError(\n        'Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.'\n      );\n\n    const edgeData = getMatchingEdge(this, source, target, 'undirected');\n\n    if (!edgeData)\n      throw new NotFoundGraphError(\n        `Graph.dropUndirectedEdge: could not find a \"${source}\" -> \"${target}\" edge in the graph.`\n      );\n\n    dropEdgeFromData(this, edgeData);\n\n    return this;\n  }\n\n  /**\n   * Method used to remove every edge & every node from the graph.\n   *\n   * @return {Graph}\n   */\n  clear() {\n    // Clearing edges\n    this._edges.clear();\n\n    // Clearing nodes\n    this._nodes.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('cleared');\n  }\n\n  /**\n   * Method used to remove every edge from the graph.\n   *\n   * @return {Graph}\n   */\n  clearEdges() {\n    // Clearing structure index\n    const iterator = this._nodes.values();\n\n    let step;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      step.value.clear();\n    }\n\n    // Clearing edges\n    this._edges.clear();\n\n    // Reset counters\n    this._resetInstanceCounters();\n\n    // Emitting\n    this.emit('edgesCleared');\n  }\n\n  /**---------------------------------------------------------------------------\n   * Attributes-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning the desired graph's attribute.\n   *\n   * @param  {string} name - Name of the attribute.\n   * @return {any}\n   */\n  getAttribute(name) {\n    return this._attributes[name];\n  }\n\n  /**\n   * Method returning the graph's attributes.\n   *\n   * @return {object}\n   */\n  getAttributes() {\n    return this._attributes;\n  }\n\n  /**\n   * Method returning whether the graph has the desired attribute.\n   *\n   * @param  {string}  name - Name of the attribute.\n   * @return {boolean}\n   */\n  hasAttribute(name) {\n    return this._attributes.hasOwnProperty(name);\n  }\n\n  /**\n   * Method setting a value for the desired graph's attribute.\n   *\n   * @param  {string}  name  - Name of the attribute.\n   * @param  {any}     value - Value for the attribute.\n   * @return {Graph}\n   */\n  setAttribute(name, value) {\n    this._attributes[name] = value;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method using a function to update the desired graph's attribute's value.\n   *\n   * @param  {string}   name    - Name of the attribute.\n   * @param  {function} updater - Function use to update the attribute's value.\n   * @return {Graph}\n   */\n  updateAttribute(name, updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttribute: updater should be a function.'\n      );\n\n    const value = this._attributes[name];\n\n    this._attributes[name] = updater(value);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'set',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method removing the desired graph's attribute.\n   *\n   * @param  {string} name  - Name of the attribute.\n   * @return {Graph}\n   */\n  removeAttribute(name) {\n    delete this._attributes[name];\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'remove',\n      attributes: this._attributes,\n      name\n    });\n\n    return this;\n  }\n\n  /**\n   * Method replacing the graph's attributes.\n   *\n   * @param  {object} attributes - New attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  replaceAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.replaceAttributes: provided attributes are not a plain object.'\n      );\n\n    this._attributes = attributes;\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'replace',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method merging the graph's attributes.\n   *\n   * @param  {object} attributes - Attributes to merge.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given attributes are not a plain object.\n   */\n  mergeAttributes(attributes) {\n    if (!isPlainObject(attributes))\n      throw new InvalidArgumentsGraphError(\n        'Graph.mergeAttributes: provided attributes are not a plain object.'\n      );\n\n    assign(this._attributes, attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'merge',\n      attributes: this._attributes,\n      data: attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method updating the graph's attributes.\n   *\n   * @param  {function} updater - Function used to update the attributes.\n   * @return {Graph}\n   *\n   * @throws {Error} - Will throw if given updater is not a function.\n   */\n  updateAttributes(updater) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateAttributes: provided updater is not a function.'\n      );\n\n    this._attributes = updater(this._attributes);\n\n    // Emitting\n    this.emit('attributesUpdated', {\n      type: 'update',\n      attributes: this._attributes\n    });\n\n    return this;\n  }\n\n  /**\n   * Method used to update each node's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachNodeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      nodeData.attributes = updater(nodeData.key, nodeData.attributes);\n    }\n\n    this.emit('eachNodeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**\n   * Method used to update each edge's attributes using the given function.\n   *\n   * @param {function}  updater - Updater function to use.\n   * @param {object}    [hints] - Optional hints.\n   */\n  updateEachEdgeAttributes(updater, hints) {\n    if (typeof updater !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: expecting an updater function.'\n      );\n\n    if (hints && !validateHints(hints))\n      throw new InvalidArgumentsGraphError(\n        'Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}'\n      );\n\n    const iterator = this._edges.values();\n\n    let step, edgeData, sourceData, targetData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n      sourceData = edgeData.source;\n      targetData = edgeData.target;\n\n      edgeData.attributes = updater(\n        edgeData.key,\n        edgeData.attributes,\n        sourceData.key,\n        targetData.key,\n        sourceData.attributes,\n        targetData.attributes,\n        edgeData.undirected\n      );\n    }\n\n    this.emit('eachEdgeAttributesUpdated', {\n      hints: hints ? hints : null\n    });\n  }\n\n  /**---------------------------------------------------------------------------\n   * Iteration-related methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method iterating over the graph's adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, false, this, callback);\n  }\n  forEachAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, false, true, this, callback);\n  }\n\n  /**\n   * Method iterating over the graph's assymetric adjacency using the given callback.\n   *\n   * @param  {function}  callback - Callback to use.\n   */\n  forEachAssymetricAdjacencyEntry(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntry: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, false, this, callback);\n  }\n  forEachAssymetricAdjacencyEntryWithOrphans(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.'\n      );\n\n    forEachAdjacency(false, true, true, this, callback);\n  }\n\n  /**\n   * Method returning the list of the graph's nodes.\n   *\n   * @return {array} - The nodes.\n   */\n  nodes() {\n    return Array.from(this._nodes.keys());\n  }\n\n  /**\n   * Method iterating over the graph's nodes using the given callback.\n   *\n   * @param  {function}  callback - Callback (key, attributes, index).\n   */\n  forEachNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.forEachNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      callback(nodeData.key, nodeData.attributes);\n    }\n  }\n\n  /**\n   * Method iterating attempting to find a node matching the given predicate\n   * function.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  findNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.findNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return nodeData.key;\n    }\n\n    return;\n  }\n\n  /**\n   * Method mapping nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  mapNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.mapNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = new Array(this.order);\n    let i = 0;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      result[i++] = callback(nodeData.key, nodeData.attributes);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method returning whether some node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  someNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.someNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Method returning whether all node verify the given predicate.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  everyNode(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.everyNode: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (!callback(nodeData.key, nodeData.attributes)) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Method filtering nodes.\n   *\n   * @param  {function}  callback - Callback (key, attributes).\n   */\n  filterNodes(callback) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.filterNodes: expecting a callback.'\n      );\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    const result = [];\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n\n      if (callback(nodeData.key, nodeData.attributes))\n        result.push(nodeData.key);\n    }\n\n    return result;\n  }\n\n  /**\n   * Method reducing nodes.\n   *\n   * @param  {function}  callback - Callback (accumulator, key, attributes).\n   */\n  reduceNodes(callback, initialValue) {\n    if (typeof callback !== 'function')\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: expecting a callback.'\n      );\n\n    if (arguments.length < 2)\n      throw new InvalidArgumentsGraphError(\n        'Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.'\n      );\n\n    let accumulator = initialValue;\n\n    const iterator = this._nodes.values();\n\n    let step, nodeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      nodeData = step.value;\n      accumulator = callback(accumulator, nodeData.key, nodeData.attributes);\n    }\n\n    return accumulator;\n  }\n\n  /**\n   * Method returning an iterator over the graph's node entries.\n   *\n   * @return {Iterator}\n   */\n  nodeEntries() {\n    const iterator = this._nodes.values();\n\n    return {\n      [Symbol.iterator]() {\n        return this;\n      },\n      next() {\n        const step = iterator.next();\n        if (step.done) return step;\n        const data = step.value;\n        return {\n          value: {node: data.key, attributes: data.attributes},\n          done: false\n        };\n      }\n    };\n  }\n\n  /**---------------------------------------------------------------------------\n   * Serialization\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used to export the whole graph.\n   *\n   * @return {object} - The serialized graph.\n   */\n  export() {\n    const nodes = new Array(this._nodes.size);\n\n    let i = 0;\n\n    this._nodes.forEach((data, key) => {\n      nodes[i++] = serializeNode(key, data);\n    });\n\n    const edges = new Array(this._edges.size);\n\n    i = 0;\n\n    this._edges.forEach((data, key) => {\n      edges[i++] = serializeEdge(this.type, key, data);\n    });\n\n    return {\n      options: {\n        type: this.type,\n        multi: this.multi,\n        allowSelfLoops: this.allowSelfLoops\n      },\n      attributes: this.getAttributes(),\n      nodes,\n      edges\n    };\n  }\n\n  /**\n   * Method used to import a serialized graph.\n   *\n   * @param  {object|Graph} data  - The serialized graph.\n   * @param  {boolean}      merge - Whether to merge data.\n   * @return {Graph}              - Returns itself for chaining.\n   */\n  import(data, merge = false) {\n    // Importing a Graph instance directly\n    if (data instanceof Graph) {\n      // Nodes\n      data.forEachNode((n, a) => {\n        if (merge) this.mergeNode(n, a);\n        else this.addNode(n, a);\n      });\n\n      // Edges\n      data.forEachEdge((e, a, s, t, _sa, _ta, u) => {\n        if (merge) {\n          if (u) this.mergeUndirectedEdgeWithKey(e, s, t, a);\n          else this.mergeDirectedEdgeWithKey(e, s, t, a);\n        } else {\n          if (u) this.addUndirectedEdgeWithKey(e, s, t, a);\n          else this.addDirectedEdgeWithKey(e, s, t, a);\n        }\n      });\n\n      return this;\n    }\n\n    // Importing a serialized graph\n    if (!isPlainObject(data))\n      throw new InvalidArgumentsGraphError(\n        'Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.'\n      );\n\n    if (data.attributes) {\n      if (!isPlainObject(data.attributes))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid attributes. Expecting a plain object.'\n        );\n\n      if (merge) this.mergeAttributes(data.attributes);\n      else this.replaceAttributes(data.attributes);\n    }\n\n    let i, l, list, node, edge;\n\n    if (data.nodes) {\n      list = data.nodes;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid nodes. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        node = list[i];\n\n        // Validating\n        validateSerializedNode(node);\n\n        // Adding the node\n        const {key, attributes} = node;\n\n        if (merge) this.mergeNode(key, attributes);\n        else this.addNode(key, attributes);\n      }\n    }\n\n    if (data.edges) {\n      let undirectedByDefault = false;\n\n      if (this.type === 'undirected') {\n        undirectedByDefault = true;\n      }\n\n      list = data.edges;\n\n      if (!Array.isArray(list))\n        throw new InvalidArgumentsGraphError(\n          'Graph.import: invalid edges. Expecting an array.'\n        );\n\n      for (i = 0, l = list.length; i < l; i++) {\n        edge = list[i];\n\n        // Validating\n        validateSerializedEdge(edge);\n\n        // Adding the edge\n        const {\n          source,\n          target,\n          attributes,\n          undirected = undirectedByDefault\n        } = edge;\n\n        let method;\n\n        if ('key' in edge) {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdgeWithKey\n              : this.mergeDirectedEdgeWithKey\n            : undirected\n            ? this.addUndirectedEdgeWithKey\n            : this.addDirectedEdgeWithKey;\n\n          method.call(this, edge.key, source, target, attributes);\n        } else {\n          method = merge\n            ? undirected\n              ? this.mergeUndirectedEdge\n              : this.mergeDirectedEdge\n            : undirected\n            ? this.addUndirectedEdge\n            : this.addDirectedEdge;\n\n          method.call(this, source, target, attributes);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Utils\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method returning a null copy of the graph, i.e. a graph without nodes\n   * & edges but with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The null copy.\n   */\n  nullCopy(options) {\n    const graph = new Graph(assign({}, this._options, options));\n    graph.replaceAttributes(assign({}, this.getAttributes()));\n    return graph;\n  }\n\n  /**\n   * Method returning an empty copy of the graph, i.e. a graph without edges but\n   * with the exact same options.\n   *\n   * @param  {object} options - Options to merge with the current ones.\n   * @return {Graph}          - The empty copy.\n   */\n  emptyCopy(options) {\n    const graph = this.nullCopy(options);\n\n    this._nodes.forEach((nodeData, key) => {\n      const attributes = assign({}, nodeData.attributes);\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      nodeData = new graph.NodeDataClass(key, attributes);\n      graph._nodes.set(key, nodeData);\n    });\n\n    return graph;\n  }\n\n  /**\n   * Method returning an exact copy of the graph.\n   *\n   * @param  {object} options - Upgrade options.\n   * @return {Graph}          - The copy.\n   */\n  copy(options) {\n    options = options || {};\n\n    if (\n      typeof options.type === 'string' &&\n      options.type !== this.type &&\n      options.type !== 'mixed'\n    )\n      throw new UsageGraphError(\n        `Graph.copy: cannot create an incompatible copy from \"${this.type}\" type to \"${options.type}\" because this would mean losing information about the current graph.`\n      );\n\n    if (\n      typeof options.multi === 'boolean' &&\n      options.multi !== this.multi &&\n      options.multi !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.'\n      );\n\n    if (\n      typeof options.allowSelfLoops === 'boolean' &&\n      options.allowSelfLoops !== this.allowSelfLoops &&\n      options.allowSelfLoops !== true\n    )\n      throw new UsageGraphError(\n        'Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.'\n      );\n\n    const graph = this.emptyCopy(options);\n\n    const iterator = this._edges.values();\n\n    let step, edgeData;\n\n    while (((step = iterator.next()), step.done !== true)) {\n      edgeData = step.value;\n\n      // NOTE: no need to emit events since user cannot access the instance yet\n      addEdge(\n        graph,\n        'copy',\n        false,\n        edgeData.undirected,\n        edgeData.key,\n        edgeData.source.key,\n        edgeData.target.key,\n        assign({}, edgeData.attributes)\n      );\n    }\n\n    return graph;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Known methods\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Method used by JavaScript to perform JSON serialization.\n   *\n   * @return {object} - The serialized graph.\n   */\n  toJSON() {\n    return this.export();\n  }\n\n  /**\n   * Method returning [object Graph].\n   */\n  toString() {\n    return '[object Graph]';\n  }\n\n  /**\n   * Method used internally by node's console to display a custom object.\n   *\n   * @return {object} - Formatted object representation of the graph.\n   */\n  inspect() {\n    const nodes = {};\n    this._nodes.forEach((data, key) => {\n      nodes[key] = data.attributes;\n    });\n\n    const edges = {},\n      multiIndex = {};\n\n    this._edges.forEach((data, key) => {\n      const direction = data.undirected ? '--' : '->';\n\n      let label = '';\n\n      let source = data.source.key;\n      let target = data.target.key;\n      let tmp;\n\n      if (data.undirected && source > target) {\n        tmp = source;\n        source = target;\n        target = tmp;\n      }\n\n      const desc = `(${source})${direction}(${target})`;\n\n      if (!key.startsWith('geid_')) {\n        label += `[${key}]: `;\n      } else if (this.multi) {\n        if (typeof multiIndex[desc] === 'undefined') {\n          multiIndex[desc] = 0;\n        } else {\n          multiIndex[desc]++;\n        }\n\n        label += `${multiIndex[desc]}. `;\n      }\n\n      label += desc;\n\n      edges[label] = data.attributes;\n    });\n\n    const dummy = {};\n\n    for (const k in this) {\n      if (\n        this.hasOwnProperty(k) &&\n        !EMITTER_PROPS.has(k) &&\n        typeof this[k] !== 'function' &&\n        typeof k !== 'symbol'\n      )\n        dummy[k] = this[k];\n    }\n\n    dummy.attributes = this._attributes;\n    dummy.nodes = nodes;\n    dummy.edges = edges;\n\n    privateProperty(dummy, 'constructor', this.constructor);\n\n    return dummy;\n  }\n}\n\n/**\n * Attaching methods to the prototype.\n *\n * Here, we are attaching a wide variety of methods to the Graph class'\n * prototype when those are very numerous and when their creation is\n * abstracted.\n */\n\n/**\n * Attaching custom inspect method for node >= 10.\n */\nif (typeof Symbol !== 'undefined')\n  Graph.prototype[Symbol.for('nodejs.util.inspect.custom')] =\n    Graph.prototype.inspect;\n\n/**\n * Related to edge addition.\n */\nEDGE_ADD_METHODS.forEach(method => {\n  ['add', 'merge', 'update'].forEach(verb => {\n    const name = method.name(verb);\n    const fn = verb === 'add' ? addEdge : mergeEdge;\n\n    if (method.generateKey) {\n      Graph.prototype[name] = function (source, target, attributes) {\n        return fn(\n          this,\n          name,\n          true,\n          (method.type || this.type) === 'undirected',\n          null,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    } else {\n      Graph.prototype[name] = function (edge, source, target, attributes) {\n        return fn(\n          this,\n          name,\n          false,\n          (method.type || this.type) === 'undirected',\n          edge,\n          source,\n          target,\n          attributes,\n          verb === 'update'\n        );\n      };\n    }\n  });\n});\n\n/**\n * Attributes-related.\n */\nattachNodeAttributesMethods(Graph);\nattachEdgeAttributesMethods(Graph);\n\n/**\n * Edge iteration-related.\n */\nattachEdgeIterationMethods(Graph);\n\n/**\n * Neighbor iteration-related.\n */\nattachNeighborIterationMethods(Graph);\n\n/**\n * Graphology Helper Classes\n * ==========================\n *\n * Building some higher-order classes instantiating the graph with\n * predefinite options.\n */\n\n/**\n * Alternative constructors.\n */\nclass DirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'DirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass UndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected'}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== false)\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'UndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiDirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'directed', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'directed')\n      throw new InvalidArgumentsGraphError(\n        'MultiDirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\nclass MultiUndirectedGraph extends Graph {\n  constructor(options) {\n    const finalOptions = assign({type: 'undirected', multi: true}, options);\n\n    if ('multi' in finalOptions && finalOptions.multi !== true)\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!'\n      );\n\n    if (finalOptions.type !== 'undirected')\n      throw new InvalidArgumentsGraphError(\n        'MultiUndirectedGraph.from: inconsistent \"' +\n          finalOptions.type +\n          '\" type in given options!'\n      );\n\n    super(finalOptions);\n  }\n}\n\n/**\n * Attaching static #.from method to each of the constructors.\n */\nfunction attachStaticFromMethod(Class) {\n  /**\n   * Builds a graph from serialized data or another graph's data.\n   *\n   * @param  {Graph|SerializedGraph} data      - Hydratation data.\n   * @param  {object}                [options] - Options.\n   * @return {Class}\n   */\n  Class.from = function (data, options) {\n    // Merging given options with serialized ones\n    const finalOptions = assign({}, data.options, options);\n\n    const instance = new Class(finalOptions);\n    instance.import(data);\n\n    return instance;\n  };\n}\n\nattachStaticFromMethod(Graph);\nattachStaticFromMethod(DirectedGraph);\nattachStaticFromMethod(UndirectedGraph);\nattachStaticFromMethod(MultiGraph);\nattachStaticFromMethod(MultiDirectedGraph);\nattachStaticFromMethod(MultiUndirectedGraph);\n\nGraph.Graph = Graph;\nGraph.DirectedGraph = DirectedGraph;\nGraph.UndirectedGraph = UndirectedGraph;\nGraph.MultiGraph = MultiGraph;\nGraph.MultiDirectedGraph = MultiDirectedGraph;\nGraph.MultiUndirectedGraph = MultiUndirectedGraph;\n\nGraph.InvalidArgumentsGraphError = InvalidArgumentsGraphError;\nGraph.NotFoundGraphError = NotFoundGraphError;\nGraph.UsageGraphError = UsageGraphError;\n\n/**\n * Graphology ESM Endoint\n * =======================\n *\n * Endpoint for ESM modules consumers.\n */\n\n\n//# sourceMappingURL=graphology.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5L2Rpc3QvZ3JhcGhvbG9neS5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBc0M7O0FBRXRDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDLE9BQU87QUFDL0M7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGFBQWE7QUFDeEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsT0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUEsV0FBVyxpQ0FBaUM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7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Q0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksVUFBVTtBQUN0QixZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLHdCQUF3QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZ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QUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsU0FBUztBQUN2QixjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVO0FBQ3hCLGNBQWMsVUFBVTtBQUN4QixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYztBQUNkO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QixjQUFjO0FBQ2Q7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixhQUFhLFdBQVc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5R0FBeUcsc0JBQXNCO0FBQy9IOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlHQUF5RyxzQkFBc0I7QUFDL0g7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsNENBQTRDO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCLGNBQWMsY0FBYztBQUM1QixjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLE9BQU87QUFDMUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGVBQWUsaUJBQWlCOztBQUVoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQ0FBbUMsT0FBTztBQUMxQzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckMscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxnQkFBZ0I7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsZ0JBQWdCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVSxhQUFhLGFBQWE7QUFDcEc7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUIsT0FBTyxHQUFHLFVBQVUsR0FBRyxPQUFPOztBQUVyRDtBQUNBLHFCQUFxQixJQUFJO0FBQ3pCLFFBQVE7QUFDUjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1CQUFtQjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsWUFBWTs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyw4QkFBOEI7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGdDQUFnQzs7QUFFakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWMsdUJBQXVCO0FBQ3JDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFMEw7QUFDMUwiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcbGVub3ZvXFxEZXNrdG9wXFxmcm9udGVuZFxcZnJvbnRlbmRcXG5vZGVfbW9kdWxlc1xcZ3JhcGhvbG9neVxcZGlzdFxcZ3JhcGhvbG9neS5tanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBHcmFwaG9sb2d5IFV0aWxpdGllc1xuICogPT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29sbGVjdGlvbiBvZiBoZWxwZnVsIGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIE9iamVjdC5hc3NpZ24tbGlrZSBwb2x5ZmlsbC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHRhcmdldCAgICAgICAtIEZpcnN0IG9iamVjdC5cbiAqIEBwYXJhbSAge29iamVjdH0gWy4uLm9iamVjdHNdIC0gT2JqZWN0cyB0byBtZXJnZS5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gYXNzaWduUG9seWZpbGwoKSB7XG4gIGNvbnN0IHRhcmdldCA9IGFyZ3VtZW50c1swXTtcblxuICBmb3IgKGxldCBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoIWFyZ3VtZW50c1tpXSkgY29udGludWU7XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gYXJndW1lbnRzW2ldKSB0YXJnZXRba10gPSBhcmd1bWVudHNbaV1ba107XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5sZXQgYXNzaWduID0gYXNzaWduUG9seWZpbGw7XG5cbmlmICh0eXBlb2YgT2JqZWN0LmFzc2lnbiA9PT0gJ2Z1bmN0aW9uJykgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxuLyoqXG4gKiBGdW5jdGlvbiByZXR1cm5pbmcgdGhlIGZpcnN0IG1hdGNoaW5nIGVkZ2UgZm9yIGdpdmVuIHBhdGguXG4gKiBOb3RlOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNoZWNrIHRoZSBleGlzdGVuY2Ugb2Ygc291cmNlICYgdGFyZ2V0LiBUaGlzXG4gKiBtdXN0IGJlIHBlcmZvcm1lZCBieSB0aGUgY2FsbGVyLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgZ3JhcGggIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7YW55fSAgICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9IHR5cGUgICAtIFR5cGUgb2YgdGhlIGVkZ2UgKG1peGVkLCBkaXJlY3RlZCBvciB1bmRpcmVjdGVkKS5cbiAqIEByZXR1cm4ge3N0cmluZ3xudWxsfVxuICovXG5mdW5jdGlvbiBnZXRNYXRjaGluZ0VkZ2UoZ3JhcGgsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKSB7XG4gIGNvbnN0IHNvdXJjZURhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgbGV0IGVkZ2UgPSBudWxsO1xuXG4gIGlmICghc291cmNlRGF0YSkgcmV0dXJuIGVkZ2U7XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcpIHtcbiAgICBlZGdlID1cbiAgICAgIChzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdKSB8fFxuICAgICAgKHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2RpcmVjdGVkJykge1xuICAgIGVkZ2UgPSBzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdO1xuICB9IGVsc2Uge1xuICAgIGVkZ2UgPSBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgJiYgc291cmNlRGF0YS51bmRpcmVjdGVkW3RhcmdldF07XG4gIH1cblxuICByZXR1cm4gZWRnZTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKlxuICogQHBhcmFtICB7bWl4ZWR9ICAgdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gIC8vIE5PVEU6IGFzIHBlciBodHRwczovL2dpdGh1Yi5jb20vZ3JhcGhvbG9neS9ncmFwaG9sb2d5L2lzc3Vlcy8xNDlcbiAgLy8gdGhpcyBmdW5jdGlvbiBoYXMgYmVlbiBsb29zZW5lZCBub3QgdG8gcmVqZWN0IG9iamVjdCBpbnN0YW5jZXNcbiAgLy8gY29taW5nIGZyb20gb3RoZXIgSmF2YVNjcmlwdCBjb250ZXh0cy4gSXQgaGFzIGFsc28gYmVlbiBjaG9zZW5cbiAgLy8gbm90IHRvIGltcHJvdmUgaXQgdG8gYXZvaWQgb2J2aW91cyBmYWxzZSBwb3NpdGl2ZXMgYW5kIGF2b2lkXG4gIC8vIHRha2luZyBhIHBlcmZvcm1hbmNlIGhpdC4gUGVvcGxlIHNob3VsZCByZWFsbHkgdXNlIFR5cGVTY3JpcHRcbiAgLy8gaWYgdGhleSB3YW50IHRvIGF2b2lkIGZlZWRpbmcgc3VidGx5IGlycmVsdmFudCBhdHRyaWJ1dGUgb2JqZWN0cy5cbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGw7XG59XG5cbi8qKlxuICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIG9iamVjdCBpcyBlbXB0eS5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBvIC0gVGFyZ2V0IE9iamVjdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkobykge1xuICBsZXQgaztcblxuICBmb3IgKGsgaW4gbykgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBcInByaXZhdGVcIiBwcm9wZXJ0eSBmb3IgdGhlIGdpdmVuIG1lbWJlciBuYW1lIGJ5IGNvbmNlYWxpbmcgaXRcbiAqIHVzaW5nIHRoZSBgZW51bWVyYWJsZWAgb3B0aW9uLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0YXJnZXQgLSBUYXJnZXQgb2JqZWN0LlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgICAtIE1lbWJlciBuYW1lLlxuICovXG5mdW5jdGlvbiBwcml2YXRlUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBuYW1lLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB2YWx1ZVxuICB9KTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgcmVhZC1vbmx5IHByb3BlcnR5IGZvciB0aGUgZ2l2ZW4gbWVtYmVyIG5hbWUgJiB0aGUgZ2l2ZW4gZ2V0dGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIHRhcmdldCAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBuYW1lICAgLSBNZW1iZXIgbmFtZS5cbiAqIEBwYXJhbSB7bWl4ZWR9ICAgIHZhbHVlICAtIFRoZSBhdHRhY2hlZCBnZXR0ZXIgb3IgZml4ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHJlYWRPbmx5UHJvcGVydHkodGFyZ2V0LCBuYW1lLCB2YWx1ZSkge1xuICBjb25zdCBkZXNjcmlwdG9yID0ge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH07XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGRlc2NyaXB0b3IuZ2V0ID0gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgZGVzY3JpcHRvci52YWx1ZSA9IHZhbHVlO1xuICAgIGRlc2NyaXB0b3Iud3JpdGFibGUgPSBmYWxzZTtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufVxuXG4vKipcbiAqIFJldHVybnMgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGNvbnN0aXR1dGUgdmFsaWQgaGludHMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGhpbnRzIC0gVGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVIaW50cyhoaW50cykge1xuICBpZiAoIWlzUGxhaW5PYmplY3QoaGludHMpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKGhpbnRzLmF0dHJpYnV0ZXMgJiYgIUFycmF5LmlzQXJyYXkoaGludHMuYXR0cmlidXRlcykpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gZ2VuZXJhdGluZyBpbmNyZW1lbnRhbCBpZHMgZm9yIGVkZ2VzLlxuICpcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBpbmNyZW1lbnRhbElkU3RhcnRpbmdGcm9tUmFuZG9tQnl0ZSgpIHtcbiAgbGV0IGkgPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpICYgMHhmZjtcblxuICByZXR1cm4gKCkgPT4ge1xuICAgIHJldHVybiBpKys7XG4gIH07XG59XG5cbi8qKlxuICogQ2hhaW5zIG11bHRpcGxlIGl0ZXJhdG9ycyBpbnRvIGEgc2luZ2xlIGl0ZXJhdG9yLlxuICpcbiAqIEBwYXJhbSB7Li4uSXRlcmF0b3J9IGl0ZXJhYmxlc1xuICogQHJldHVybnMge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjaGFpbigpIHtcbiAgY29uc3QgaXRlcmFibGVzID0gYXJndW1lbnRzO1xuICBsZXQgY3VycmVudCA9IG51bGw7XG4gIGxldCBpID0gLTE7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGxldCBzdGVwID0gbnVsbDtcblxuICAgICAgZG8ge1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgIGkrKztcbiAgICAgICAgICBpZiAoaSA+PSBpdGVyYWJsZXMubGVuZ3RoKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgICAgICAgIGN1cnJlbnQgPSBpdGVyYWJsZXNbaV1bU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBjdXJyZW50Lm5leHQoKTtcbiAgICAgICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgICAgIGN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBlbXB0eUl0ZXJhdG9yKCkge1xuICByZXR1cm4ge1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBuZXh0KCkge1xuICAgICAgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBDdXN0b20gRXJyb3JzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRGVmaW5pbmcgY3VzdG9tIGVycm9ycyBmb3IgZWFzZSBvZiB1c2UgJiBlYXN5IHVuaXQgdGVzdHMgYWNyb3NzXG4gKiBpbXBsZW1lbnRhdGlvbnMgKG5vcm1hbGl6ZWQgdHlwb2xvZ3kgcmF0aGVyIHRoYW4gcmVseWluZyBvbiBlcnJvclxuICogbWVzc2FnZXMgdG8gY2hlY2sgd2hldGhlciB0aGUgY29ycmVjdCBlcnJvciB3YXMgZm91bmQpLlxuICovXG5jbGFzcyBHcmFwaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWUgPSAnR3JhcGhFcnJvcic7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxufVxuXG5jbGFzcyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvciBleHRlbmRzIEdyYXBoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yJztcblxuICAgIC8vIFRoaXMgaXMgVjggc3BlY2lmaWMgdG8gZW5oYW5jZSBzdGFjayByZWFkYWJpbGl0eVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShcbiAgICAgICAgdGhpcyxcbiAgICAgICAgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yXG4gICAgICApO1xuICB9XG59XG5cbmNsYXNzIE5vdEZvdW5kR3JhcGhFcnJvciBleHRlbmRzIEdyYXBoRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ05vdEZvdW5kR3JhcGhFcnJvcic7XG5cbiAgICAvLyBUaGlzIGlzIFY4IHNwZWNpZmljIHRvIGVuaGFuY2Ugc3RhY2sgcmVhZGFiaWxpdHlcbiAgICBpZiAodHlwZW9mIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlID09PSAnZnVuY3Rpb24nKVxuICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgTm90Rm91bmRHcmFwaEVycm9yLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcik7XG4gIH1cbn1cblxuY2xhc3MgVXNhZ2VHcmFwaEVycm9yIGV4dGVuZHMgR3JhcGhFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSAnVXNhZ2VHcmFwaEVycm9yJztcblxuICAgIC8vIFRoaXMgaXMgVjggc3BlY2lmaWMgdG8gZW5oYW5jZSBzdGFjayByZWFkYWJpbGl0eVxuICAgIGlmICh0eXBlb2YgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgPT09ICdmdW5jdGlvbicpXG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBVc2FnZUdyYXBoRXJyb3IucHJvdG90eXBlLmNvbnN0cnVjdG9yKTtcbiAgfVxufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgSW50ZXJuYWwgRGF0YSBDbGFzc2VzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBJbnRlcm5hbCBjbGFzc2VzIGhvcGVmdWxseSByZWR1Y2VkIHRvIHN0cnVjdHMgYnkgZW5naW5lcyAmIHN0b3JpbmdcbiAqIG5lY2Vzc2FyeSBpbmZvcm1hdGlvbiBmb3Igbm9kZXMgJiBlZGdlcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhvc2UgY2xhc3NlcyBkb24ndCByZWx5IG9uIHRoZSBgY2xhc3NgIGtleXdvcmQgdG8gYXZvaWQgc29tZVxuICogY3J1ZnQgaW50cm9kdWNlZCBieSBtb3N0IG9mIEVTMjAxNSB0cmFuc3BpbGVycy5cbiAqL1xuXG4vKipcbiAqIE1peGVkTm9kZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOb2RlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gTWl4ZWROb2RlRGF0YShrZXksIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICB0aGlzLmNsZWFyKCk7XG59XG5cbk1peGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMuaW5EZWdyZWUgPSAwO1xuICB0aGlzLm91dERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZExvb3BzID0gMDtcbiAgdGhpcy5kaXJlY3RlZExvb3BzID0gMDtcblxuICAvLyBJbmRpY2VzXG4gIHRoaXMuaW4gPSB7fTtcbiAgdGhpcy5vdXQgPSB7fTtcbiAgdGhpcy51bmRpcmVjdGVkID0ge307XG59O1xuXG4vKipcbiAqIERpcmVjdGVkTm9kZURhdGEgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICogQHBhcmFtIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOb2RlJ3MgYXR0cmlidXRlcy5cbiAqL1xuZnVuY3Rpb24gRGlyZWN0ZWROb2RlRGF0YShrZXksIGF0dHJpYnV0ZXMpIHtcbiAgLy8gQXR0cmlidXRlc1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICB0aGlzLmNsZWFyKCk7XG59XG5cbkRpcmVjdGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMuaW5EZWdyZWUgPSAwO1xuICB0aGlzLm91dERlZ3JlZSA9IDA7XG4gIHRoaXMuZGlyZWN0ZWRMb29wcyA9IDA7XG5cbiAgLy8gSW5kaWNlc1xuICB0aGlzLmluID0ge307XG4gIHRoaXMub3V0ID0ge307XG59O1xuXG4vKipcbiAqIFVuZGlyZWN0ZWROb2RlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gKiBAcGFyYW0ge29iamVjdH0gYXR0cmlidXRlcyAtIE5vZGUncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBVbmRpcmVjdGVkTm9kZURhdGEoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgdGhpcy5jbGVhcigpO1xufVxuXG5VbmRpcmVjdGVkTm9kZURhdGEucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAvLyBEZWdyZWVzXG4gIHRoaXMudW5kaXJlY3RlZERlZ3JlZSA9IDA7XG4gIHRoaXMudW5kaXJlY3RlZExvb3BzID0gMDtcblxuICAvLyBJbmRpY2VzXG4gIHRoaXMudW5kaXJlY3RlZCA9IHt9O1xufTtcblxuLyoqXG4gKiBFZGdlRGF0YSBjbGFzcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5kaXJlY3RlZCAgIC0gV2hldGhlciB0aGUgZWRnZSBpcyB1bmRpcmVjdGVkLlxuICogQHBhcmFtIHtzdHJpbmd9ICBzdHJpbmcgICAgICAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgc291cmNlICAgICAgIC0gU291cmNlIG9mIHRoZSBlZGdlLlxuICogQHBhcmFtIHtzdHJpbmd9ICB0YXJnZXQgICAgICAgLSBUYXJnZXQgb2YgdGhlIGVkZ2UuXG4gKiBAcGFyYW0ge29iamVjdH0gIGF0dHJpYnV0ZXMgICAtIEVkZ2UncyBhdHRyaWJ1dGVzLlxuICovXG5mdW5jdGlvbiBFZGdlRGF0YSh1bmRpcmVjdGVkLCBrZXksIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gIC8vIEF0dHJpYnV0ZXNcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gIHRoaXMudW5kaXJlY3RlZCA9IHVuZGlyZWN0ZWQ7XG5cbiAgLy8gRXh0cmVtaXRpZXNcbiAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xufVxuXG5FZGdlRGF0YS5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24gKCkge1xuICBsZXQgb3V0S2V5ID0gJ291dCc7XG4gIGxldCBpbktleSA9ICdpbic7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCkgb3V0S2V5ID0gaW5LZXkgPSAndW5kaXJlY3RlZCc7XG5cbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgLy8gSGFuZGxpbmcgc291cmNlXG4gIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XSA9IHRoaXM7XG5cbiAgaWYgKHRoaXMudW5kaXJlY3RlZCAmJiBzb3VyY2UgPT09IHRhcmdldCkgcmV0dXJuO1xuXG4gIC8vIEhhbmRsaW5nIHRhcmdldFxuICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXM7XG59O1xuXG5FZGdlRGF0YS5wcm90b3R5cGUuYXR0YWNoTXVsdGkgPSBmdW5jdGlvbiAoKSB7XG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBjb25zdCBzb3VyY2UgPSB0aGlzLnNvdXJjZS5rZXk7XG4gIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0LmtleTtcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICAvLyBIYW5kbGluZyBzb3VyY2VcbiAgY29uc3QgYWRqID0gdGhpcy5zb3VyY2Vbb3V0S2V5XTtcbiAgY29uc3QgaGVhZCA9IGFkalt0YXJnZXRdO1xuXG4gIGlmICh0eXBlb2YgaGVhZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBhZGpbdGFyZ2V0XSA9IHRoaXM7XG5cbiAgICAvLyBTZWxmLWxvb3Agb3B0aW1pemF0aW9uXG4gICAgaWYgKCEodGhpcy51bmRpcmVjdGVkICYmIHNvdXJjZSA9PT0gdGFyZ2V0KSkge1xuICAgICAgLy8gSGFuZGxpbmcgdGFyZ2V0XG4gICAgICB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXSA9IHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gUHJlcGVuZGluZyB0byBkb3VibHktbGlua2VkIGxpc3RcbiAgaGVhZC5wcmV2aW91cyA9IHRoaXM7XG4gIHRoaXMubmV4dCA9IGhlYWQ7XG5cbiAgLy8gUG9pbnRpbmcgdG8gbmV3IGhlYWRcbiAgLy8gTk9URTogdXNlIG11dGF0aW5nIHN3YXAgbGF0ZXIgdG8gYXZvaWQgbG9va3VwP1xuICBhZGpbdGFyZ2V0XSA9IHRoaXM7XG4gIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcztcbn07XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IHNvdXJjZSA9IHRoaXMuc291cmNlLmtleTtcbiAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXQua2V5O1xuXG4gIGxldCBvdXRLZXkgPSAnb3V0JztcbiAgbGV0IGluS2V5ID0gJ2luJztcblxuICBpZiAodGhpcy51bmRpcmVjdGVkKSBvdXRLZXkgPSBpbktleSA9ICd1bmRpcmVjdGVkJztcblxuICBkZWxldGUgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdO1xuXG4gIC8vIE5vLW9wIGRlbGV0ZSBpbiBjYXNlIG9mIHVuZGlyZWN0ZWQgc2VsZi1sb29wXG4gIGRlbGV0ZSB0aGlzLnRhcmdldFtpbktleV1bc291cmNlXTtcbn07XG5cbkVkZ2VEYXRhLnByb3RvdHlwZS5kZXRhY2hNdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc291cmNlID0gdGhpcy5zb3VyY2Uua2V5O1xuICBjb25zdCB0YXJnZXQgPSB0aGlzLnRhcmdldC5rZXk7XG5cbiAgbGV0IG91dEtleSA9ICdvdXQnO1xuICBsZXQgaW5LZXkgPSAnaW4nO1xuXG4gIGlmICh0aGlzLnVuZGlyZWN0ZWQpIG91dEtleSA9IGluS2V5ID0gJ3VuZGlyZWN0ZWQnO1xuXG4gIC8vIERlbGV0aW5nIGZyb20gZG91Ymx5LWxpbmtlZCBsaXN0XG4gIGlmICh0aGlzLnByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIHRoZSBoZWFkXG5cbiAgICAvLyBTaG91bGQgd2UgZGVsZXRlIHRoZSBhZGphY2VuY3kgZW50cnkgYmVjYXVzZSBpdCBpcyBub3cgZW1wdHk/XG4gICAgaWYgKHRoaXMubmV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWxldGUgdGhpcy5zb3VyY2Vbb3V0S2V5XVt0YXJnZXRdO1xuXG4gICAgICAvLyBOby1vcCBkZWxldGUgaW4gY2FzZSBvZiB1bmRpcmVjdGVkIHNlbGYtbG9vcFxuICAgICAgZGVsZXRlIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZXRhY2hpbmdcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gTk9URTogY291bGQgYXZvaWQgdGhlIGxvb2t1cHMgYnkgY3JlYXRpbmcgYSAjLmJlY29tZSBtdXRhdGluZyBtZXRob2RcbiAgICAgIHRoaXMuc291cmNlW291dEtleV1bdGFyZ2V0XSA9IHRoaXMubmV4dDtcblxuICAgICAgLy8gTm8tb3AgZGVsZXRlIGluIGNhc2Ugb2YgdW5kaXJlY3RlZCBzZWxmLWxvb3BcbiAgICAgIHRoaXMudGFyZ2V0W2luS2V5XVtzb3VyY2VdID0gdGhpcy5uZXh0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhcmUgZGVhbGluZyB3aXRoIGFub3RoZXIgbGlzdCBub2RlXG4gICAgdGhpcy5wcmV2aW91cy5uZXh0ID0gdGhpcy5uZXh0O1xuXG4gICAgLy8gSWYgbm90IGxhc3RcbiAgICBpZiAodGhpcy5uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubmV4dC5wcmV2aW91cyA9IHRoaXMucHJldmlvdXM7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgTm9kZSBBdHRyaWJ1dGVzIG1ldGhvZHNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuY29uc3QgTk9ERSA9IDA7XG5jb25zdCBTT1VSQ0UgPSAxO1xuY29uc3QgVEFSR0VUID0gMjtcbmNvbnN0IE9QUE9TSVRFID0gMztcblxuZnVuY3Rpb24gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gIGdyYXBoLFxuICBtZXRob2QsXG4gIG1vZGUsXG4gIG5vZGVPckVkZ2UsXG4gIG5hbWVPckVkZ2UsXG4gIGFkZDEsXG4gIGFkZDJcbikge1xuICBsZXQgbm9kZURhdGEsIGVkZ2VEYXRhLCBhcmcxLCBhcmcyO1xuXG4gIG5vZGVPckVkZ2UgPSAnJyArIG5vZGVPckVkZ2U7XG5cbiAgaWYgKG1vZGUgPT09IE5PREUpIHtcbiAgICBub2RlRGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQobm9kZU9yRWRnZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlT3JFZGdlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBhcmcxID0gbmFtZU9yRWRnZTtcbiAgICBhcmcyID0gYWRkMTtcbiAgfSBlbHNlIGlmIChtb2RlID09PSBPUFBPU0lURSkge1xuICAgIG5hbWVPckVkZ2UgPSAnJyArIG5hbWVPckVkZ2U7XG5cbiAgICBlZGdlRGF0YSA9IGdyYXBoLl9lZGdlcy5nZXQobmFtZU9yRWRnZSk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtuYW1lT3JFZGdlfVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBzb3VyY2UgPSBlZGdlRGF0YS5zb3VyY2Uua2V5O1xuICAgIGNvbnN0IHRhcmdldCA9IGVkZ2VEYXRhLnRhcmdldC5rZXk7XG5cbiAgICBpZiAobm9kZU9yRWRnZSA9PT0gc291cmNlKSB7XG4gICAgICBub2RlRGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcbiAgICB9IGVsc2UgaWYgKG5vZGVPckVkZ2UgPT09IHRhcmdldCkge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHRoZSBcIiR7bm9kZU9yRWRnZX1cIiBub2RlIGlzIG5vdCBhdHRhY2hlZCB0byB0aGUgXCIke25hbWVPckVkZ2V9XCIgZWRnZSAoJHtzb3VyY2V9LCAke3RhcmdldH0pLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgYXJnMSA9IGFkZDE7XG4gICAgYXJnMiA9IGFkZDI7XG4gIH0gZWxzZSB7XG4gICAgZWRnZURhdGEgPSBncmFwaC5fZWRnZXMuZ2V0KG5vZGVPckVkZ2UpO1xuXG4gICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZU9yRWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKG1vZGUgPT09IFNPVVJDRSkge1xuICAgICAgbm9kZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVEYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuICAgIH1cblxuICAgIGFyZzEgPSBuYW1lT3JFZGdlO1xuICAgIGFyZzIgPSBhZGQxO1xuICB9XG5cbiAgcmV0dXJuIFtub2RlRGF0YSwgYXJnMSwgYXJnMl07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVHZXR0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc0dldHRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UpIHtcbiAgICBjb25zdCBbZGF0YV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2VcbiAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuYXR0cmlidXRlcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZUNoZWNrZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KG5hbWUpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlU2V0dGVyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSwgYWRkMikge1xuICAgIGNvbnN0IFtkYXRhLCBuYW1lLCB2YWx1ZV0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxLFxuICAgICAgYWRkMlxuICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZVVwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxLCBhZGQyKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWUsIHVwZGF0ZXJdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMSxcbiAgICAgIGFkZDJcbiAgICApO1xuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiB1cGRhdGVyIHNob3VsZCBiZSBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gZGF0YS5hdHRyaWJ1dGVzO1xuICAgIGNvbnN0IHZhbHVlID0gdXBkYXRlcihhdHRyaWJ1dGVzW25hbWVdKTtcblxuICAgIGF0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZVJlbW92ZXIoQ2xhc3MsIG1ldGhvZCwgbW9kZSkge1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChub2RlT3JFZGdlLCBuYW1lT3JFZGdlLCBhZGQxKSB7XG4gICAgY29uc3QgW2RhdGEsIG5hbWVdID0gZmluZFJlbGV2YW50Tm9kZURhdGEoXG4gICAgICB0aGlzLFxuICAgICAgbWV0aG9kLFxuICAgICAgbW9kZSxcbiAgICAgIG5vZGVPckVkZ2UsXG4gICAgICBuYW1lT3JFZGdlLFxuICAgICAgYWRkMVxuICAgICk7XG5cbiAgICBkZWxldGUgZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBhdHRhY2hOb2RlQXR0cmlidXRlc1JlcGxhY2VyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBhdHRyaWJ1dGVzXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGRhdGEuYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnbm9kZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzTWVyZ2VyKENsYXNzLCBtZXRob2QsIG1vZGUpIHtcbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAobm9kZU9yRWRnZSwgbmFtZU9yRWRnZSwgYWRkMSkge1xuICAgIGNvbnN0IFtkYXRhLCBhdHRyaWJ1dGVzXSA9IGZpbmRSZWxldmFudE5vZGVEYXRhKFxuICAgICAgdGhpcyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIG1vZGUsXG4gICAgICBub2RlT3JFZGdlLFxuICAgICAgbmFtZU9yRWRnZSxcbiAgICAgIGFkZDFcbiAgICApO1xuXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuYFxuICAgICAgKTtcblxuICAgIGFzc2lnbihkYXRhLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGF0dGFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlcihDbGFzcywgbWV0aG9kLCBtb2RlKSB7XG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKG5vZGVPckVkZ2UsIG5hbWVPckVkZ2UsIGFkZDEpIHtcbiAgICBjb25zdCBbZGF0YSwgdXBkYXRlcl0gPSBmaW5kUmVsZXZhbnROb2RlRGF0YShcbiAgICAgIHRoaXMsXG4gICAgICBtZXRob2QsXG4gICAgICBtb2RlLFxuICAgICAgbm9kZU9yRWRnZSxcbiAgICAgIG5hbWVPckVkZ2UsXG4gICAgICBhZGQxXG4gICAgKTtcblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogcHJvdmlkZWQgdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogTGlzdCBvZiBtZXRob2RzIHRvIGF0dGFjaC5cbiAqL1xuY29uc3QgTk9ERV9BVFRSSUJVVEVTX01FVEhPRFMgPSBbXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZUdldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgZ2V0JHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc0dldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgaGFzJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVDaGVja2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBzZXQke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZVNldHRlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZWAsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVVcGRhdGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGByZW1vdmUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoTm9kZUF0dHJpYnV0ZVJlbW92ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlcGxhY2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaE5vZGVBdHRyaWJ1dGVzUmVwbGFjZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYG1lcmdlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc01lcmdlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgdXBkYXRlJHtlbGVtZW50fUF0dHJpYnV0ZXNgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZXJcbiAgfVxuXTtcblxuLyoqXG4gKiBBdHRhY2ggZXZlcnkgYXR0cmlidXRlcy1yZWxhdGVkIG1ldGhvZHMgdG8gYSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIFRhcmdldCBjbGFzcy5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTm9kZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKSB7XG4gIE5PREVfQVRUUklCVVRFU19NRVRIT0RTLmZvckVhY2goZnVuY3Rpb24gKHtuYW1lLCBhdHRhY2hlcn0pIHtcbiAgICAvLyBGb3Igbm9kZXNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnTm9kZScpLCBOT0RFKTtcblxuICAgIC8vIEZvciBzb3VyY2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ1NvdXJjZScpLCBTT1VSQ0UpO1xuXG4gICAgLy8gRm9yIHRhcmdldHNcbiAgICBhdHRhY2hlcihHcmFwaCwgbmFtZSgnVGFyZ2V0JyksIFRBUkdFVCk7XG5cbiAgICAvLyBGb3Igb3Bwb3NpdGVzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ09wcG9zaXRlJyksIE9QUE9TSVRFKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBFZGdlIEF0dHJpYnV0ZXMgbWV0aG9kc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgZ2V0dGVyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgbWV0aG9kICAgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZUdldHRlcihDbGFzcywgbWV0aG9kLCB0eXBlKSB7XG4gIC8qKlxuICAgKiBHZXQgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gbmFtZSAgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHttaXhlZH0gICAgICAgICAgLSBUaGUgYXR0cmlidXRlJ3MgdmFsdWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdG9vIG1hbnkgYXJndW1lbnRzIGFyZSBwcm92aWRlZC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBhbnkgb2YgdGhlIGVsZW1lbnRzIGlzIG5vdCBmb3VuZC5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24gKGVsZW1lbnQsIG5hbWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMikge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YS5hdHRyaWJ1dGVzW25hbWVdO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGVzIGdldHRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAtIE1ldGhvZCBuYW1lLlxuICogQHBhcmFtIHtzdHJpbmd9ICAgdHlwZSAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzR2V0dGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbGwgdGhlIHRhcmdldCBlbGVtZW50J3MgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAtIFRhcmdldCBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9ICAgICAgICAgIC0gVGhlIGVsZW1lbnQncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGFyZ3VtZW50c1sxXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBjaGVja2VyIG1ldGhvZCBvbnRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAtIFR5cGUgb2YgdGhlIGVkZ2UgdG8gZmluZC5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRWRnZUF0dHJpYnV0ZUNoZWNrZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGRlc2lyZWQgYXR0cmlidXRlIGlzIHNldCBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKlxuICAgKiBBcml0eSAzIChvbmx5IGZvciBlZGdlcyk6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBkYXRhLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSBzZXR0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlU2V0dGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFNldCB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICogQHBhcmFtICB7bWl4ZWR9ICB2YWx1ZSAgIC0gTmV3IGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqIEBwYXJhbSAge21peGVkfSAgdmFsdWUgICAtIE5ldyBhdHRyaWJ1dGUgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBsZXQgZGF0YTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgZmluZCB0aGlzIHR5cGUgb2YgZWRnZXMgaW4geW91ciAke3RoaXMudHlwZX0gZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMykge1xuICAgICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGFza2luZyBhYm91dCBhbiBlZGdlJ3MgYXR0cmlidXRlcyBpbiBhIE11bHRpR3JhcGggc2luY2Ugd2UgY2Fubm90IGluZmVyIHRoZSBvbmUgeW91IHdhbnQgaW5mb3JtYXRpb24gYWJvdXQuYFxuICAgICAgICApO1xuXG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBjb25zdCB0YXJnZXQgPSAnJyArIG5hbWU7XG5cbiAgICAgIG5hbWUgPSBhcmd1bWVudHNbMl07XG4gICAgICB2YWx1ZSA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRhdGEuYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgdXBkYXRlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVVcGRhdGVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpIHVzaW5nXG4gICAqIHRoZSBwcm92aWRlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSAgIG5hbWUgICAgLSBBdHRyaWJ1dGUncyBuYW1lLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBuYW1lLCB1cGRhdGVyKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gJycgKyBuYW1lO1xuXG4gICAgICBuYW1lID0gYXJndW1lbnRzWzJdO1xuICAgICAgdXBkYXRlciA9IGFyZ3VtZW50c1szXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzW25hbWVdID0gdXBkYXRlcihkYXRhLmF0dHJpYnV0ZXNbbmFtZV0pO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2VkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICB0eXBlOiAnc2V0JyxcbiAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xufVxuXG4vKipcbiAqIEF0dGFjaCBhbiBhdHRyaWJ1dGUgcmVtb3ZlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVSZW1vdmVyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIFJlbW92ZSB0aGUgZGVzaXJlZCBhdHRyaWJ1dGUgZm9yIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIGVsZW1lbnQgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBuYW1lICAgIC0gQXR0cmlidXRlJ3MgbmFtZS5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgICAtIEF0dHJpYnV0ZSdzIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgbmFtZSkge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudDtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgbmFtZTtcblxuICAgICAgbmFtZSA9IGFyZ3VtZW50c1syXTtcblxuICAgICAgZGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdHlwZSk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCBhbiBlZGdlIGZvciB0aGUgZ2l2ZW4gcGF0aCAoXCIke3NvdXJjZX1cIiAtIFwiJHt0YXJnZXR9XCIpLmBcbiAgICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGUgIT09ICdtaXhlZCcpXG4gICAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2FsbGluZyB0aGlzIG1ldGhvZCB3aXRoIG9ubHkgYSBrZXkgKHZzLiBhIHNvdXJjZSBhbmQgdGFyZ2V0KSBkb2VzIG5vdCBtYWtlIHNlbnNlIHNpbmNlIGFuIGVkZ2Ugd2l0aCB0aGlzIGtleSBjb3VsZCBoYXZlIHRoZSBvdGhlciB0eXBlLmBcbiAgICAgICAgKTtcblxuICAgICAgZWxlbWVudCA9ICcnICsgZWxlbWVudDtcbiAgICAgIGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWxlbWVudCk7XG5cbiAgICAgIGlmICghZGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VsZW1lbnR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH1cblxuICAgIGRlbGV0ZSBkYXRhLmF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdyZW1vdmUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5cbi8qKlxuICogQXR0YWNoIGFuIGF0dHJpYnV0ZSByZXBsYWNlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzUmVwbGFjZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogUmVwbGFjZSB0aGUgYXR0cmlidXRlcyBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgKG5vZGUgb3IgZWRnZSkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgZWxlbWVudCAgICAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBOZXcgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQXJpdHkgMyAob25seSBmb3IgZWRnZXMpOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgIC0gU291cmNlIGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7b2JqZWN0fSAgYXR0cmlidXRlcyAtIE5ldyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGF0dHJpYnV0ZXM7XG5cbiAgICAgIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgZGF0YS5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBrZXk6IGRhdGEua2V5LFxuICAgICAgdHlwZTogJ3JlcGxhY2UnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIG1lcmdlciBtZXRob2Qgb250byB0aGUgcHJvdmlkZWQgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIG1ldGhvZCAgICAgICAgLSBNZXRob2QgbmFtZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSAgIHR5cGUgICAgICAgICAgLSBUeXBlIG9mIHRoZSBlZGdlIHRvIGZpbmQuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWVyZ2VyKENsYXNzLCBtZXRob2QsIHR5cGUpIHtcbiAgLyoqXG4gICAqIE1lcmdlIHRoZSBhdHRyaWJ1dGVzIGZvciB0aGUgZ2l2ZW4gZWxlbWVudCAobm9kZSBvciBlZGdlKS5cbiAgICpcbiAgICogQXJpdHkgMjpcbiAgICogQHBhcmFtICB7YW55fSAgICBlbGVtZW50ICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIEF0dHJpYnV0ZXMgdG8gbWVyZ2UuXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgc291cmNlICAgICAtIFNvdXJjZSBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgIC0gVGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBwYXJhbSAge29iamVjdH0gIGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIG1lcmdlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAgIC0gUmV0dXJucyBpdHNlbGYgZm9yIGNoYWluaW5nLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRvbyBtYW55IGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgYW55IG9mIHRoZSBlbGVtZW50cyBpcyBub3QgZm91bmQuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uIChlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgbGV0IGRhdGE7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY2Fubm90IGZpbmQgdGhpcyB0eXBlIG9mIGVkZ2VzIGluIHlvdXIgJHt0aGlzLnR5cGV9IGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBhc2tpbmcgYWJvdXQgYW4gZWRnZSdzIGF0dHJpYnV0ZXMgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IGluZm9ybWF0aW9uIGFib3V0LmBcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgc291cmNlID0gJycgKyBlbGVtZW50LFxuICAgICAgICB0YXJnZXQgPSAnJyArIGF0dHJpYnV0ZXM7XG5cbiAgICAgIGF0dHJpYnV0ZXMgPSBhcmd1bWVudHNbMl07XG5cbiAgICAgIGRhdGEgPSBnZXRNYXRjaGluZ0VkZ2UodGhpcywgc291cmNlLCB0YXJnZXQsIHR5cGUpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgYW4gZWRnZSBmb3IgdGhlIGdpdmVuIHBhdGggKFwiJHtzb3VyY2V9XCIgLSBcIiR7dGFyZ2V0fVwiKS5gXG4gICAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnKVxuICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2l0aCBvbmx5IGEga2V5ICh2cy4gYSBzb3VyY2UgYW5kIHRhcmdldCkgZG9lcyBub3QgbWFrZSBzZW5zZSBzaW5jZSBhbiBlZGdlIHdpdGggdGhpcyBrZXkgY291bGQgaGF2ZSB0aGUgb3RoZXIgdHlwZS5gXG4gICAgICAgICk7XG5cbiAgICAgIGVsZW1lbnQgPSAnJyArIGVsZW1lbnQ7XG4gICAgICBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVsZW1lbnQpO1xuXG4gICAgICBpZiAoIWRhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bWV0aG9kfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtlbGVtZW50fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC5gXG4gICAgICApO1xuXG4gICAgYXNzaWduKGRhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICdtZXJnZScsXG4gICAgICBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXMsXG4gICAgICBkYXRhOiBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBBdHRhY2ggYW4gYXR0cmlidXRlIHVwZGF0ZXIgbWV0aG9kIG9udG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge3N0cmluZ30gICBtZXRob2QgICAgICAgIC0gTWV0aG9kIG5hbWUuXG4gKiBAcGFyYW0ge3N0cmluZ30gICB0eXBlICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZWRnZSB0byBmaW5kLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZXIoQ2xhc3MsIG1ldGhvZCwgdHlwZSkge1xuICAvKipcbiAgICogVXBkYXRlIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBnaXZlbiBlbGVtZW50IChub2RlIG9yIGVkZ2UpLlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgZWxlbWVudCAtIFRhcmdldCBlbGVtZW50LlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDMgKG9ubHkgZm9yIGVkZ2VzKTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgLSBTb3VyY2UgZWxlbWVudC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgLSBUYXJnZXQgZWxlbWVudC5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH0gICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0b28gbWFueSBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGFueSBvZiB0aGUgZWxlbWVudHMgaXMgbm90IGZvdW5kLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoZWxlbWVudCwgdXBkYXRlcikge1xuICAgIGxldCBkYXRhO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNhbm5vdCBmaW5kIHRoaXMgdHlwZSBvZiBlZGdlcyBpbiB5b3VyICR7dGhpcy50eXBlfSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYW5ub3QgdXNlIGEge3NvdXJjZSx0YXJnZXR9IGNvbWJvIHdoZW4gYXNraW5nIGFib3V0IGFuIGVkZ2UncyBhdHRyaWJ1dGVzIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCBpbmZvcm1hdGlvbiBhYm91dC5gXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IHNvdXJjZSA9ICcnICsgZWxlbWVudCxcbiAgICAgICAgdGFyZ2V0ID0gJycgKyB1cGRhdGVyO1xuXG4gICAgICB1cGRhdGVyID0gYXJndW1lbnRzWzJdO1xuXG4gICAgICBkYXRhID0gZ2V0TWF0Y2hpbmdFZGdlKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCB0eXBlKTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIGFuIGVkZ2UgZm9yIHRoZSBnaXZlbiBwYXRoIChcIiR7c291cmNlfVwiIC0gXCIke3RhcmdldH1cIikuYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZSAhPT0gJ21peGVkJylcbiAgICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHttZXRob2R9OiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpdGggb25seSBhIGtleSAodnMuIGEgc291cmNlIGFuZCB0YXJnZXQpIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugc2luY2UgYW4gZWRnZSB3aXRoIHRoaXMga2V5IGNvdWxkIGhhdmUgdGhlIG90aGVyIHR5cGUuYFxuICAgICAgICApO1xuXG4gICAgICBlbGVtZW50ID0gJycgKyBlbGVtZW50O1xuICAgICAgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlbGVtZW50KTtcblxuICAgICAgaWYgKCFkYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke21ldGhvZH06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWxlbWVudH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHttZXRob2R9OiBwcm92aWRlZCB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG5cbiAgICBkYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgIHR5cGU6ICd1cGRhdGUnLFxuICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIG1ldGhvZHMgdG8gYXR0YWNoLlxuICovXG5jb25zdCBFREdFX0FUVFJJQlVURVNfTUVUSE9EUyA9IFtcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYGdldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBnZXQke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzR2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGBoYXMke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZUNoZWNrZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHNldCR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlU2V0dGVyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZVVwZGF0ZXJcbiAgfSxcbiAge1xuICAgIG5hbWU6IGVsZW1lbnQgPT4gYHJlbW92ZSR7ZWxlbWVudH1BdHRyaWJ1dGVgLFxuICAgIGF0dGFjaGVyOiBhdHRhY2hFZGdlQXR0cmlidXRlUmVtb3ZlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgcmVwbGFjZSR7ZWxlbWVudH1BdHRyaWJ1dGVzYCxcbiAgICBhdHRhY2hlcjogYXR0YWNoRWRnZUF0dHJpYnV0ZXNSZXBsYWNlclxuICB9LFxuICB7XG4gICAgbmFtZTogZWxlbWVudCA9PiBgbWVyZ2Uke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzTWVyZ2VyXG4gIH0sXG4gIHtcbiAgICBuYW1lOiBlbGVtZW50ID0+IGB1cGRhdGUke2VsZW1lbnR9QXR0cmlidXRlc2AsXG4gICAgYXR0YWNoZXI6IGF0dGFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlclxuICB9XG5dO1xuXG4vKipcbiAqIEF0dGFjaCBldmVyeSBhdHRyaWJ1dGVzLXJlbGF0ZWQgbWV0aG9kcyB0byBhIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gVGFyZ2V0IGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpIHtcbiAgRURHRV9BVFRSSUJVVEVTX01FVEhPRFMuZm9yRWFjaChmdW5jdGlvbiAoe25hbWUsIGF0dGFjaGVyfSkge1xuICAgIC8vIEZvciBlZGdlc1xuICAgIGF0dGFjaGVyKEdyYXBoLCBuYW1lKCdFZGdlJyksICdtaXhlZCcpO1xuXG4gICAgLy8gRm9yIGRpcmVjdGVkIGVkZ2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ0RpcmVjdGVkRWRnZScpLCAnZGlyZWN0ZWQnKTtcblxuICAgIC8vIEZvciB1bmRpcmVjdGVkIGVkZ2VzXG4gICAgYXR0YWNoZXIoR3JhcGgsIG5hbWUoJ1VuZGlyZWN0ZWRFZGdlJyksICd1bmRpcmVjdGVkJyk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgRWRnZSBJdGVyYXRpb25cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQXR0YWNoaW5nIHNvbWUgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MgdG8gYmUgYWJsZSB0byBpdGVyYXRlIG92ZXIgYVxuICogZ3JhcGgncyBlZGdlcy5cbiAqL1xuXG4vKipcbiAqIERlZmluaXRpb25zLlxuICovXG5jb25zdCBFREdFU19JVEVSQVRJT04gPSBbXG4gIHtcbiAgICBuYW1lOiAnZWRnZXMnLFxuICAgIHR5cGU6ICdtaXhlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbkVkZ2VzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dEVkZ2VzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbmJvdW5kRWRnZXMnLFxuICAgIHR5cGU6ICdtaXhlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0Ym91bmRFZGdlcycsXG4gICAgdHlwZTogJ21peGVkJyxcbiAgICBkaXJlY3Rpb246ICdvdXQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnZGlyZWN0ZWRFZGdlcycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ3VuZGlyZWN0ZWRFZGdlcycsXG4gICAgdHlwZTogJ3VuZGlyZWN0ZWQnXG4gIH1cbl07XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgZWRnZXMgZnJvbSB0aGUgZ2l2ZW4gb2JqZWN0IHRvIG1hdGNoIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSAgIG9iamVjdCAgIC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaFNpbXBsZShicmVha2FibGUsIG9iamVjdCwgY2FsbGJhY2ssIGF2b2lkKSB7XG4gIGxldCBzaG91bGRCcmVhayA9IGZhbHNlO1xuXG4gIGZvciAoY29uc3QgayBpbiBvYmplY3QpIHtcbiAgICBpZiAoayA9PT0gYXZvaWQpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgZWRnZURhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhLmtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaE11bHRpKGJyZWFrYWJsZSwgb2JqZWN0LCBjYWxsYmFjaywgYXZvaWQpIHtcbiAgbGV0IGVkZ2VEYXRhLCBzb3VyY2UsIHRhcmdldDtcblxuICBsZXQgc2hvdWxkQnJlYWsgPSBmYWxzZTtcblxuICBmb3IgKGNvbnN0IGsgaW4gb2JqZWN0KSB7XG4gICAgaWYgKGsgPT09IGF2b2lkKSBjb250aW51ZTtcblxuICAgIGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gICAgZG8ge1xuICAgICAgc291cmNlID0gZWRnZURhdGEuc291cmNlO1xuICAgICAgdGFyZ2V0ID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICBzaG91bGRCcmVhayA9IGNhbGxiYWNrKFxuICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgIGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgIHNvdXJjZS5rZXksXG4gICAgICAgIHRhcmdldC5rZXksXG4gICAgICAgIHNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICB0YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhLmtleTtcblxuICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgIH0gd2hpbGUgKGVkZ2VEYXRhICE9PSB1bmRlZmluZWQpO1xuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGVkZ2VzIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgb2JqZWN0IC0gVGFyZ2V0IG9iamVjdC5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvcihvYmplY3QsIGF2b2lkKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpO1xuICBjb25zdCBsID0ga2V5cy5sZW5ndGg7XG5cbiAgbGV0IGVkZ2VEYXRhO1xuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKCFlZGdlRGF0YSkge1xuICAgICAgICAgIGlmIChpID49IGwpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG5cbiAgICAgICAgICBjb25zdCBrID0ga2V5c1tpKytdO1xuXG4gICAgICAgICAgaWYgKGsgPT09IGF2b2lkKSB7XG4gICAgICAgICAgICBlZGdlRGF0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoIWVkZ2VEYXRhKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgZWRnZTogZWRnZURhdGEua2V5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgc291cmNlOiBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICAgIHRhcmdldDogZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkOiBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBlZ2RlcyBmcm9tIHRoZSBvYmplY3QgYXQgZ2l2ZW4ga2V5IHRvIG1hdGNoXG4gKiBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gICBvYmplY3QgICAtIFRhcmdldCBvYmplY3QuXG4gKiBAcGFyYW0ge21peGVkfSAgICBrICAgICAgICAtIE5laWdoYm9yIGtleS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRm9yS2V5U2ltcGxlKGJyZWFrYWJsZSwgb2JqZWN0LCBrLCBjYWxsYmFjaykge1xuICBjb25zdCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICBpZiAoIWVkZ2VEYXRhKSByZXR1cm47XG5cbiAgY29uc3Qgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgY29uc3QgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICBpZiAoXG4gICAgY2FsbGJhY2soXG4gICAgICBlZGdlRGF0YS5rZXksXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICB0YXJnZXREYXRhLmtleSxcbiAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgIHRhcmdldERhdGEuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICApICYmXG4gICAgYnJlYWthYmxlXG4gIClcbiAgICByZXR1cm4gZWRnZURhdGEua2V5O1xufVxuXG5mdW5jdGlvbiBmb3JFYWNoRm9yS2V5TXVsdGkoYnJlYWthYmxlLCBvYmplY3QsIGssIGNhbGxiYWNrKSB7XG4gIGxldCBlZGdlRGF0YSA9IG9iamVjdFtrXTtcblxuICBpZiAoIWVkZ2VEYXRhKSByZXR1cm47XG5cbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG5cbiAgZG8ge1xuICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICBlZGdlRGF0YS5rZXksXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5rZXksXG4gICAgICBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgIGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGEua2V5O1xuXG4gICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICB9IHdoaWxlIChlZGdlRGF0YSAhPT0gdW5kZWZpbmVkKTtcblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGVnZGVzIGZyb20gdGhlIG9iamVjdCBhdCBnaXZlbiBrZXkuXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSAgIG9iamVjdCAgIC0gVGFyZ2V0IG9iamVjdC5cbiAqIEBwYXJhbSAge21peGVkfSAgICBrICAgICAgICAtIE5laWdoYm9yIGtleS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVJdGVyYXRvckZvcktleShvYmplY3QsIGspIHtcbiAgbGV0IGVkZ2VEYXRhID0gb2JqZWN0W2tdO1xuXG4gIGlmIChlZGdlRGF0YS5uZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGlmICghZWRnZURhdGEpIHJldHVybiB7ZG9uZTogdHJ1ZX07XG5cbiAgICAgICAgY29uc3QgdmFsdWUgPSB7XG4gICAgICAgICAgZWRnZTogZWRnZURhdGEua2V5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGVkZ2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgc291cmNlOiBlZGdlRGF0YS5zb3VyY2Uua2V5LFxuICAgICAgICAgIHRhcmdldDogZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgICBzb3VyY2VBdHRyaWJ1dGVzOiBlZGdlRGF0YS5zb3VyY2UuYXR0cmlidXRlcyxcbiAgICAgICAgICB0YXJnZXRBdHRyaWJ1dGVzOiBlZGdlRGF0YS50YXJnZXQuYXR0cmlidXRlcyxcbiAgICAgICAgICB1bmRpcmVjdGVkOiBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICAgIH07XG5cbiAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGlmIChkb25lID09PSB0cnVlKSByZXR1cm4ge2RvbmU6IHRydWV9O1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBlZGdlOiBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgYXR0cmlidXRlczogZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICBzb3VyY2U6IGVkZ2VEYXRhLnNvdXJjZS5rZXksXG4gICAgICAgICAgdGFyZ2V0OiBlZGdlRGF0YS50YXJnZXQua2V5LFxuICAgICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGVkZ2VEYXRhLnRhcmdldC5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHVuZGlyZWN0ZWQ6IGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgIGdyYXBoIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgLSBBcnJheSBvZiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycmF5KGdyYXBoLCB0eXBlKSB7XG4gIGlmIChncmFwaC5zaXplID09PSAwKSByZXR1cm4gW107XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcgfHwgdHlwZSA9PT0gZ3JhcGgudHlwZSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGdyYXBoLl9lZGdlcy5rZXlzKCkpO1xuICB9XG5cbiAgY29uc3Qgc2l6ZSA9XG4gICAgdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnID8gZ3JhcGgudW5kaXJlY3RlZFNpemUgOiBncmFwaC5kaXJlY3RlZFNpemU7XG5cbiAgY29uc3QgbGlzdCA9IG5ldyBBcnJheShzaXplKSxcbiAgICBtYXNrID0gdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIGxldCBpID0gMDtcbiAgbGV0IHN0ZXAsIGRhdGE7XG5cbiAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICBkYXRhID0gc3RlcC52YWx1ZTtcblxuICAgIGlmIChkYXRhLnVuZGlyZWN0ZWQgPT09IG1hc2spIGxpc3RbaSsrXSA9IGRhdGEua2V5O1xuICB9XG5cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYSBncmFwaCdzIGVkZ2VzIHVzaW5nIGEgY2FsbGJhY2sgdG8gbWF0Y2ggb25lIG9mXG4gKiB0aGVtLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoRWRnZShicmVha2FibGUsIGdyYXBoLCB0eXBlLCBjYWxsYmFjaykge1xuICBpZiAoZ3JhcGguc2l6ZSA9PT0gMCkgcmV0dXJuO1xuXG4gIGNvbnN0IHNob3VsZEZpbHRlciA9IHR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gZ3JhcGgudHlwZTtcbiAgY29uc3QgbWFzayA9IHR5cGUgPT09ICd1bmRpcmVjdGVkJztcblxuICBsZXQgc3RlcCwgZGF0YTtcbiAgbGV0IHNob3VsZEJyZWFrID0gZmFsc2U7XG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgZGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICBpZiAoc2hvdWxkRmlsdGVyICYmIGRhdGEudW5kaXJlY3RlZCAhPT0gbWFzaykgY29udGludWU7XG5cbiAgICBjb25zdCB7a2V5LCBhdHRyaWJ1dGVzLCBzb3VyY2UsIHRhcmdldH0gPSBkYXRhO1xuXG4gICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgIGtleSxcbiAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICBzb3VyY2Uua2V5LFxuICAgICAgdGFyZ2V0LmtleSxcbiAgICAgIHNvdXJjZS5hdHRyaWJ1dGVzLFxuICAgICAgdGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICBkYXRhLnVuZGlyZWN0ZWRcbiAgICApO1xuXG4gICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBpdGVyYXRvciBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHR5cGUuXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoIC0gVGFyZ2V0IEdyYXBoIGluc3RhbmNlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEByZXR1cm4ge0l0ZXJhdG9yfVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlSXRlcmF0b3IoZ3JhcGgsIHR5cGUpIHtcbiAgaWYgKGdyYXBoLnNpemUgPT09IDApIHJldHVybiBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgY29uc3Qgc2hvdWxkRmlsdGVyID0gdHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSBncmFwaC50eXBlO1xuICBjb25zdCBtYXNrID0gdHlwZSA9PT0gJ3VuZGlyZWN0ZWQnO1xuXG4gIGNvbnN0IGl0ZXJhdG9yID0gZ3JhcGguX2VkZ2VzLnZhbHVlcygpO1xuXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIG5leHQoKSB7XG4gICAgICBsZXQgc3RlcCwgZGF0YTtcblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RlcCA9IGl0ZXJhdG9yLm5leHQoKTtcblxuICAgICAgICBpZiAoc3RlcC5kb25lKSByZXR1cm4gc3RlcDtcblxuICAgICAgICBkYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgICBpZiAoc2hvdWxkRmlsdGVyICYmIGRhdGEudW5kaXJlY3RlZCAhPT0gbWFzaykgY29udGludWU7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHZhbHVlID0ge1xuICAgICAgICBlZGdlOiBkYXRhLmtleSxcbiAgICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBzb3VyY2U6IGRhdGEuc291cmNlLmtleSxcbiAgICAgICAgdGFyZ2V0OiBkYXRhLnRhcmdldC5rZXksXG4gICAgICAgIHNvdXJjZUF0dHJpYnV0ZXM6IGRhdGEuc291cmNlLmF0dHJpYnV0ZXMsXG4gICAgICAgIHRhcmdldEF0dHJpYnV0ZXM6IGRhdGEudGFyZ2V0LmF0dHJpYnV0ZXMsXG4gICAgICAgIHVuZGlyZWN0ZWQ6IGRhdGEudW5kaXJlY3RlZFxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIHt2YWx1ZSwgZG9uZTogZmFsc2V9O1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlcyB1c2luZyBhIGNhbGxiYWNrIHRvIG1hdGNoIG9uZSBvZiB0aGVtLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICBtdWx0aSAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aSBvciBub3QuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrICAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFZGdlRm9yTm9kZShcbiAgYnJlYWthYmxlLFxuICBtdWx0aSxcbiAgdHlwZSxcbiAgZGlyZWN0aW9uLFxuICBub2RlRGF0YSxcbiAgY2FsbGJhY2tcbikge1xuICBjb25zdCBmbiA9IG11bHRpID8gZm9yRWFjaE11bHRpIDogZm9yRWFjaFNpbXBsZTtcblxuICBsZXQgZm91bmQ7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChkaXJlY3Rpb24gIT09ICdvdXQnKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgbm9kZURhdGEuaW4sIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nKSB7XG4gICAgICBmb3VuZCA9IGZuKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG5vZGVEYXRhLm91dCxcbiAgICAgICAgY2FsbGJhY2ssXG4gICAgICAgICFkaXJlY3Rpb24gPyBub2RlRGF0YS5rZXkgOiB1bmRlZmluZWRcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBub2RlRGF0YS51bmRpcmVjdGVkLCBjYWxsYmFjayk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG4gIH1cblxuICByZXR1cm47XG59XG5cbi8qKlxuICogRnVuY3Rpb24gY3JlYXRpbmcgYW4gYXJyYXkgb2YgZWRnZXMgZm9yIHRoZSBnaXZlbiB0eXBlICYgdGhlIGdpdmVuIG5vZGUuXG4gKlxuICogQHBhcmFtICB7Ym9vbGVhbn0gbXVsdGkgICAgIC0gV2hldGhlciB0aGUgZ3JhcGggaXMgbXVsdGkgb3Igbm90LlxuICogQHBhcmFtICB7c3RyaW5nfSAgdHlwZSAgICAgIC0gVHlwZSBvZiBlZGdlcyB0byByZXRyaWV2ZS5cbiAqIEBwYXJhbSAge3N0cmluZ30gIGRpcmVjdGlvbiAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge2FueX0gICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEByZXR1cm4ge2FycmF5fSAgICAgICAgICAgICAtIEFycmF5IG9mIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQXJyYXlGb3JOb2RlKG11bHRpLCB0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIGNvbnN0IGVkZ2VzID0gW107IC8vIFRPRE86IHBvc3NpYmlsaXR5IHRvIGtub3cgc2l6ZSBiZWZvcmVoYW5kIG9yIGZhY3Rvcml6ZSB3aXRoIG1hcFxuXG4gIGZvckVhY2hFZGdlRm9yTm9kZShmYWxzZSwgbXVsdGksIHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEsIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBlZGdlcy5wdXNoKGtleSk7XG4gIH0pO1xuXG4gIHJldHVybiBlZGdlcztcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIG5vZGUncyBlZGdlcyB1c2luZyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICB0eXBlICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yTm9kZSh0eXBlLCBkaXJlY3Rpb24sIG5vZGVEYXRhKSB7XG4gIGxldCBpdGVyYXRvciA9IGVtcHR5SXRlcmF0b3IoKTtcblxuICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ291dCcgJiYgdHlwZW9mIG5vZGVEYXRhLmluICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oaXRlcmF0b3IsIGNyZWF0ZUl0ZXJhdG9yKG5vZGVEYXRhLmluKSk7XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJyAmJiB0eXBlb2Ygbm9kZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJylcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVJdGVyYXRvcihub2RlRGF0YS5vdXQsICFkaXJlY3Rpb24gPyBub2RlRGF0YS5rZXkgOiB1bmRlZmluZWQpXG4gICAgICApO1xuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcgJiYgdHlwZW9mIG5vZGVEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3Iobm9kZURhdGEudW5kaXJlY3RlZCkpO1xuICB9XG5cbiAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gcGF0aCB1c2luZyBhIGNhbGxiYWNrIHRvIG1hdGNoXG4gKiBvbmUgb2YgdGhlbS5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtib29sZWFufSAgbXVsdGkgICAgICAtIFdoZXRoZXIgdGhlIGdyYXBoIGlzIG11bHRpLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAgLSBJbiBvciBvdXQ/XG4gKiBAcGFyYW0gIHtOb2RlRGF0YX0gc291cmNlRGF0YSAtIFNvdXJjZSBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICB0YXJnZXQgICAgIC0gVGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgICAtIEZ1bmN0aW9uIHRvIGNhbGwuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgYnJlYWthYmxlLFxuICB0eXBlLFxuICBtdWx0aSxcbiAgZGlyZWN0aW9uLFxuICBzb3VyY2VEYXRhLFxuICB0YXJnZXQsXG4gIGNhbGxiYWNrXG4pIHtcbiAgY29uc3QgZm4gPSBtdWx0aSA/IGZvckVhY2hGb3JLZXlNdWx0aSA6IGZvckVhY2hGb3JLZXlTaW1wbGU7XG5cbiAgbGV0IGZvdW5kO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZURhdGEuaW4gIT09ICd1bmRlZmluZWQnICYmIGRpcmVjdGlvbiAhPT0gJ291dCcpIHtcbiAgICAgIGZvdW5kID0gZm4oYnJlYWthYmxlLCBzb3VyY2VEYXRhLmluLCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRpcmVjdGlvbiAhPT0gJ2luJyAmJlxuICAgICAgKGRpcmVjdGlvbiB8fCBzb3VyY2VEYXRhLmtleSAhPT0gdGFyZ2V0KVxuICAgICkge1xuICAgICAgZm91bmQgPSBmbihicmVha2FibGUsIHNvdXJjZURhdGEub3V0LCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBmb3VuZCA9IGZuKGJyZWFrYWJsZSwgc291cmNlRGF0YS51bmRpcmVjdGVkLCB0YXJnZXQsIGNhbGxiYWNrKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBmb3VuZCkgcmV0dXJuIGZvdW5kO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiBlZGdlcyBmb3IgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAgLSBUeXBlIG9mIGVkZ2VzIHRvIHJldHJpZXZlLlxuICogQHBhcmFtICB7Ym9vbGVhbn0gIG11bHRpICAgICAgLSBXaGV0aGVyIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAqIEBwYXJhbSAge3N0cmluZ30gICBkaXJlY3Rpb24gIC0gSW4gb3Igb3V0P1xuICogQHBhcmFtICB7Tm9kZURhdGF9IHNvdXJjZURhdGEgLSBTb3VyY2Ugbm9kZSdzIGRhdGEuXG4gKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgICAtIFRhcmdldCBub2RlLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgICAgICAgICAgLSBBcnJheSBvZiBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUFycmF5Rm9yUGF0aCh0eXBlLCBtdWx0aSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXQpIHtcbiAgY29uc3QgZWRnZXMgPSBbXTsgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8ga25vdyBzaXplIGJlZm9yZWhhbmQgb3IgZmFjdG9yaXplIHdpdGggbWFwXG5cbiAgZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICAgIGZhbHNlLFxuICAgIHR5cGUsXG4gICAgbXVsdGksXG4gICAgZGlyZWN0aW9uLFxuICAgIHNvdXJjZURhdGEsXG4gICAgdGFyZ2V0LFxuICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGVkZ2VzLnB1c2goa2V5KTtcbiAgICB9XG4gICk7XG5cbiAgcmV0dXJuIGVkZ2VzO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGVkZ2VzIGZvciB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgICAtIFR5cGUgb2YgZWRnZXMgdG8gcmV0cmlldmUuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uICAtIEluIG9yIG91dD9cbiAqIEBwYXJhbSAge05vZGVEYXRhfSBzb3VyY2VEYXRhIC0gU291cmNlIG5vZGUncyBkYXRhLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHRhcmdldCAgICAgLSBUYXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgIC0gRnVuY3Rpb24gdG8gY2FsbC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRWRnZUl0ZXJhdG9yRm9yUGF0aCh0eXBlLCBkaXJlY3Rpb24sIHNvdXJjZURhdGEsIHRhcmdldCkge1xuICBsZXQgaXRlcmF0b3IgPSBlbXB0eUl0ZXJhdG9yKCk7XG5cbiAgaWYgKHR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLmluICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgZGlyZWN0aW9uICE9PSAnb3V0JyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEuaW5cbiAgICApXG4gICAgICBpdGVyYXRvciA9IGNoYWluKGl0ZXJhdG9yLCBjcmVhdGVJdGVyYXRvckZvcktleShzb3VyY2VEYXRhLmluLCB0YXJnZXQpKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBzb3VyY2VEYXRhLm91dCAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIGRpcmVjdGlvbiAhPT0gJ2luJyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEub3V0ICYmXG4gICAgICAoZGlyZWN0aW9uIHx8IHNvdXJjZURhdGEua2V5ICE9PSB0YXJnZXQpXG4gICAgKVxuICAgICAgaXRlcmF0b3IgPSBjaGFpbihpdGVyYXRvciwgY3JlYXRlSXRlcmF0b3JGb3JLZXkoc291cmNlRGF0YS5vdXQsIHRhcmdldCkpO1xuICB9XG5cbiAgaWYgKHR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICBpZiAoXG4gICAgICB0eXBlb2Ygc291cmNlRGF0YS51bmRpcmVjdGVkICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgdGFyZ2V0IGluIHNvdXJjZURhdGEudW5kaXJlY3RlZFxuICAgIClcbiAgICAgIGl0ZXJhdG9yID0gY2hhaW4oXG4gICAgICAgIGl0ZXJhdG9yLFxuICAgICAgICBjcmVhdGVJdGVyYXRvckZvcktleShzb3VyY2VEYXRhLnVuZGlyZWN0ZWQsIHRhcmdldClcbiAgICAgICk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGFuIGVkZ2UgYXJyYXkgY3JlYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlQXJyYXlDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZSwgdHlwZSwgZGlyZWN0aW9ufSA9IGRlc2NyaXB0aW9uO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY2VydGFpbiBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMDogUmV0dXJuIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqXG4gICAqIEFyaXR5IDE6IFJldHVybiBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlICAgLSBUYXJnZXQgbm9kZS5cbiAgICpcbiAgICogQXJpdHkgMjogUmV0dXJuIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICBzb3VyY2UgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheXxudW1iZXJ9IC0gVGhlIGVkZ2VzIG9yIHRoZSBudW1iZXIgb2YgZWRnZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNyZWF0ZUVkZ2VBcnJheSh0aGlzLCB0eXBlKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlQXJyYXlGb3JOb2RlKFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICB0eXBlID09PSAnbWl4ZWQnID8gdGhpcy50eXBlIDogdHlwZSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBub2RlRGF0YVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gY3JlYXRlRWRnZUFycmF5Rm9yUGF0aChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICBzb3VyY2VEYXRhLFxuICAgICAgICB0YXJnZXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDAsIDEgb3IgMiBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIGF0dGFjaGluZyBhIGVkZ2UgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRm9yRWFjaEVkZ2UoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgZm9yRWFjaE5hbWUgPSAnZm9yRWFjaCcgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEsIC0xKTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgYnkgYXBwbHlpbmcgdGhlIGdpdmVuXG4gICAqIGNhbGxiYWNrLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW2ZvckVhY2hOYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpIHJldHVybjtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjYWxsYmFjayA9IHNvdXJjZTtcbiAgICAgIHJldHVybiBmb3JFYWNoRWRnZShmYWxzZSwgdGhpcywgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xuXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIC8vIFRPRE86IG1heWJlIGF0dGFjaCB0aGUgc3ViIG1ldGhvZCB0byB0aGUgaW5zdGFuY2UgZHluYW1pY2FsbHk/XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JOb2RlKFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06ICBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuXG4gICAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke2ZvckVhY2hOYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yUGF0aChcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIHR5cGUsXG4gICAgICAgIHRoaXMubXVsdGksXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgc291cmNlRGF0YSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICBjYWxsYmFja1xuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtmb3JFYWNoTmFtZX06IHRvbyBtYW55IGFyZ3VtZW50cyAoZXhwZWN0aW5nIDEsIDIgb3IgMyBhbmQgZ290ICR7YXJndW1lbnRzLmxlbmd0aH0pLmBcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBtYXBwaW5nIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGJ5IGFwcGx5aW5nIHRoZSBnaXZlblxuICAgKiBjYWxsYmFjay5cbiAgICpcbiAgICogQXJpdHkgMTogTWFwIGFsbCB0aGUgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogTWFwIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogTWFwIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgdGFyZ2V0ICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IG1hcE5hbWUgPSAnbWFwJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW21hcE5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGxldCByZXN1bHQ7XG5cbiAgICAvLyBXZSBrbm93IHRoZSByZXN1bHQgbGVuZ3RoIGJlZm9yZWhhbmRcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIGxldCBsZW5ndGggPSAwO1xuXG4gICAgICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykgbGVuZ3RoICs9IHRoaXMudW5kaXJlY3RlZFNpemU7XG4gICAgICBpZiAodHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSBsZW5ndGggKz0gdGhpcy5kaXJlY3RlZFNpemU7XG5cbiAgICAgIHJlc3VsdCA9IG5ldyBBcnJheShsZW5ndGgpO1xuXG4gICAgICBsZXQgaSA9IDA7XG5cbiAgICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgICByZXN1bHRbaSsrXSA9IGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gV2UgZG9uJ3Qga25vdyB0aGUgcmVzdWx0IGxlbmd0aCBiZWZvcmVoYW5kXG4gICAgLy8gVE9ETzogd2UgY2FuIGluIHNvbWUgaW5zdGFuY2VzIG9mIHNpbXBsZSBncmFwaHMsIGtub3dpbmcgZGVncmVlXG4gICAgZWxzZSB7XG4gICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gZmlsdGVyaW5nIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGVcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEZpbHRlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMjogRmlsdGVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQXJpdHkgMzogRmlsdGVyIHRoZSByZWxldmFudCBlZGdlcyBhY3Jvc3MgdGhlIGdpdmVuIHBhdGguXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBzb3VyY2UgICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gcHJlZGljYXRlIC0gUHJlZGljYXRlIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBmaWx0ZXJOYW1lID0gJ2ZpbHRlcicgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtmaWx0ZXJOYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IGFyZ3MucG9wKCk7XG5cbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgaWYgKGNhbGxiYWNrKGUsIGVhLCBzLCB0LCBzYSwgdGEsIHUpKSByZXN1bHQucHVzaChlKTtcbiAgICB9KTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gcmVkdWNpbmcgdGhlIGdyYXBoJ3MgcmVsZXZhbnQgZWRnZXMgdXNpbmcgdGhlIHByb3ZpZGVkIGFjY3VtdWxhdG9yXG4gICAqIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBSZWR1Y2UgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEFyaXR5IDI6IFJlZHVjZSBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEFyaXR5IDM6IFJlZHVjZSB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgICAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGFjY3VtdWxhdG9yICAtIEFjY3VtdWxhdG9yIHRvIHVzZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIGluaXRpYWxWYWx1ZSAtIEluaXRpYWwgdmFsdWUuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgcmVkdWNlTmFtZSA9ICdyZWR1Y2UnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxKTtcblxuICBDbGFzcy5wcm90b3R5cGVbcmVkdWNlTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoIDwgMiB8fCBhcmdzLmxlbmd0aCA+IDQpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7cmVkdWNlTmFtZX06IGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoZXhwZWN0aW5nIDIsIDMgb3IgNCBhbmQgZ290ICR7YXJncy5sZW5ndGh9KS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMl0gIT09ICdmdW5jdGlvbidcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7cmVkdWNlTmFtZX06IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS5gXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBjYWxsYmFjaztcbiAgICBsZXQgaW5pdGlhbFZhbHVlO1xuXG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBjYWxsYmFjayA9IGFyZ3NbMF07XG4gICAgICBpbml0aWFsVmFsdWUgPSBhcmdzWzFdO1xuICAgICAgYXJncyA9IFtdO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDMpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZ3NbMl07XG4gICAgICBhcmdzID0gW2FyZ3NbMF1dO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNhbGxiYWNrID0gYXJnc1syXTtcbiAgICAgIGluaXRpYWxWYWx1ZSA9IGFyZ3NbM107XG4gICAgICBhcmdzID0gW2FyZ3NbMF0sIGFyZ3NbMV1dO1xuICAgIH1cblxuICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgYWNjdW11bGF0b3IgPSBjYWxsYmFjayhhY2N1bXVsYXRvciwgZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgfSk7XG5cbiAgICB0aGlzW2ZvckVhY2hOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBicmVha2FibGUgZWRnZSBjYWxsYmFjayBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoXG4gKiBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoRmluZEVkZ2UoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgZmluZEVkZ2VOYW1lID0gJ2ZpbmQnICsgbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSgxLCAtMSk7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIG1hdGNoXG4gICAqIG9uZSBvZiB0aGVtIHVzaW5nIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZmluZEVkZ2VOYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY2FsbGJhY2sgPSBzb3VyY2U7XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2UodHJ1ZSwgdGhpcywgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIGNhbGxiYWNrID0gdGFyZ2V0O1xuXG4gICAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIGEgbm9kZSdzIGVkZ2VzXG4gICAgICAvLyBUT0RPOiBtYXliZSBhdHRhY2ggdGhlIHN1YiBtZXRob2QgdG8gdGhlIGluc3RhbmNlIGR5bmFtaWNhbGx5P1xuICAgICAgcmV0dXJuIGZvckVhY2hFZGdlRm9yTm9kZShcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgdGhpcy5tdWx0aSxcbiAgICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAzKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghc291cmNlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtmaW5kRWRnZU5hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgdGhlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0XG4gICAgICByZXR1cm4gZm9yRWFjaEVkZ2VGb3JQYXRoKFxuICAgICAgICB0cnVlLFxuICAgICAgICB0eXBlLFxuICAgICAgICB0aGlzLm11bHRpLFxuICAgICAgICBkaXJlY3Rpb24sXG4gICAgICAgIHNvdXJjZURhdGEsXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7ZmluZEVkZ2VOYW1lfTogdG9vIG1hbnkgYXJndW1lbnRzIChleHBlY3RpbmcgMSwgMiBvciAzIGFuZCBnb3QgJHthcmd1bWVudHMubGVuZ3RofSkuYFxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIGFzc2VydFxuICAgKiB3aGV0aGVyIGFueSBvbmUgb2YgdGhlbSBtYXRjaGVzIHRoZSBwcm92aWRlZCBwcmVkaWNhdGUgZnVuY3Rpb24uXG4gICAqXG4gICAqIEFyaXR5IDE6IEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDI6IEl0ZXJhdGUgb3ZlciBhbGwgb2YgYSBub2RlJ3MgcmVsZXZhbnQgZWRnZXMuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEFyaXR5IDM6IEl0ZXJhdGUgb3ZlciB0aGUgcmVsZXZhbnQgZWRnZXMgYWNyb3NzIHRoZSBnaXZlbiBwYXRoLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgc291cmNlICAgLSBTb3VyY2Ugbm9kZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHRhcmdldCAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICpcbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBzb21lTmFtZSA9ICdzb21lJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtzb21lTmFtZV0gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgYXJncy5wdXNoKChlLCBlYSwgcywgdCwgc2EsIHRhLCB1KSA9PiB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZEVkZ2VOYW1lXS5hcHBseSh0aGlzLCBhcmdzKTtcblxuICAgIGlmIChmb3VuZCkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIHJlbGV2YW50IGVkZ2VzIGluIG9yZGVyIHRvIGFzc2VydFxuICAgKiB3aGV0aGVyIGFsbCBvZiB0aGVtIG1hdGNoZSB0aGUgcHJvdmlkZWQgcHJlZGljYXRlIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBBcml0eSAxOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgYWxsIG9mIGEgbm9kZSdzIHJlbGV2YW50IGVkZ2VzLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBBcml0eSAzOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgICAgIHNvdXJjZSAgIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgICB0YXJnZXQgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZXZlcnlOYW1lID0gJ2V2ZXJ5JyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtldmVyeU5hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gYXJncy5wb3AoKTtcblxuICAgIGFyZ3MucHVzaCgoZSwgZWEsIHMsIHQsIHNhLCB0YSwgdSkgPT4ge1xuICAgICAgcmV0dXJuICFjYWxsYmFjayhlLCBlYSwgcywgdCwgc2EsIHRhLCB1KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kRWRnZU5hbWVdLmFwcGx5KHRoaXMsIGFyZ3MpO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYW4gZWRnZSBpdGVyYXRvciBtZXRob2QgdG8gdGhlIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlSXRlcmF0b3JDcmVhdG9yKENsYXNzLCBkZXNjcmlwdGlvbikge1xuICBjb25zdCB7bmFtZTogb3JpZ2luYWxOYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgbmFtZSA9IG9yaWdpbmFsTmFtZS5zbGljZSgwLCAtMSkgKyAnRW50cmllcyc7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIHRoZSBncmFwaCdzIGVkZ2VzLlxuICAgKlxuICAgKiBBcml0eSAwOiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWxldmFudCBlZGdlcy5cbiAgICpcbiAgICogQXJpdHkgMTogSXRlcmF0ZSBvdmVyIGFsbCBvZiBhIG5vZGUncyByZWxldmFudCBlZGdlcy5cbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgICAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBBcml0eSAyOiBJdGVyYXRlIG92ZXIgdGhlIHJlbGV2YW50IGVkZ2VzIGFjcm9zcyB0aGUgZ2l2ZW4gcGF0aC5cbiAgICogQHBhcmFtICB7YW55fSAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge2FycmF5fG51bWJlcn0gLSBUaGUgZWRnZXMgb3IgdGhlIG51bWJlciBvZiBlZGdlcy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgQ2xhc3MucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKVxuICAgICAgcmV0dXJuIGVtcHR5SXRlcmF0b3IoKTtcblxuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIGNyZWF0ZUVkZ2VJdGVyYXRvcih0aGlzLCB0eXBlKTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcblxuICAgICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgLy8gSXRlcmF0aW5nIG92ZXIgYSBub2RlJ3MgZWRnZXNcbiAgICAgIHJldHVybiBjcmVhdGVFZGdlSXRlcmF0b3JGb3JOb2RlKHR5cGUsIGRpcmVjdGlvbiwgc291cmNlRGF0YSk7XG4gICAgfVxuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IHNvdXJjZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICAgIGBHcmFwaC4ke25hbWV9OiAgY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICAgKTtcblxuICAgICAgaWYgKCF0aGlzLl9ub2Rlcy5oYXModGFyZ2V0KSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogIGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG5cbiAgICAgIC8vIEl0ZXJhdGluZyBvdmVyIHRoZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldFxuICAgICAgcmV0dXJuIGNyZWF0ZUVkZ2VJdGVyYXRvckZvclBhdGgodHlwZSwgZGlyZWN0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXQpO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB0b28gbWFueSBhcmd1bWVudHMgKGV4cGVjdGluZyAwLCAxIG9yIDIgYW5kIGdvdCAke2FyZ3VtZW50cy5sZW5ndGh9KS5gXG4gICAgKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgZXZlcnkgZWRnZSBpdGVyYXRpb24gbWV0aG9kIHRvIHRoZSBHcmFwaCBjbGFzcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBHcmFwaCAtIEdyYXBoIGNsYXNzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hFZGdlSXRlcmF0aW9uTWV0aG9kcyhHcmFwaCkge1xuICBFREdFU19JVEVSQVRJT04uZm9yRWFjaChkZXNjcmlwdGlvbiA9PiB7XG4gICAgYXR0YWNoRWRnZUFycmF5Q3JlYXRvcihHcmFwaCwgZGVzY3JpcHRpb24pO1xuICAgIGF0dGFjaEZvckVhY2hFZGdlKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRmluZEVkZ2UoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgICBhdHRhY2hFZGdlSXRlcmF0b3JDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgTmVpZ2hib3IgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBBdHRhY2hpbmcgc29tZSBtZXRob2RzIHRvIHRoZSBHcmFwaCBjbGFzcyB0byBiZSBhYmxlIHRvIGl0ZXJhdGUgb3ZlclxuICogbmVpZ2hib3JzLlxuICovXG5cbi8qKlxuICogRGVmaW5pdGlvbnMuXG4gKi9cbmNvbnN0IE5FSUdIQk9SU19JVEVSQVRJT04gPSBbXG4gIHtcbiAgICBuYW1lOiAnbmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnaW5OZWlnaGJvcnMnLFxuICAgIHR5cGU6ICdkaXJlY3RlZCcsXG4gICAgZGlyZWN0aW9uOiAnaW4nXG4gIH0sXG4gIHtcbiAgICBuYW1lOiAnb3V0TmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdpbmJvdW5kTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ2luJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ291dGJvdW5kTmVpZ2hib3JzJyxcbiAgICB0eXBlOiAnbWl4ZWQnLFxuICAgIGRpcmVjdGlvbjogJ291dCdcbiAgfSxcbiAge1xuICAgIG5hbWU6ICdkaXJlY3RlZE5laWdoYm9ycycsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogJ3VuZGlyZWN0ZWROZWlnaGJvcnMnLFxuICAgIHR5cGU6ICd1bmRpcmVjdGVkJ1xuICB9XG5dO1xuXG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cbmZ1bmN0aW9uIENvbXBvc2l0ZVNldFdyYXBwZXIoKSB7XG4gIHRoaXMuQSA9IG51bGw7XG4gIHRoaXMuQiA9IG51bGw7XG59XG5cbkNvbXBvc2l0ZVNldFdyYXBwZXIucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc2V0KSB7XG4gIGlmICh0aGlzLkEgPT09IG51bGwpIHRoaXMuQSA9IHNldDtcbiAgZWxzZSBpZiAodGhpcy5CID09PSBudWxsKSB0aGlzLkIgPSBzZXQ7XG59O1xuXG5Db21wb3NpdGVTZXRXcmFwcGVyLnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIGlmICh0aGlzLkEgIT09IG51bGwgJiYga2V5IGluIHRoaXMuQSkgcmV0dXJuIHRydWU7XG4gIGlmICh0aGlzLkIgIT09IG51bGwgJiYga2V5IGluIHRoaXMuQikgcmV0dXJuIHRydWU7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgdGhlIGdpdmVuIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnMgdG8gbWF0Y2hcbiAqIG9uZSBvZiB0aGVtIHVzaW5nIGEgcHJlZGljYXRlZCBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgdHlwZSAgICAgIC0gVHlwZSBvZiBuZWlnaGJvcnMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgZGlyZWN0aW9uIC0gRGlyZWN0aW9uLlxuICogQHBhcmFtICB7YW55fSAgICAgIG5vZGVEYXRhICAtIFRhcmdldCBub2RlJ3MgZGF0YS5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAgLSBDYWxsYmFjayB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hJbk9iamVjdE9uY2UoYnJlYWthYmxlLCB2aXNpdGVkLCBub2RlRGF0YSwgb2JqZWN0LCBjYWxsYmFjaykge1xuICBmb3IgKGNvbnN0IGsgaW4gb2JqZWN0KSB7XG4gICAgY29uc3QgZWRnZURhdGEgPSBvYmplY3Rba107XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gZWRnZURhdGEuc291cmNlO1xuICAgIGNvbnN0IHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICBjb25zdCBuZWlnaGJvckRhdGEgPSBzb3VyY2VEYXRhID09PSBub2RlRGF0YSA/IHRhcmdldERhdGEgOiBzb3VyY2VEYXRhO1xuXG4gICAgaWYgKHZpc2l0ZWQgJiYgdmlzaXRlZC5oYXMobmVpZ2hib3JEYXRhLmtleSkpIGNvbnRpbnVlO1xuXG4gICAgY29uc3Qgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhuZWlnaGJvckRhdGEua2V5LCBuZWlnaGJvckRhdGEuYXR0cmlidXRlcyk7XG5cbiAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gbmVpZ2hib3JEYXRhLmtleTtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaE5laWdoYm9yKGJyZWFrYWJsZSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSwgY2FsbGJhY2spIHtcbiAgLy8gSWYgd2Ugd2FudCBvbmx5IHVuZGlyZWN0ZWQgb3IgaW4gb3Igb3V0LCB3ZSBjYW4gcm9sbCBzb21lIG9wdGltaXphdGlvbnNcbiAgaWYgKHR5cGUgIT09ICdtaXhlZCcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgcmV0dXJuIGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhLnVuZGlyZWN0ZWQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuXG4gICAgaWYgKHR5cGVvZiBkaXJlY3Rpb24gPT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIGZvckVhY2hJbk9iamVjdE9uY2UoXG4gICAgICAgIGJyZWFrYWJsZSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbm9kZURhdGEsXG4gICAgICAgIG5vZGVEYXRhW2RpcmVjdGlvbl0sXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICB9XG5cbiAgLy8gRWxzZSB3ZSBuZWVkIHRvIGtlZXAgYSBzZXQgb2YgbmVpZ2hib3JzIG5vdCB0byByZXR1cm4gZHVwbGljYXRlc1xuICAvLyBXZSBjaGVhdCBieSBxdWVyeWluZyB0aGUgb3RoZXIgYWRqYWNlbmNpZXNcbiAgY29uc3QgdmlzaXRlZCA9IG5ldyBDb21wb3NpdGVTZXRXcmFwcGVyKCk7XG5cbiAgbGV0IGZvdW5kO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YS5pbixcbiAgICAgICAgY2FsbGJhY2tcbiAgICAgICk7XG5cbiAgICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcblxuICAgICAgdmlzaXRlZC53cmFwKG5vZGVEYXRhLmluKTtcbiAgICB9XG4gICAgaWYgKGRpcmVjdGlvbiAhPT0gJ2luJykge1xuICAgICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgICBicmVha2FibGUsXG4gICAgICAgIHZpc2l0ZWQsXG4gICAgICAgIG5vZGVEYXRhLFxuICAgICAgICBub2RlRGF0YS5vdXQsXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuXG4gICAgICBpZiAoYnJlYWthYmxlICYmIGZvdW5kKSByZXR1cm4gZm91bmQ7XG5cbiAgICAgIHZpc2l0ZWQud3JhcChub2RlRGF0YS5vdXQpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgZm91bmQgPSBmb3JFYWNoSW5PYmplY3RPbmNlKFxuICAgICAgYnJlYWthYmxlLFxuICAgICAgdmlzaXRlZCxcbiAgICAgIG5vZGVEYXRhLFxuICAgICAgbm9kZURhdGEudW5kaXJlY3RlZCxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcblxuICAgIGlmIChicmVha2FibGUgJiYgZm91bmQpIHJldHVybiBmb3VuZDtcbiAgfVxuXG4gIHJldHVybjtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBjcmVhdGluZyBhbiBhcnJheSBvZiByZWxldmFudCBuZWlnaGJvcnMgZm9yIHRoZSBnaXZlbiBub2RlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gICAgICAgdHlwZSAgICAgIC0gVHlwZSBvZiBuZWlnaGJvcnMuXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICAgICAgIGRpcmVjdGlvbiAtIERpcmVjdGlvbi5cbiAqIEBwYXJhbSAge2FueX0gICAgICAgICAgbm9kZURhdGEgIC0gVGFyZ2V0IG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7QXJyYXl9ICAgICAgICAgICAgICAgICAgLSBUaGUgbGlzdCBvZiBuZWlnaGJvcnMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5laWdoYm9yQXJyYXlGb3JOb2RlKHR5cGUsIGRpcmVjdGlvbiwgbm9kZURhdGEpIHtcbiAgLy8gSWYgd2Ugd2FudCBvbmx5IHVuZGlyZWN0ZWQgb3IgaW4gb3Igb3V0LCB3ZSBjYW4gcm9sbCBzb21lIG9wdGltaXphdGlvbnNcbiAgaWYgKHR5cGUgIT09ICdtaXhlZCcpIHtcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gT2JqZWN0LmtleXMobm9kZURhdGEudW5kaXJlY3RlZCk7XG5cbiAgICBpZiAodHlwZW9mIGRpcmVjdGlvbiA9PT0gJ3N0cmluZycpIHJldHVybiBPYmplY3Qua2V5cyhub2RlRGF0YVtkaXJlY3Rpb25dKTtcbiAgfVxuXG4gIGNvbnN0IG5laWdoYm9ycyA9IFtdO1xuXG4gIGZvckVhY2hOZWlnaGJvcihmYWxzZSwgdHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSwgZnVuY3Rpb24gKGtleSkge1xuICAgIG5laWdoYm9ycy5wdXNoKGtleSk7XG4gIH0pO1xuXG4gIHJldHVybiBuZWlnaGJvcnM7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdpdmVuIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnMuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSAgIHR5cGUgICAgICAtIFR5cGUgb2YgbmVpZ2hib3JzLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGRpcmVjdGlvbiAtIERpcmVjdGlvbi5cbiAqIEBwYXJhbSAge2FueX0gICAgICBub2RlRGF0YSAgLSBUYXJnZXQgbm9kZSdzIGRhdGEuXG4gKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBvYmplY3QpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGNvbnN0IGwgPSBrZXlzLmxlbmd0aDtcblxuICBsZXQgaSA9IDA7XG5cbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbmV4dCgpIHtcbiAgICAgIGxldCBuZWlnaGJvckRhdGEgPSBudWxsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChpID49IGwpIHtcbiAgICAgICAgICBpZiAodmlzaXRlZCkgdmlzaXRlZC53cmFwKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHtkb25lOiB0cnVlfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVkZ2VEYXRhID0gb2JqZWN0W2tleXNbaSsrXV07XG5cbiAgICAgICAgY29uc3Qgc291cmNlRGF0YSA9IGVkZ2VEYXRhLnNvdXJjZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGF0YSA9IGVkZ2VEYXRhLnRhcmdldDtcblxuICAgICAgICBuZWlnaGJvckRhdGEgPSBzb3VyY2VEYXRhID09PSBub2RlRGF0YSA/IHRhcmdldERhdGEgOiBzb3VyY2VEYXRhO1xuXG4gICAgICAgIGlmICh2aXNpdGVkICYmIHZpc2l0ZWQuaGFzKG5laWdoYm9yRGF0YS5rZXkpKSB7XG4gICAgICAgICAgbmVpZ2hib3JEYXRhID0gbnVsbDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobmVpZ2hib3JEYXRhID09PSBudWxsKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiB7bmVpZ2hib3I6IG5laWdoYm9yRGF0YS5rZXksIGF0dHJpYnV0ZXM6IG5laWdoYm9yRGF0YS5hdHRyaWJ1dGVzfVxuICAgICAgfTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5laWdoYm9ySXRlcmF0b3IodHlwZSwgZGlyZWN0aW9uLCBub2RlRGF0YSkge1xuICAvLyBJZiB3ZSB3YW50IG9ubHkgdW5kaXJlY3RlZCBvciBpbiBvciBvdXQsIHdlIGNhbiByb2xsIHNvbWUgb3B0aW1pemF0aW9uc1xuICBpZiAodHlwZSAhPT0gJ21peGVkJykge1xuICAgIGlmICh0eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgICByZXR1cm4gY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKG51bGwsIG5vZGVEYXRhLCBub2RlRGF0YS51bmRpcmVjdGVkKTtcblxuICAgIGlmICh0eXBlb2YgZGlyZWN0aW9uID09PSAnc3RyaW5nJylcbiAgICAgIHJldHVybiBjcmVhdGVEZWR1cGVkT2JqZWN0SXRlcmF0b3IobnVsbCwgbm9kZURhdGEsIG5vZGVEYXRhW2RpcmVjdGlvbl0pO1xuICB9XG5cbiAgbGV0IGl0ZXJhdG9yID0gZW1wdHlJdGVyYXRvcigpO1xuXG4gIC8vIEVsc2Ugd2UgbmVlZCB0byBrZWVwIGEgc2V0IG9mIG5laWdoYm9ycyBub3QgdG8gcmV0dXJuIGR1cGxpY2F0ZXNcbiAgLy8gV2UgY2hlYXQgYnkgcXVlcnlpbmcgdGhlIG90aGVyIGFkamFjZW5jaWVzXG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgQ29tcG9zaXRlU2V0V3JhcHBlcigpO1xuXG4gIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnb3V0Jykge1xuICAgICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgICAgaXRlcmF0b3IsXG4gICAgICAgIGNyZWF0ZURlZHVwZWRPYmplY3RJdGVyYXRvcih2aXNpdGVkLCBub2RlRGF0YSwgbm9kZURhdGEuaW4pXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoZGlyZWN0aW9uICE9PSAnaW4nKSB7XG4gICAgICBpdGVyYXRvciA9IGNoYWluKFxuICAgICAgICBpdGVyYXRvcixcbiAgICAgICAgY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBub2RlRGF0YS5vdXQpXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgaXRlcmF0b3IgPSBjaGFpbihcbiAgICAgIGl0ZXJhdG9yLFxuICAgICAgY3JlYXRlRGVkdXBlZE9iamVjdEl0ZXJhdG9yKHZpc2l0ZWQsIG5vZGVEYXRhLCBub2RlRGF0YS51bmRpcmVjdGVkKVxuICAgICk7XG4gIH1cblxuICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgbmVpZ2hib3JzIGFycmF5IGNyZWF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTmVpZ2hib3JBcnJheUNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBhcnJheSBvZiBjZXJ0YWluIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgIG5vZGUgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgbmVpZ2hib3JzIG9mIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBub2RlIGlzIG5vdCBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbiAobm9kZSkge1xuICAgIC8vIEVhcmx5IHRlcm1pbmF0aW9uXG4gICAgaWYgKHR5cGUgIT09ICdtaXhlZCcgJiYgdGhpcy50eXBlICE9PSAnbWl4ZWQnICYmIHR5cGUgIT09IHRoaXMudHlwZSlcbiAgICAgIHJldHVybiBbXTtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bmFtZX06IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgLy8gSGVyZSwgd2Ugd2FudCB0byBpdGVyYXRlIG92ZXIgYSBub2RlJ3MgcmVsZXZhbnQgbmVpZ2hib3JzXG4gICAgcmV0dXJuIGNyZWF0ZU5laWdoYm9yQXJyYXlGb3JOb2RlKFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGEgbmVpZ2hib3JzIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGUgR3JhcGggcHJvdG90eXBlLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzICAgICAgIC0gVGFyZ2V0IGNsYXNzLlxuICogQHBhcmFtIHtvYmplY3R9ICAgZGVzY3JpcHRpb24gLSBNZXRob2QgZGVzY3JpcHRpb24uXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaEZvckVhY2hOZWlnaGJvcihDbGFzcywgZGVzY3JpcHRpb24pIHtcbiAgY29uc3Qge25hbWUsIHR5cGUsIGRpcmVjdGlvbn0gPSBkZXNjcmlwdGlvbjtcblxuICBjb25zdCBmb3JFYWNoTmFtZSA9ICdmb3JFYWNoJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhbGwgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtmb3JFYWNoTmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpIHJldHVybjtcblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICh0eXBlb2Ygbm9kZURhdGEgPT09ICd1bmRlZmluZWQnKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7Zm9yRWFjaE5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIGZvckVhY2hOZWlnaGJvcihcbiAgICAgIGZhbHNlLFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YSxcbiAgICAgIGNhbGxiYWNrXG4gICAgKTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gbWFwcGluZyB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IG1hcE5hbWUgPSAnbWFwJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW21hcE5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogb3B0aW1pemUgd2hlbiBzaXplIGlzIGtub3duIGJlZm9yZWhhbmRcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICByZXN1bHQucHVzaChjYWxsYmFjayhuLCBhKSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiBmaWx0ZXJpbmcgdGhlIHJlbGV2YW50IG5laWdoYm9ycyB1c2luZyBhIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBmaWx0ZXJOYW1lID0gJ2ZpbHRlcicgKyBuYW1lWzBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpO1xuXG4gIENsYXNzLnByb3RvdHlwZVtmaWx0ZXJOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgdGhpc1tmb3JFYWNoTmFtZV0obm9kZSwgKG4sIGEpID0+IHtcbiAgICAgIGlmIChjYWxsYmFjayhuLCBhKSkgcmVzdWx0LnB1c2gobik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBGdW5jdGlvbiByZWR1Y2luZyB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHVzaW5nIGEgY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAtIFRhcmdldCBub2RlLlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byB1c2UuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIGNvbnN0IHJlZHVjZU5hbWUgPSAncmVkdWNlJyArIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3JlZHVjZU5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDMpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke3JlZHVjZU5hbWV9OiBtaXNzaW5nIGluaXRpYWwgdmFsdWUuIFlvdSBtdXN0IHByb3ZpZGUgaXQgYmVjYXVzZSB0aGUgY2FsbGJhY2sgdGFrZXMgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCBhbmQgd2UgY2Fubm90IGluZmVyIHRoZSBpbml0aWFsIHZhbHVlIGZyb20gdGhlIGZpcnN0IGl0ZXJhdGlvbiwgYXMgeW91IGNvdWxkIHdpdGggYSBzaW1wbGUgYXJyYXkuYFxuICAgICAgKTtcblxuICAgIGxldCBhY2N1bXVsYXRvciA9IGluaXRpYWxWYWx1ZTtcblxuICAgIHRoaXNbZm9yRWFjaE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBuLCBhKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBicmVha2FibGUgbmVpZ2hib3JzIGNhbGxiYWNrIGl0ZXJhdG9yIG1ldGhvZCB0byB0aGVcbiAqIEdyYXBoIHByb3RvdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzcyAgICAgICAtIFRhcmdldCBjbGFzcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSAgIGRlc2NyaXB0aW9uIC0gTWV0aG9kIGRlc2NyaXB0aW9uLlxuICovXG5mdW5jdGlvbiBhdHRhY2hGaW5kTmVpZ2hib3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgY2FwaXRhbGl6ZWRTaW5ndWxhciA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSwgLTEpO1xuXG4gIGNvbnN0IGZpbmROYW1lID0gJ2ZpbmQnICsgY2FwaXRhbGl6ZWRTaW5ndWxhcjtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdXNpbmcgYSBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBDbGFzcy5wcm90b3R5cGVbZmluZE5hbWVdID0gZnVuY3Rpb24gKG5vZGUsIGNhbGxiYWNrKSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodHlwZSAhPT0gJ21peGVkJyAmJiB0aGlzLnR5cGUgIT09ICdtaXhlZCcgJiYgdHlwZSAhPT0gdGhpcy50eXBlKSByZXR1cm47XG5cbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAodHlwZW9mIG5vZGVEYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke2ZpbmROYW1lfTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICAvLyBIZXJlLCB3ZSB3YW50IHRvIGl0ZXJhdGUgb3ZlciBhIG5vZGUncyByZWxldmFudCBuZWlnaGJvcnNcbiAgICByZXR1cm4gZm9yRWFjaE5laWdoYm9yKFxuICAgICAgdHJ1ZSxcbiAgICAgIHR5cGUgPT09ICdtaXhlZCcgPyB0aGlzLnR5cGUgOiB0eXBlLFxuICAgICAgZGlyZWN0aW9uLFxuICAgICAgbm9kZURhdGEsXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIGl0ZXJhdGluZyBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzIHRvIGZpbmQgaWYgYW55IG9mIHRoZW1cbiAgICogbWF0Y2hlcyB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gdXNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZXJlIGFyZSB0b28gbWFueSBhcmd1bWVudHMuXG4gICAqL1xuICBjb25zdCBzb21lTmFtZSA9ICdzb21lJyArIGNhcGl0YWxpemVkU2luZ3VsYXI7XG5cbiAgQ2xhc3MucHJvdG90eXBlW3NvbWVOYW1lXSA9IGZ1bmN0aW9uIChub2RlLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGZvdW5kID0gdGhpc1tmaW5kTmFtZV0obm9kZSwgY2FsbGJhY2spO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gdHJ1ZTtcblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICAvKipcbiAgICogRnVuY3Rpb24gaXRlcmF0aW5nIG92ZXIgYWxsIHRoZSByZWxldmFudCBuZWlnaGJvcnMgdG8gZmluZCBpZiBhbGwgb2YgdGhlbVxuICAgKiBtYXRjaGUgdGhlIGdpdmVuIHByZWRpY2F0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgIG5vZGUgICAgIC0gVGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGVyZSBhcmUgdG9vIG1hbnkgYXJndW1lbnRzLlxuICAgKi9cbiAgY29uc3QgZXZlcnlOYW1lID0gJ2V2ZXJ5JyArIGNhcGl0YWxpemVkU2luZ3VsYXI7XG5cbiAgQ2xhc3MucHJvdG90eXBlW2V2ZXJ5TmFtZV0gPSBmdW5jdGlvbiAobm9kZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBmb3VuZCA9IHRoaXNbZmluZE5hbWVdKG5vZGUsIChuLCBhKSA9PiB7XG4gICAgICByZXR1cm4gIWNhbGxiYWNrKG4sIGEpO1xuICAgIH0pO1xuXG4gICAgaWYgKGZvdW5kKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBGdW5jdGlvbiBhdHRhY2hpbmcgYSBuZWlnaGJvcnMgY2FsbGJhY2sgaXRlcmF0b3IgbWV0aG9kIHRvIHRoZSBHcmFwaCBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3MgICAgICAgLSBUYXJnZXQgY2xhc3MuXG4gKiBAcGFyYW0ge29iamVjdH0gICBkZXNjcmlwdGlvbiAtIE1ldGhvZCBkZXNjcmlwdGlvbi5cbiAqL1xuZnVuY3Rpb24gYXR0YWNoTmVpZ2hib3JJdGVyYXRvckNyZWF0b3IoQ2xhc3MsIGRlc2NyaXB0aW9uKSB7XG4gIGNvbnN0IHtuYW1lLCB0eXBlLCBkaXJlY3Rpb259ID0gZGVzY3JpcHRpb247XG5cbiAgY29uc3QgaXRlcmF0b3JOYW1lID0gbmFtZS5zbGljZSgwLCAtMSkgKyAnRW50cmllcyc7XG5cbiAgLyoqXG4gICAqIEZ1bmN0aW9uIHJldHVybmluZyBhbiBpdGVyYXRvciBvdmVyIGFsbCB0aGUgcmVsZXZhbnQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICAgbm9kZSAgICAgLSBUYXJnZXQgbm9kZS5cbiAgICogQHJldHVybiB7SXRlcmF0b3J9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlcmUgYXJlIHRvbyBtYW55IGFyZ3VtZW50cy5cbiAgICovXG4gIENsYXNzLnByb3RvdHlwZVtpdGVyYXRvck5hbWVdID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0eXBlICE9PSAnbWl4ZWQnICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJyAmJiB0eXBlICE9PSB0aGlzLnR5cGUpXG4gICAgICByZXR1cm4gZW1wdHlJdGVyYXRvcigpO1xuXG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlRGF0YSA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguJHtpdGVyYXRvck5hbWV9OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIC8vIEhlcmUsIHdlIHdhbnQgdG8gaXRlcmF0ZSBvdmVyIGEgbm9kZSdzIHJlbGV2YW50IG5laWdoYm9yc1xuICAgIHJldHVybiBjcmVhdGVOZWlnaGJvckl0ZXJhdG9yKFxuICAgICAgdHlwZSA9PT0gJ21peGVkJyA/IHRoaXMudHlwZSA6IHR5cGUsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBub2RlRGF0YVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuICogRnVuY3Rpb24gYXR0YWNoaW5nIGV2ZXJ5IG5laWdoYm9yIGl0ZXJhdGlvbiBtZXRob2QgdG8gdGhlIEdyYXBoIGNsYXNzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IEdyYXBoIC0gR3JhcGggY2xhc3MuXG4gKi9cbmZ1bmN0aW9uIGF0dGFjaE5laWdoYm9ySXRlcmF0aW9uTWV0aG9kcyhHcmFwaCkge1xuICBORUlHSEJPUlNfSVRFUkFUSU9OLmZvckVhY2goZGVzY3JpcHRpb24gPT4ge1xuICAgIGF0dGFjaE5laWdoYm9yQXJyYXlDcmVhdG9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRm9yRWFjaE5laWdoYm9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoRmluZE5laWdoYm9yKEdyYXBoLCBkZXNjcmlwdGlvbik7XG4gICAgYXR0YWNoTmVpZ2hib3JJdGVyYXRvckNyZWF0b3IoR3JhcGgsIGRlc2NyaXB0aW9uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGhvbG9neSBBZGphY2VuY3kgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQXR0YWNoaW5nIHNvbWUgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MgdG8gYmUgYWJsZSB0byBpdGVyYXRlIG92ZXIgYVxuICogZ3JhcGgncyBhZGphY2VuY3kuXG4gKi9cblxuLyoqXG4gKiBGdW5jdGlvbiBpdGVyYXRpbmcgb3ZlciBhIHNpbXBsZSBncmFwaCdzIGFkamFjZW5jeSB1c2luZyBhIGNhbGxiYWNrLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gIGJyZWFrYWJsZSAgICAgICAgIC0gQ2FuIHdlIGJyZWFrP1xuICogQHBhcmFtIHtib29sZWFufSAgYXNzeW1ldHJpYyAgICAgICAgLSBXaGV0aGVyIHRvIGVtaXQgdW5kaXJlY3RlZCBlZGdlcyBvbmx5IG9uY2UuXG4gKiBAcGFyYW0ge2Jvb2xlYW59ICBkaXNjb25uZWN0ZWROb2RlcyAtIFdoZXRoZXIgdG8gZW1pdCBkaXNjb25uZWN0ZWQgbm9kZXMuXG4gKiBAcGFyYW0ge0dyYXBofSAgICBncmFwaCAgICAgICAgICAgICAtIFRhcmdldCBHcmFwaCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7Y2FsbGJhY2t9IGZ1bmN0aW9uICAgICAgICAgIC0gSXRlcmF0aW9uIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWRqYWNlbmN5KFxuICBicmVha2FibGUsXG4gIGFzc3ltZXRyaWMsXG4gIGRpc2Nvbm5lY3RlZE5vZGVzLFxuICBncmFwaCxcbiAgY2FsbGJhY2tcbikge1xuICBjb25zdCBpdGVyYXRvciA9IGdyYXBoLl9ub2Rlcy52YWx1ZXMoKTtcblxuICBjb25zdCB0eXBlID0gZ3JhcGgudHlwZTtcblxuICBsZXQgc3RlcCwgc291cmNlRGF0YSwgbmVpZ2hib3IsIGFkaiwgZWRnZURhdGEsIHRhcmdldERhdGEsIHNob3VsZEJyZWFrO1xuXG4gIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgbGV0IGhhc0VkZ2VzID0gZmFsc2U7XG5cbiAgICBzb3VyY2VEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgIGlmICh0eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGFkaiA9IHNvdXJjZURhdGEub3V0O1xuXG4gICAgICBmb3IgKG5laWdoYm9yIGluIGFkaikge1xuICAgICAgICBlZGdlRGF0YSA9IGFkaltuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBoYXNFZGdlcyA9IHRydWU7XG4gICAgICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgICAgIHNvdXJjZURhdGEua2V5LFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICB0YXJnZXREYXRhLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgICBlZGdlRGF0YS5rZXksXG4gICAgICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEudW5kaXJlY3RlZFxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoYnJlYWthYmxlICYmIHNob3VsZEJyZWFrKSByZXR1cm4gZWRnZURhdGE7XG5cbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgYWRqID0gc291cmNlRGF0YS51bmRpcmVjdGVkO1xuXG4gICAgICBmb3IgKG5laWdoYm9yIGluIGFkaikge1xuICAgICAgICBpZiAoYXNzeW1ldHJpYyAmJiBzb3VyY2VEYXRhLmtleSA+IG5laWdoYm9yKSBjb250aW51ZTtcblxuICAgICAgICBlZGdlRGF0YSA9IGFkaltuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHRhcmdldERhdGEgPSBlZGdlRGF0YS50YXJnZXQ7XG5cbiAgICAgICAgICBpZiAodGFyZ2V0RGF0YS5rZXkgIT09IG5laWdoYm9yKSB0YXJnZXREYXRhID0gZWRnZURhdGEuc291cmNlO1xuXG4gICAgICAgICAgaGFzRWRnZXMgPSB0cnVlO1xuICAgICAgICAgIHNob3VsZEJyZWFrID0gY2FsbGJhY2soXG4gICAgICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgICAgIHRhcmdldERhdGEua2V5LFxuICAgICAgICAgICAgc291cmNlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICAgICAgZWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWRcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIGVkZ2VEYXRhO1xuXG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRpc2Nvbm5lY3RlZE5vZGVzICYmICFoYXNFZGdlcykge1xuICAgICAgc2hvdWxkQnJlYWsgPSBjYWxsYmFjayhcbiAgICAgICAgc291cmNlRGF0YS5rZXksXG4gICAgICAgIG51bGwsXG4gICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcblxuICAgICAgaWYgKGJyZWFrYWJsZSAmJiBzaG91bGRCcmVhaykgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuO1xufVxuXG4vKipcbiAqIEdyYXBob2xvZ3kgU2VyaWFsaXphdGlvbiBVdGlsaXRpZXNcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29sbGVjdGlvbiBvZiBmdW5jdGlvbnMgdXNlZCBieSB0aGUgZ3JhcGggc2VyaWFsaXphdGlvbiBzY2hlbWVzLlxuICovXG5cbi8qKlxuICogRm9ybWF0cyBpbnRlcm5hbCBub2RlIGRhdGEgaW50byBhIHNlcmlhbGl6ZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHthbnl9ICAgIGtleSAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAtIEludGVybmFsIG5vZGUncyBkYXRhLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgIC0gVGhlIHNlcmlhbGl6ZWQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplTm9kZShrZXksIGRhdGEpIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHtrZXl9O1xuXG4gIGlmICghaXNFbXB0eShkYXRhLmF0dHJpYnV0ZXMpKVxuICAgIHNlcmlhbGl6ZWQuYXR0cmlidXRlcyA9IGFzc2lnbih7fSwgZGF0YS5hdHRyaWJ1dGVzKTtcblxuICByZXR1cm4gc2VyaWFsaXplZDtcbn1cblxuLyoqXG4gKiBGb3JtYXRzIGludGVybmFsIGVkZ2UgZGF0YSBpbnRvIGEgc2VyaWFsaXplZCBlZGdlLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gdHlwZSAtIFRoZSBncmFwaCdzIHR5cGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgIGtleSAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gZGF0YSAtIEludGVybmFsIGVkZ2UncyBkYXRhLlxuICogQHJldHVybiB7YXJyYXl9ICAgICAgIC0gVGhlIHNlcmlhbGl6ZWQgZWRnZS5cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplRWRnZSh0eXBlLCBrZXksIGRhdGEpIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICBrZXksXG4gICAgc291cmNlOiBkYXRhLnNvdXJjZS5rZXksXG4gICAgdGFyZ2V0OiBkYXRhLnRhcmdldC5rZXlcbiAgfTtcblxuICBpZiAoIWlzRW1wdHkoZGF0YS5hdHRyaWJ1dGVzKSlcbiAgICBzZXJpYWxpemVkLmF0dHJpYnV0ZXMgPSBhc3NpZ24oe30sIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgaWYgKHR5cGUgPT09ICdtaXhlZCcgJiYgZGF0YS51bmRpcmVjdGVkKSBzZXJpYWxpemVkLnVuZGlyZWN0ZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzZXJpYWxpemVkO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHNlcmlhbGl6ZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTZXJpYWxpemVkTm9kZSh2YWx1ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBub2RlLiBBIHNlcmlhbGl6ZWQgbm9kZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwia2V5XCIgcHJvcGVydHkuJ1xuICAgICk7XG5cbiAgaWYgKCEoJ2tleScgaW4gdmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IHNlcmlhbGl6ZWQgbm9kZSBpcyBtaXNzaW5nIGl0cyBrZXkuJ1xuICAgICk7XG5cbiAgaWYgKFxuICAgICdhdHRyaWJ1dGVzJyBpbiB2YWx1ZSAmJlxuICAgICghaXNQbGFpbk9iamVjdCh2YWx1ZS5hdHRyaWJ1dGVzKSB8fCB2YWx1ZS5hdHRyaWJ1dGVzID09PSBudWxsKVxuICApXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCBhdHRyaWJ1dGVzLiBBdHRyaWJ1dGVzIHNob3VsZCBiZSBhIHBsYWluIG9iamVjdCwgbnVsbCBvciBvbWl0dGVkLidcbiAgICApO1xufVxuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhIHNlcmlhbGl6ZWQgZWRnZS5cbiAqXG4gKiBAcGFyYW0gIHttaXhlZH0gdmFsdWUgLSBUYXJnZXQgdmFsdWUuXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTZXJpYWxpemVkRWRnZSh2YWx1ZSkge1xuICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgc2VyaWFsaXplZCBlZGdlLiBBIHNlcmlhbGl6ZWQgZWRnZSBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3Qgd2l0aCBhdCBsZWFzdCBhIFwic291cmNlXCIgJiBcInRhcmdldFwiIHByb3BlcnR5LidcbiAgICApO1xuXG4gIGlmICghKCdzb3VyY2UnIGluIHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIGVkZ2UgaXMgbWlzc2luZyBpdHMgc291cmNlLidcbiAgICApO1xuXG4gIGlmICghKCd0YXJnZXQnIGluIHZhbHVlKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAnR3JhcGguaW1wb3J0OiBzZXJpYWxpemVkIGVkZ2UgaXMgbWlzc2luZyBpdHMgdGFyZ2V0LidcbiAgICApO1xuXG4gIGlmIChcbiAgICAnYXR0cmlidXRlcycgaW4gdmFsdWUgJiZcbiAgICAoIWlzUGxhaW5PYmplY3QodmFsdWUuYXR0cmlidXRlcykgfHwgdmFsdWUuYXR0cmlidXRlcyA9PT0gbnVsbClcbiAgKVxuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gQXR0cmlidXRlcyBzaG91bGQgYmUgYSBwbGFpbiBvYmplY3QsIG51bGwgb3Igb21pdHRlZC4nXG4gICAgKTtcblxuICBpZiAoJ3VuZGlyZWN0ZWQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS51bmRpcmVjdGVkICE9PSAnYm9vbGVhbicpXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgJ0dyYXBoLmltcG9ydDogaW52YWxpZCB1bmRpcmVjdGVkbmVzcyBpbmZvcm1hdGlvbi4gVW5kaXJlY3RlZCBzaG91bGQgYmUgYm9vbGVhbiBvciBvbWl0dGVkLidcbiAgICApO1xufVxuXG4vKiBlc2xpbnQgbm8tbmVzdGVkLXRlcm5hcnk6IDAgKi9cblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbmNvbnN0IElOU1RBTkNFX0lEID0gaW5jcmVtZW50YWxJZFN0YXJ0aW5nRnJvbVJhbmRvbUJ5dGUoKTtcblxuLyoqXG4gKiBFbnVtcy5cbiAqL1xuY29uc3QgVFlQRVMgPSBuZXcgU2V0KFsnZGlyZWN0ZWQnLCAndW5kaXJlY3RlZCcsICdtaXhlZCddKTtcblxuY29uc3QgRU1JVFRFUl9QUk9QUyA9IG5ldyBTZXQoW1xuICAnZG9tYWluJyxcbiAgJ19ldmVudHMnLFxuICAnX2V2ZW50c0NvdW50JyxcbiAgJ19tYXhMaXN0ZW5lcnMnXG5dKTtcblxuY29uc3QgRURHRV9BRERfTUVUSE9EUyA9IFtcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1FZGdlYCxcbiAgICBnZW5lcmF0ZUtleTogdHJ1ZVxuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifURpcmVjdGVkRWRnZWAsXG4gICAgZ2VuZXJhdGVLZXk6IHRydWUsXG4gICAgdHlwZTogJ2RpcmVjdGVkJ1xuICB9LFxuICB7XG4gICAgbmFtZTogdmVyYiA9PiBgJHt2ZXJifVVuZGlyZWN0ZWRFZGdlYCxcbiAgICBnZW5lcmF0ZUtleTogdHJ1ZSxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1FZGdlV2l0aEtleWBcbiAgfSxcbiAge1xuICAgIG5hbWU6IHZlcmIgPT4gYCR7dmVyYn1EaXJlY3RlZEVkZ2VXaXRoS2V5YCxcbiAgICB0eXBlOiAnZGlyZWN0ZWQnXG4gIH0sXG4gIHtcbiAgICBuYW1lOiB2ZXJiID0+IGAke3ZlcmJ9VW5kaXJlY3RlZEVkZ2VXaXRoS2V5YCxcbiAgICB0eXBlOiAndW5kaXJlY3RlZCdcbiAgfVxuXTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMuXG4gKi9cbmNvbnN0IERFRkFVTFRTID0ge1xuICBhbGxvd1NlbGZMb29wczogdHJ1ZSxcbiAgbXVsdGk6IGZhbHNlLFxuICB0eXBlOiAnbWl4ZWQnXG59O1xuXG4vKipcbiAqIEFic3RyYWN0IGZ1bmN0aW9ucyB1c2VkIGJ5IHRoZSBHcmFwaCBjbGFzcyBmb3IgdmFyaW91cyBtZXRob2RzLlxuICovXG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gYWRkIGEgbm9kZSB0byB0aGUgZ2l2ZW4gZ3JhcGhcbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAgICAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAqIEBwYXJhbSAge29iamVjdH0gIFthdHRyaWJ1dGVzXSAgICAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gKiBAcmV0dXJuIHtOb2RlRGF0YX0gICAgICAgICAgICAgICAgLSBDcmVhdGVkIG5vZGUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gYWRkTm9kZShncmFwaCwgbm9kZSwgYXR0cmlidXRlcykge1xuICBpZiAoYXR0cmlidXRlcyAmJiAhaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguYWRkTm9kZTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgKTtcblxuICAvLyBTdHJpbmcgY29lcmNpb25cbiAgbm9kZSA9ICcnICsgbm9kZTtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKGdyYXBoLl9ub2Rlcy5oYXMobm9kZSkpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC5hZGROb2RlOiB0aGUgXCIke25vZGV9XCIgbm9kZSBhbHJlYWR5IGV4aXN0IGluIHRoZSBncmFwaC5gXG4gICAgKTtcblxuICBjb25zdCBkYXRhID0gbmV3IGdyYXBoLk5vZGVEYXRhQ2xhc3Mobm9kZSwgYXR0cmlidXRlcyk7XG5cbiAgLy8gQWRkaW5nIHRoZSBub2RlIHRvIGludGVybmFsIHJlZ2lzdGVyXG4gIGdyYXBoLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgLy8gRW1pdHRpbmdcbiAgZ3JhcGguZW1pdCgnbm9kZUFkZGVkJywge1xuICAgIGtleTogbm9kZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFNhbWUgYXMgdGhlIGFib3ZlIGJ1dCB3aXRob3V0IHNhbml0eSBjaGVja3MgYmVjYXVzZSB3ZSBjYWxsIHRoaXMgaW4gY29udGV4dHNcbiAqIHdoZXJlIG5lY2Vzc2FyeSBjaGVja3Mgd2VyZSBhbHJlYWR5IGRvbmUuXG4gKi9cbmZ1bmN0aW9uIHVuc2FmZUFkZE5vZGUoZ3JhcGgsIG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgY29uc3QgZGF0YSA9IG5ldyBncmFwaC5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gIGdyYXBoLl9ub2Rlcy5zZXQobm9kZSwgZGF0YSk7XG5cbiAgZ3JhcGguZW1pdCgnbm9kZUFkZGVkJywge1xuICAgIGtleTogbm9kZSxcbiAgICBhdHRyaWJ1dGVzXG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGFkZCBhbiBhcmJpdHJhcnkgZWRnZSB0byB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgZ3JhcGggICAgICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAgICAgICAgICAgIC0gTmFtZSBvZiB0aGUgY2hpbGQgbWV0aG9kIGZvciBlcnJvcnMuXG4gKiBAcGFyYW0gIHtib29sZWFufSBtdXN0R2VuZXJhdGVLZXkgLSBTaG91bGQgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkP1xuICogQHBhcmFtICB7Ym9vbGVhbn0gdW5kaXJlY3RlZCAgICAgIC0gV2hldGhlciB0aGUgZWRnZSBpcyB1bmRpcmVjdGVkLlxuICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAgICAgICAgICAgIC0gVGhlIGVkZ2UncyBrZXkuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgICAgICAgICAgLSBUaGUgc291cmNlIG5vZGUuXG4gKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgICAgICAgICAgLSBUaGUgdGFyZ2V0IG5vZGUuXG4gKiBAcGFyYW0gIHtvYmplY3R9ICBbYXR0cmlidXRlc10gICAgLSBPcHRpb25hbCBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVkZ2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgb2YgdGhlIHdyb25nIHR5cGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYW4gb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIGFkZEVkZ2UoXG4gIGdyYXBoLFxuICBuYW1lLFxuICBtdXN0R2VuZXJhdGVLZXksXG4gIHVuZGlyZWN0ZWQsXG4gIGVkZ2UsXG4gIHNvdXJjZSxcbiAgdGFyZ2V0LFxuICBhdHRyaWJ1dGVzXG4pIHtcbiAgLy8gQ2hlY2tpbmcgdmFsaWRpdHkgb2Ygb3BlcmF0aW9uXG4gIGlmICghdW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAndW5kaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IGFkZCBhIGRpcmVjdGVkIGVkZ2UgdG8gYW4gdW5kaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLmFkZEVkZ2Ugb3IgIy5hZGRVbmRpcmVjdGVkRWRnZSBpbnN0ZWFkLmBcbiAgICApO1xuXG4gIGlmICh1bmRpcmVjdGVkICYmIGdyYXBoLnR5cGUgPT09ICdkaXJlY3RlZCcpXG4gICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgIGBHcmFwaC4ke25hbWV9OiB5b3UgY2Fubm90IGFkZCBhbiB1bmRpcmVjdGVkIGVkZ2UgdG8gYSBkaXJlY3RlZCBncmFwaC4gVXNlIHRoZSAjLmFkZEVkZ2Ugb3IgIy5hZGREaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAoYXR0cmlidXRlcyAmJiAhaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgKTtcblxuICAvLyBDb2VyY2lvbiBvZiBzb3VyY2UgJiB0YXJnZXQ6XG4gIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICB0YXJnZXQgPSAnJyArIHRhcmdldDtcbiAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG5cbiAgaWYgKCFncmFwaC5hbGxvd1NlbGZMb29wcyAmJiBzb3VyY2UgPT09IHRhcmdldClcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IHNvdXJjZSAmIHRhcmdldCBhcmUgdGhlIHNhbWUgKFwiJHtzb3VyY2V9XCIpLCB0aHVzIGNyZWF0aW5nIGEgbG9vcCBleHBsaWNpdGx5IGZvcmJpZGRlbiBieSB0aGlzIGdyYXBoICdhbGxvd1NlbGZMb29wcycgb3B0aW9uIHNldCB0byBmYWxzZS5gXG4gICAgKTtcblxuICBjb25zdCBzb3VyY2VEYXRhID0gZ3JhcGguX25vZGVzLmdldChzb3VyY2UpLFxuICAgIHRhcmdldERhdGEgPSBncmFwaC5fbm9kZXMuZ2V0KHRhcmdldCk7XG5cbiAgaWYgKCFzb3VyY2VEYXRhKVxuICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogc291cmNlIG5vZGUgXCIke3NvdXJjZX1cIiBub3QgZm91bmQuYFxuICAgICk7XG5cbiAgaWYgKCF0YXJnZXREYXRhKVxuICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogdGFyZ2V0IG5vZGUgXCIke3RhcmdldH1cIiBub3QgZm91bmQuYFxuICAgICk7XG5cbiAgLy8gTXVzdCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQgZm9yIHRoaXMgZWRnZT9cbiAgY29uc3QgZXZlbnREYXRhID0ge1xuICAgIGtleTogbnVsbCxcbiAgICB1bmRpcmVjdGVkLFxuICAgIHNvdXJjZSxcbiAgICB0YXJnZXQsXG4gICAgYXR0cmlidXRlc1xuICB9O1xuXG4gIGlmIChtdXN0R2VuZXJhdGVLZXkpIHtcbiAgICAvLyBOT1RFOiBpbiB0aGlzIGNhc2Ugd2UgY2FuIGd1YXJhbnRlZSB0aGF0IHRoZSBrZXkgZG9lcyBub3QgYWxyZWFkeVxuICAgIC8vIGV4aXN0IGFuZCBpcyBhbHJlYWR5IGNvcnJlY3RseSBjYXN0ZWQgYXMgYSBzdHJpbmdcbiAgICBlZGdlID0gZ3JhcGguX2VkZ2VLZXlHZW5lcmF0b3IoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBDb2VyY2lvbiBvZiBlZGdlIGtleVxuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICAvLyBIZXJlLCB3ZSBoYXZlIGEga2V5IGNvbGxpc2lvblxuICAgIGlmIChncmFwaC5fZWRnZXMuaGFzKGVkZ2UpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLiR7bmFtZX06IHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGFscmVhZHkgZXhpc3RzIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuICB9XG5cbiAgLy8gSGVyZSwgd2UgbWlnaHQgaGF2ZSBhIHNvdXJjZSAvIHRhcmdldCBjb2xsaXNpb25cbiAgaWYgKFxuICAgICFncmFwaC5tdWx0aSAmJlxuICAgICh1bmRpcmVjdGVkXG4gICAgICA/IHR5cGVvZiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgIDogdHlwZW9mIHNvdXJjZURhdGEub3V0W3RhcmdldF0gIT09ICd1bmRlZmluZWQnKVxuICApIHtcbiAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLiR7bmFtZX06IGFuIGVkZ2UgbGlua2luZyBcIiR7c291cmNlfVwiIHRvIFwiJHt0YXJnZXR9XCIgYWxyZWFkeSBleGlzdHMuIElmIHlvdSByZWFsbHkgd2FudCB0byBhZGQgbXVsdGlwbGUgZWRnZXMgbGlua2luZyB0aG9zZSBub2RlcywgeW91IHNob3VsZCBjcmVhdGUgYSBtdWx0aSBncmFwaCBieSB1c2luZyB0aGUgJ211bHRpJyBvcHRpb24uYFxuICAgICk7XG4gIH1cblxuICAvLyBTdG9yaW5nIHNvbWUgZGF0YVxuICBjb25zdCBlZGdlRGF0YSA9IG5ldyBFZGdlRGF0YShcbiAgICB1bmRpcmVjdGVkLFxuICAgIGVkZ2UsXG4gICAgc291cmNlRGF0YSxcbiAgICB0YXJnZXREYXRhLFxuICAgIGF0dHJpYnV0ZXNcbiAgKTtcblxuICAvLyBBZGRpbmcgdGhlIGVkZ2UgdG8gdGhlIGludGVybmFsIHJlZ2lzdGVyXG4gIGdyYXBoLl9lZGdlcy5zZXQoZWRnZSwgZWRnZURhdGEpO1xuXG4gIC8vIEluY3JlbWVudGluZyBub2RlIGRlZ3JlZSBjb3VudGVyc1xuICBjb25zdCBpc1NlbGZMb29wID0gc291cmNlID09PSB0YXJnZXQ7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIHtcbiAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLnVuZGlyZWN0ZWREZWdyZWUrKztcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZURhdGEub3V0RGVncmVlKys7XG4gICAgdGFyZ2V0RGF0YS5pbkRlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEuZGlyZWN0ZWRMb29wcysrO1xuICAgICAgZ3JhcGguX2RpcmVjdGVkU2VsZkxvb3BDb3VudCsrO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVwZGF0aW5nIHJlbGV2YW50IGluZGV4XG4gIGlmIChncmFwaC5tdWx0aSkgZWRnZURhdGEuYXR0YWNoTXVsdGkoKTtcbiAgZWxzZSBlZGdlRGF0YS5hdHRhY2goKTtcblxuICBpZiAodW5kaXJlY3RlZCkgZ3JhcGguX3VuZGlyZWN0ZWRTaXplKys7XG4gIGVsc2UgZ3JhcGguX2RpcmVjdGVkU2l6ZSsrO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGV2ZW50RGF0YS5rZXkgPSBlZGdlO1xuXG4gIGdyYXBoLmVtaXQoJ2VkZ2VBZGRlZCcsIGV2ZW50RGF0YSk7XG5cbiAgcmV0dXJuIGVkZ2U7XG59XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gYWRkIGFuIGFyYml0cmFyeSBlZGdlIHRvIHRoZSBnaXZlbiBncmFwaC5cbiAqXG4gKiBAcGFyYW0gIHtHcmFwaH0gICBncmFwaCAgICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtzdHJpbmd9ICBuYW1lICAgICAgICAgICAgLSBOYW1lIG9mIHRoZSBjaGlsZCBtZXRob2QgZm9yIGVycm9ycy5cbiAqIEBwYXJhbSAge2Jvb2xlYW59IG11c3RHZW5lcmF0ZUtleSAtIFNob3VsZCB0aGUgZ3JhcGggZ2VuZXJhdGUgYW4gaWQ/XG4gKiBAcGFyYW0gIHtib29sZWFufSB1bmRpcmVjdGVkICAgICAgLSBXaGV0aGVyIHRoZSBlZGdlIGlzIHVuZGlyZWN0ZWQuXG4gKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlICAgICAgICAgICAgLSBUaGUgZWRnZSdzIGtleS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAgICAgICAgICAtIFRoZSBzb3VyY2Ugbm9kZS5cbiAqIEBwYXJhbSAge2FueX0gICAgIHRhcmdldCAgICAgICAgICAtIFRoZSB0YXJnZXQgbm9kZS5cbiAqIEBwYXJhbSAge29iamVjdH0gIFthdHRyaWJ1dGVzXSAgICAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0gIHtib29sZWFufSBbYXNVcGRhdGVyXSAgICAgICAtIEFyZSB3ZSB1cGRhdGluZyBvciBtZXJnaW5nP1xuICogQHJldHVybiB7YW55fSAgICAgICAgICAgICAgICAgICAgIC0gVGhlIGVkZ2UuXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgb2YgdGhlIHdyb25nIHR5cGUuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYW4gb2JqZWN0LlxuICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGFscmVhZHkgZXhpc3QuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlRWRnZShcbiAgZ3JhcGgsXG4gIG5hbWUsXG4gIG11c3RHZW5lcmF0ZUtleSxcbiAgdW5kaXJlY3RlZCxcbiAgZWRnZSxcbiAgc291cmNlLFxuICB0YXJnZXQsXG4gIGF0dHJpYnV0ZXMsXG4gIGFzVXBkYXRlclxuKSB7XG4gIC8vIENoZWNraW5nIHZhbGlkaXR5IG9mIG9wZXJhdGlvblxuICBpZiAoIXVuZGlyZWN0ZWQgJiYgZ3JhcGgudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBtZXJnZS91cGRhdGUgYSBkaXJlY3RlZCBlZGdlIHRvIGFuIHVuZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5tZXJnZUVkZ2UvIy51cGRhdGVFZGdlIG9yICMuYWRkVW5kaXJlY3RlZEVkZ2UgaW5zdGVhZC5gXG4gICAgKTtcblxuICBpZiAodW5kaXJlY3RlZCAmJiBncmFwaC50eXBlID09PSAnZGlyZWN0ZWQnKVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogeW91IGNhbm5vdCBtZXJnZS91cGRhdGUgYW4gdW5kaXJlY3RlZCBlZGdlIHRvIGEgZGlyZWN0ZWQgZ3JhcGguIFVzZSB0aGUgIy5tZXJnZUVkZ2UvIy51cGRhdGVFZGdlIG9yICMuYWRkRGlyZWN0ZWRFZGdlIGluc3RlYWQuYFxuICAgICk7XG5cbiAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAoYXNVcGRhdGVyKSB7XG4gICAgICBpZiAodHlwZW9mIGF0dHJpYnV0ZXMgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCB1cGRhdGVyIGZ1bmN0aW9uLiBFeHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiJHthdHRyaWJ1dGVzfVwiYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpXG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguJHtuYW1lfTogaW52YWxpZCBhdHRyaWJ1dGVzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGJ1dCBnb3QgXCIke2F0dHJpYnV0ZXN9XCJgXG4gICAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLy8gQ29lcmNpb24gb2Ygc291cmNlICYgdGFyZ2V0OlxuICBzb3VyY2UgPSAnJyArIHNvdXJjZTtcbiAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgbGV0IHVwZGF0ZXI7XG5cbiAgaWYgKGFzVXBkYXRlcikge1xuICAgIHVwZGF0ZXIgPSBhdHRyaWJ1dGVzO1xuICAgIGF0dHJpYnV0ZXMgPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAoIWdyYXBoLmFsbG93U2VsZkxvb3BzICYmIHNvdXJjZSA9PT0gdGFyZ2V0KVxuICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguJHtuYW1lfTogc291cmNlICYgdGFyZ2V0IGFyZSB0aGUgc2FtZSAoXCIke3NvdXJjZX1cIiksIHRodXMgY3JlYXRpbmcgYSBsb29wIGV4cGxpY2l0bHkgZm9yYmlkZGVuIGJ5IHRoaXMgZ3JhcGggJ2FsbG93U2VsZkxvb3BzJyBvcHRpb24gc2V0IHRvIGZhbHNlLmBcbiAgICApO1xuXG4gIGxldCBzb3VyY2VEYXRhID0gZ3JhcGguX25vZGVzLmdldChzb3VyY2UpO1xuICBsZXQgdGFyZ2V0RGF0YSA9IGdyYXBoLl9ub2Rlcy5nZXQodGFyZ2V0KTtcbiAgbGV0IGVkZ2VEYXRhO1xuXG4gIC8vIERvIHdlIG5lZWQgdG8gaGFuZGxlIGR1cGxpY2F0ZT9cbiAgbGV0IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhO1xuXG4gIGlmICghbXVzdEdlbmVyYXRlS2V5KSB7XG4gICAgZWRnZURhdGEgPSBncmFwaC5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSB7XG4gICAgICAvLyBIZXJlLCB3ZSBuZWVkIHRvIGVuc3VyZSwgaWYgdGhlIHVzZXIgZ2F2ZSBhIGtleSwgdGhhdCBzb3VyY2UgJiB0YXJnZXRcbiAgICAgIC8vIGFyZSBjb25zaXN0ZW50XG4gICAgICBpZiAoZWRnZURhdGEuc291cmNlLmtleSAhPT0gc291cmNlIHx8IGVkZ2VEYXRhLnRhcmdldC5rZXkgIT09IHRhcmdldCkge1xuICAgICAgICAvLyBJZiBzb3VyY2Ugb3IgdGFyZ2V0IGluY29uc2lzdGVudFxuICAgICAgICBpZiAoXG4gICAgICAgICAgIXVuZGlyZWN0ZWQgfHxcbiAgICAgICAgICBlZGdlRGF0YS5zb3VyY2Uua2V5ICE9PSB0YXJnZXQgfHxcbiAgICAgICAgICBlZGdlRGF0YS50YXJnZXQua2V5ICE9PSBzb3VyY2VcbiAgICAgICAgKSB7XG4gICAgICAgICAgLy8gSWYgZGlyZWN0ZWQsIG9yIHNvdXJjZS90YXJnZXQgYXJlbid0IGZsaXBwZWRcbiAgICAgICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAgICAgYEdyYXBoLiR7bmFtZX06IGluY29uc2lzdGVuY3kgZGV0ZWN0ZWQgd2hlbiBhdHRlbXB0aW5nIHRvIG1lcmdlIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIHdpdGggXCIke3NvdXJjZX1cIiBzb3VyY2UgJiBcIiR7dGFyZ2V0fVwiIHRhcmdldCB2cy4gKFwiJHtlZGdlRGF0YS5zb3VyY2Uua2V5fVwiLCBcIiR7ZWRnZURhdGEudGFyZ2V0LmtleX1cIikuYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEgPSBlZGdlRGF0YTtcbiAgICB9XG4gIH1cblxuICAvLyBIZXJlLCB3ZSBtaWdodCBoYXZlIGEgc291cmNlIC8gdGFyZ2V0IGNvbGxpc2lvblxuICBpZiAoIWFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhICYmICFncmFwaC5tdWx0aSAmJiBzb3VyY2VEYXRhKSB7XG4gICAgYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEgPSB1bmRpcmVjdGVkXG4gICAgICA/IHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdXG4gICAgICA6IHNvdXJjZURhdGEub3V0W3RhcmdldF07XG4gIH1cblxuICAvLyBIYW5kbGluZyBkdXBsaWNhdGVzXG4gIGlmIChhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YSkge1xuICAgIGNvbnN0IGluZm8gPSBbYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEua2V5LCBmYWxzZSwgZmFsc2UsIGZhbHNlXTtcblxuICAgIC8vIFdlIGNhbiBza2lwIHRoZSBhdHRyaWJ1dGUgbWVyZ2luZyBwYXJ0IGlmIHRoZSB1c2VyIGRpZCBub3QgcHJvdmlkZSB0aGVtXG4gICAgaWYgKGFzVXBkYXRlciA/ICF1cGRhdGVyIDogIWF0dHJpYnV0ZXMpIHJldHVybiBpbmZvO1xuXG4gICAgLy8gVXBkYXRpbmcgdGhlIGF0dHJpYnV0ZXNcbiAgICBpZiAoYXNVcGRhdGVyKSB7XG4gICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcztcbiAgICAgIGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXMgPSB1cGRhdGVyKG9sZEF0dHJpYnV0ZXMpO1xuXG4gICAgICBncmFwaC5lbWl0KCdlZGdlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgIHR5cGU6ICdyZXBsYWNlJyxcbiAgICAgICAga2V5OiBhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5rZXksXG4gICAgICAgIGF0dHJpYnV0ZXM6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE1lcmdpbmcgdGhlIGF0dHJpYnV0ZXNcbiAgICBlbHNlIHtcbiAgICAgIGFzc2lnbihhbHJlYWR5RXhpc3RpbmdFZGdlRGF0YS5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKTtcblxuICAgICAgZ3JhcGguZW1pdCgnZWRnZUF0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgICBrZXk6IGFscmVhZHlFeGlzdGluZ0VkZ2VEYXRhLmtleSxcbiAgICAgICAgYXR0cmlidXRlczogYWxyZWFkeUV4aXN0aW5nRWRnZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgZGF0YTogYXR0cmlidXRlc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZm87XG4gIH1cblxuICBhdHRyaWJ1dGVzID0gYXR0cmlidXRlcyB8fCB7fTtcblxuICBpZiAoYXNVcGRhdGVyICYmIHVwZGF0ZXIpIGF0dHJpYnV0ZXMgPSB1cGRhdGVyKGF0dHJpYnV0ZXMpO1xuXG4gIC8vIE11c3QgdGhlIGdyYXBoIGdlbmVyYXRlIGFuIGlkIGZvciB0aGlzIGVkZ2U/XG4gIGNvbnN0IGV2ZW50RGF0YSA9IHtcbiAgICBrZXk6IG51bGwsXG4gICAgdW5kaXJlY3RlZCxcbiAgICBzb3VyY2UsXG4gICAgdGFyZ2V0LFxuICAgIGF0dHJpYnV0ZXNcbiAgfTtcblxuICBpZiAobXVzdEdlbmVyYXRlS2V5KSB7XG4gICAgLy8gTk9URTogaW4gdGhpcyBjYXNlIHdlIGNhbiBndWFyYW50ZWUgdGhhdCB0aGUga2V5IGRvZXMgbm90IGFscmVhZHlcbiAgICAvLyBleGlzdCBhbmQgaXMgYWxyZWFkeSBjb3JyZWN0bHkgY2FzdGVkIGFzIGEgc3RyaW5nXG4gICAgZWRnZSA9IGdyYXBoLl9lZGdlS2V5R2VuZXJhdG9yKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29lcmNpb24gb2YgZWRnZSBrZXlcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgLy8gSGVyZSwgd2UgaGF2ZSBhIGtleSBjb2xsaXNpb25cbiAgICBpZiAoZ3JhcGguX2VkZ2VzLmhhcyhlZGdlKSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC4ke25hbWV9OiB0aGUgXCIke2VkZ2V9XCIgZWRnZSBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcbiAgfVxuXG4gIGxldCBzb3VyY2VXYXNBZGRlZCA9IGZhbHNlO1xuICBsZXQgdGFyZ2V0V2FzQWRkZWQgPSBmYWxzZTtcblxuICBpZiAoIXNvdXJjZURhdGEpIHtcbiAgICBzb3VyY2VEYXRhID0gdW5zYWZlQWRkTm9kZShncmFwaCwgc291cmNlLCB7fSk7XG4gICAgc291cmNlV2FzQWRkZWQgPSB0cnVlO1xuXG4gICAgaWYgKHNvdXJjZSA9PT0gdGFyZ2V0KSB7XG4gICAgICB0YXJnZXREYXRhID0gc291cmNlRGF0YTtcbiAgICAgIHRhcmdldFdhc0FkZGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKCF0YXJnZXREYXRhKSB7XG4gICAgdGFyZ2V0RGF0YSA9IHVuc2FmZUFkZE5vZGUoZ3JhcGgsIHRhcmdldCwge30pO1xuICAgIHRhcmdldFdhc0FkZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFN0b3Jpbmcgc29tZSBkYXRhXG4gIGVkZ2VEYXRhID0gbmV3IEVkZ2VEYXRhKHVuZGlyZWN0ZWQsIGVkZ2UsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGF0dHJpYnV0ZXMpO1xuXG4gIC8vIEFkZGluZyB0aGUgZWRnZSB0byB0aGUgaW50ZXJuYWwgcmVnaXN0ZXJcbiAgZ3JhcGguX2VkZ2VzLnNldChlZGdlLCBlZGdlRGF0YSk7XG5cbiAgLy8gSW5jcmVtZW50aW5nIG5vZGUgZGVncmVlIGNvdW50ZXJzXG4gIGNvbnN0IGlzU2VsZkxvb3AgPSBzb3VyY2UgPT09IHRhcmdldDtcblxuICBpZiAodW5kaXJlY3RlZCkge1xuICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuICAgIHRhcmdldERhdGEudW5kaXJlY3RlZERlZ3JlZSsrO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEudW5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fdW5kaXJlY3RlZFNlbGZMb29wQ291bnQrKztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc291cmNlRGF0YS5vdXREZWdyZWUrKztcbiAgICB0YXJnZXREYXRhLmluRGVncmVlKys7XG5cbiAgICBpZiAoaXNTZWxmTG9vcCkge1xuICAgICAgc291cmNlRGF0YS5kaXJlY3RlZExvb3BzKys7XG4gICAgICBncmFwaC5fZGlyZWN0ZWRTZWxmTG9vcENvdW50Kys7XG4gICAgfVxuICB9XG5cbiAgLy8gVXBkYXRpbmcgcmVsZXZhbnQgaW5kZXhcbiAgaWYgKGdyYXBoLm11bHRpKSBlZGdlRGF0YS5hdHRhY2hNdWx0aSgpO1xuICBlbHNlIGVkZ2VEYXRhLmF0dGFjaCgpO1xuXG4gIGlmICh1bmRpcmVjdGVkKSBncmFwaC5fdW5kaXJlY3RlZFNpemUrKztcbiAgZWxzZSBncmFwaC5fZGlyZWN0ZWRTaXplKys7XG5cbiAgLy8gRW1pdHRpbmdcbiAgZXZlbnREYXRhLmtleSA9IGVkZ2U7XG5cbiAgZ3JhcGguZW1pdCgnZWRnZUFkZGVkJywgZXZlbnREYXRhKTtcblxuICByZXR1cm4gW2VkZ2UsIHRydWUsIHNvdXJjZVdhc0FkZGVkLCB0YXJnZXRXYXNBZGRlZF07XG59XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gZHJvcCBhbiBlZGdlLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge0VkZ2VEYXRhfSBlZGdlRGF0YSAtIERhdGEgb2YgdGhlIGVkZ2UgdG8gZHJvcC5cbiAqL1xuZnVuY3Rpb24gZHJvcEVkZ2VGcm9tRGF0YShncmFwaCwgZWRnZURhdGEpIHtcbiAgLy8gRHJvcHBpbmcgdGhlIGVkZ2UgZnJvbSB0aGUgcmVnaXN0ZXJcbiAgZ3JhcGguX2VkZ2VzLmRlbGV0ZShlZGdlRGF0YS5rZXkpO1xuXG4gIC8vIFVwZGF0aW5nIHJlbGF0ZWQgZGVncmVlc1xuICBjb25zdCB7c291cmNlOiBzb3VyY2VEYXRhLCB0YXJnZXQ6IHRhcmdldERhdGEsIGF0dHJpYnV0ZXN9ID0gZWRnZURhdGE7XG5cbiAgY29uc3QgdW5kaXJlY3RlZCA9IGVkZ2VEYXRhLnVuZGlyZWN0ZWQ7XG5cbiAgY29uc3QgaXNTZWxmTG9vcCA9IHNvdXJjZURhdGEgPT09IHRhcmdldERhdGE7XG5cbiAgaWYgKHVuZGlyZWN0ZWQpIHtcbiAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWREZWdyZWUtLTtcbiAgICB0YXJnZXREYXRhLnVuZGlyZWN0ZWREZWdyZWUtLTtcblxuICAgIGlmIChpc1NlbGZMb29wKSB7XG4gICAgICBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRMb29wcy0tO1xuICAgICAgZ3JhcGguX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50LS07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNvdXJjZURhdGEub3V0RGVncmVlLS07XG4gICAgdGFyZ2V0RGF0YS5pbkRlZ3JlZS0tO1xuXG4gICAgaWYgKGlzU2VsZkxvb3ApIHtcbiAgICAgIHNvdXJjZURhdGEuZGlyZWN0ZWRMb29wcy0tO1xuICAgICAgZ3JhcGguX2RpcmVjdGVkU2VsZkxvb3BDb3VudC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIENsZWFyaW5nIGluZGV4XG4gIGlmIChncmFwaC5tdWx0aSkgZWRnZURhdGEuZGV0YWNoTXVsdGkoKTtcbiAgZWxzZSBlZGdlRGF0YS5kZXRhY2goKTtcblxuICBpZiAodW5kaXJlY3RlZCkgZ3JhcGguX3VuZGlyZWN0ZWRTaXplLS07XG4gIGVsc2UgZ3JhcGguX2RpcmVjdGVkU2l6ZS0tO1xuXG4gIC8vIEVtaXR0aW5nXG4gIGdyYXBoLmVtaXQoJ2VkZ2VEcm9wcGVkJywge1xuICAgIGtleTogZWRnZURhdGEua2V5LFxuICAgIGF0dHJpYnV0ZXMsXG4gICAgc291cmNlOiBzb3VyY2VEYXRhLmtleSxcbiAgICB0YXJnZXQ6IHRhcmdldERhdGEua2V5LFxuICAgIHVuZGlyZWN0ZWRcbiAgfSk7XG59XG5cbi8qKlxuICogR3JhcGggY2xhc3NcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSAge29iamVjdH0gIFtvcHRpb25zXSAtIE9wdGlvbnM6XG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFthbGxvd1NlbGZMb29wc10gLSBBbGxvdyBzZWxmIGxvb3BzP1xuICogQHBhcmFtICB7c3RyaW5nfSAgICBbdHlwZV0gICAgICAgICAgIC0gVHlwZSBvZiB0aGUgZ3JhcGguXG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFttYXBdICAgICAgICAgICAgLSBBbGxvdyByZWZlcmVuY2VzIGFzIGtleXM/XG4gKiBAcGFyYW0gIHtib29sZWFufSAgIFttdWx0aV0gICAgICAgICAgLSBBbGxvdyBwYXJhbGxlbCBlZGdlcz9cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCB2YWxpZC5cbiAqL1xuY2xhc3MgR3JhcGggZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIC8vLS0gU29sdmluZyBvcHRpb25zXG4gICAgb3B0aW9ucyA9IGFzc2lnbih7fSwgREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgLy8gRW5mb3JjaW5nIG9wdGlvbnMgdmFsaWRpdHlcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMubXVsdGkgIT09ICdib29sZWFuJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvbnN0cnVjdG9yOiBpbnZhbGlkICdtdWx0aScgb3B0aW9uLiBFeHBlY3RpbmcgYSBib29sZWFuIGJ1dCBnb3QgXCIke29wdGlvbnMubXVsdGl9XCIuYFxuICAgICAgKTtcblxuICAgIGlmICghVFlQRVMuaGFzKG9wdGlvbnMudHlwZSkpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAndHlwZScgb3B0aW9uLiBTaG91bGQgYmUgb25lIG9mIFwibWl4ZWRcIiwgXCJkaXJlY3RlZFwiIG9yIFwidW5kaXJlY3RlZFwiIGJ1dCBnb3QgXCIke29wdGlvbnMudHlwZX1cIi5gXG4gICAgICApO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93U2VsZkxvb3BzICE9PSAnYm9vbGVhbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5jb25zdHJ1Y3RvcjogaW52YWxpZCAnYWxsb3dTZWxmTG9vcHMnIG9wdGlvbi4gRXhwZWN0aW5nIGEgYm9vbGVhbiBidXQgZ290IFwiJHtvcHRpb25zLmFsbG93U2VsZkxvb3BzfVwiLmBcbiAgICAgICk7XG5cbiAgICAvLy0tIFByaXZhdGUgcHJvcGVydGllc1xuXG4gICAgLy8gVXRpbGl0aWVzXG4gICAgY29uc3QgTm9kZURhdGFDbGFzcyA9XG4gICAgICBvcHRpb25zLnR5cGUgPT09ICdtaXhlZCdcbiAgICAgICAgPyBNaXhlZE5vZGVEYXRhXG4gICAgICAgIDogb3B0aW9ucy50eXBlID09PSAnZGlyZWN0ZWQnXG4gICAgICAgID8gRGlyZWN0ZWROb2RlRGF0YVxuICAgICAgICA6IFVuZGlyZWN0ZWROb2RlRGF0YTtcblxuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnTm9kZURhdGFDbGFzcycsIE5vZGVEYXRhQ2xhc3MpO1xuXG4gICAgLy8gSW50ZXJuYWwgZWRnZSBrZXkgZ2VuZXJhdG9yXG5cbiAgICAvLyBOT1RFOiB0aGlzIGludGVybmFsIGdlbmVyYXRvciBwcm9kdWNlIGtleXMgdGhhdCBhcmUgc3RyaW5nc1xuICAgIC8vIGNvbXBvc2VkIG9mIGEgd2VpcmQgcHJlZml4LCBhbiBpbmNyZW1lbnRhbCBpbnN0YW5jZSBpZCBzdGFydGluZyBmcm9tXG4gICAgLy8gYSByYW5kb20gYnl0ZSBhbmQgZmluYWxseSBhbiBpbnRlcm5hbCBpbnN0YW5jZSBpbmNyZW1lbnRhbCBpZC5cbiAgICAvLyBBbGwgdGhpcyB0byBhdm9pZCBpbnRyYS1mcmFtZSBhbmQgY3Jvc3MtZnJhbWUgYWR2ZXJzYXJpYWwgaW5wdXRzXG4gICAgLy8gdGhhdCBjYW4gZm9yY2UgYSBzaW5nbGUgIy5hZGRFZGdlIGNhbGwgdG8gZGVnZW5lcmF0ZSBpbnRvIGEgTyhuKVxuICAgIC8vIGF2YWlsYWJsZSBrZXkgc2VhcmNoIGxvb3AuXG5cbiAgICAvLyBJdCBhbHNvIGVuc3VyZXMgdGhhdCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlZCBlZGdlIGtleXMgYXJlIHVubGlrZWx5XG4gICAgLy8gdG8gcHJvZHVjZSBjb2xsaXNpb25zIHdpdGggYXJiaXRyYXJ5IGtleXMgZ2l2ZW4gYnkgdXNlcnMuXG4gICAgY29uc3QgaW5zdGFuY2VQcmVmaXggPSAnZ2VpZF8nICsgSU5TVEFOQ0VfSUQoKSArICdfJztcbiAgICBsZXQgZWRnZUlkID0gMDtcblxuICAgIGNvbnN0IGVkZ2VLZXlHZW5lcmF0b3IgPSAoKSA9PiB7XG4gICAgICBsZXQgYXZhaWxhYmxlRWRnZUtleTtcblxuICAgICAgZG8ge1xuICAgICAgICBhdmFpbGFibGVFZGdlS2V5ID0gaW5zdGFuY2VQcmVmaXggKyBlZGdlSWQrKztcbiAgICAgIH0gd2hpbGUgKHRoaXMuX2VkZ2VzLmhhcyhhdmFpbGFibGVFZGdlS2V5KSk7XG5cbiAgICAgIHJldHVybiBhdmFpbGFibGVFZGdlS2V5O1xuICAgIH07XG5cbiAgICAvLyBJbmRleGVzXG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfYXR0cmlidXRlcycsIHt9KTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19ub2RlcycsIG5ldyBNYXAoKSk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZWRnZXMnLCBuZXcgTWFwKCkpO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX2RpcmVjdGVkU2l6ZScsIDApO1xuICAgIHByaXZhdGVQcm9wZXJ0eSh0aGlzLCAnX3VuZGlyZWN0ZWRTaXplJywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfZGlyZWN0ZWRTZWxmTG9vcENvdW50JywgMCk7XG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfdW5kaXJlY3RlZFNlbGZMb29wQ291bnQnLCAwKTtcbiAgICBwcml2YXRlUHJvcGVydHkodGhpcywgJ19lZGdlS2V5R2VuZXJhdG9yJywgZWRnZUtleUdlbmVyYXRvcik7XG5cbiAgICAvLyBPcHRpb25zXG4gICAgcHJpdmF0ZVByb3BlcnR5KHRoaXMsICdfb3B0aW9ucycsIG9wdGlvbnMpO1xuXG4gICAgLy8gRW1pdHRlciBwcm9wZXJ0aWVzXG4gICAgRU1JVFRFUl9QUk9QUy5mb3JFYWNoKHByb3AgPT4gcHJpdmF0ZVByb3BlcnR5KHRoaXMsIHByb3AsIHRoaXNbcHJvcF0pKTtcblxuICAgIC8vLS0gUHJvcGVydGllcyByZWFkZXJzXG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnb3JkZXInLCAoKSA9PiB0aGlzLl9ub2Rlcy5zaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdzaXplJywgKCkgPT4gdGhpcy5fZWRnZXMuc2l6ZSk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnZGlyZWN0ZWRTaXplJywgKCkgPT4gdGhpcy5fZGlyZWN0ZWRTaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICd1bmRpcmVjdGVkU2l6ZScsICgpID0+IHRoaXMuX3VuZGlyZWN0ZWRTaXplKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdzZWxmTG9vcENvdW50JyxcbiAgICAgICgpID0+IHRoaXMuX2RpcmVjdGVkU2VsZkxvb3BDb3VudCArIHRoaXMuX3VuZGlyZWN0ZWRTZWxmTG9vcENvdW50XG4gICAgKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICdkaXJlY3RlZFNlbGZMb29wQ291bnQnLFxuICAgICAgKCkgPT4gdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50XG4gICAgKTtcbiAgICByZWFkT25seVByb3BlcnR5KFxuICAgICAgdGhpcyxcbiAgICAgICd1bmRpcmVjdGVkU2VsZkxvb3BDb3VudCcsXG4gICAgICAoKSA9PiB0aGlzLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudFxuICAgICk7XG4gICAgcmVhZE9ubHlQcm9wZXJ0eSh0aGlzLCAnbXVsdGknLCB0aGlzLl9vcHRpb25zLm11bHRpKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICd0eXBlJywgdGhpcy5fb3B0aW9ucy50eXBlKTtcbiAgICByZWFkT25seVByb3BlcnR5KHRoaXMsICdhbGxvd1NlbGZMb29wcycsIHRoaXMuX29wdGlvbnMuYWxsb3dTZWxmTG9vcHMpO1xuICAgIHJlYWRPbmx5UHJvcGVydHkodGhpcywgJ2ltcGxlbWVudGF0aW9uJywgKCkgPT4gJ2dyYXBob2xvZ3knKTtcbiAgfVxuXG4gIF9yZXNldEluc3RhbmNlQ291bnRlcnMoKSB7XG4gICAgdGhpcy5fZGlyZWN0ZWRTaXplID0gMDtcbiAgICB0aGlzLl91bmRpcmVjdGVkU2l6ZSA9IDA7XG4gICAgdGhpcy5fZGlyZWN0ZWRTZWxmTG9vcENvdW50ID0gMDtcbiAgICB0aGlzLl91bmRpcmVjdGVkU2VsZkxvb3BDb3VudCA9IDA7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogUmVhZFxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gbm9kZSBpcyBmb3VuZCBpbiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc05vZGUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlcy5oYXMoJycgKyBub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGRpcmVjdGVkIGVkZ2UgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICAgKi9cbiAgaGFzRGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgLy8gRWFybHkgdGVybWluYXRpb25cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlZGdlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgICByZXR1cm4gISFlZGdlRGF0YSAmJiAhZWRnZURhdGEudW5kaXJlY3RlZDtcbiAgICB9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICAgIC8vIElmIHRoZSBub2RlIHNvdXJjZSBvciB0aGUgdGFyZ2V0IGlzIG5vdCBpbiB0aGUgZ3JhcGggd2UgYnJlYWtcbiAgICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICAgIGlmICghbm9kZURhdGEpIHJldHVybiBmYWxzZTtcblxuICAgICAgLy8gSXMgdGhlcmUgYSBkaXJlY3RlZCBlZGdlIHBvaW50aW5nIHRvd2FyZCB0YXJnZXQ/XG4gICAgICByZXR1cm4gbm9kZURhdGEub3V0Lmhhc093blByb3BlcnR5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmhhc0RpcmVjdGVkRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiB1bmRpcmVjdGVkIGVkZ2UgaXMgZm91bmQgaW4gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBBcml0eSAxOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgIHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgYXJndW1lbnRzIGFyZSBpbnZhbGlkLlxuICAgKi9cbiAgaGFzVW5kaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICAvLyBFYXJseSB0ZXJtaW5hdGlvblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBlZGdlID0gJycgKyBzb3VyY2U7XG5cbiAgICAgIGNvbnN0IGVkZ2VEYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgICByZXR1cm4gISFlZGdlRGF0YSAmJiBlZGdlRGF0YS51bmRpcmVjdGVkO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgc291cmNlIG9yIHRoZSB0YXJnZXQgaXMgbm90IGluIHRoZSBncmFwaCB3ZSBicmVha1xuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFub2RlRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJcyB0aGVyZSBhIGRpcmVjdGVkIGVkZ2UgcG9pbnRpbmcgdG93YXJkIHRhcmdldD9cbiAgICAgIHJldHVybiBub2RlRGF0YS51bmRpcmVjdGVkLmhhc093blByb3BlcnR5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLmhhc0RpcmVjdGVkRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHRoZSBnaXZlbiBlZGdlIGlzIGZvdW5kIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKlxuICAgKiBBcml0eSAyOlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGFyZ3VtZW50cyBhcmUgaW52YWxpZC5cbiAgICovXG4gIGhhc0VkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgZWRnZSA9ICcnICsgc291cmNlO1xuXG4gICAgICByZXR1cm4gdGhpcy5fZWRnZXMuaGFzKGVkZ2UpO1xuICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgICB0YXJnZXQgPSAnJyArIHRhcmdldDtcblxuICAgICAgLy8gSWYgdGhlIG5vZGUgc291cmNlIG9yIHRoZSB0YXJnZXQgaXMgbm90IGluIHRoZSBncmFwaCB3ZSBicmVha1xuICAgICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQoc291cmNlKTtcblxuICAgICAgaWYgKCFub2RlRGF0YSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBJcyB0aGVyZSBhIGRpcmVjdGVkIGVkZ2UgcG9pbnRpbmcgdG93YXJkIHRhcmdldD9cbiAgICAgIHJldHVybiAoXG4gICAgICAgICh0eXBlb2Ygbm9kZURhdGEub3V0ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgIG5vZGVEYXRhLm91dC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpKSB8fFxuICAgICAgICAodHlwZW9mIG5vZGVEYXRhLnVuZGlyZWN0ZWQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgbm9kZURhdGEudW5kaXJlY3RlZC5oYXNPd25Qcm9wZXJ0eSh0YXJnZXQpKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICBgR3JhcGguaGFzRWRnZTogaW52YWxpZCBhcml0eSAoJHthcmd1bWVudHMubGVuZ3RofSwgaW5zdGVhZCBvZiAxIG9yIDIpLiBZb3UgY2FuIGVpdGhlciBhc2sgZm9yIGFuIGVkZ2UgaWQgb3IgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYW4gZWRnZSBiZXR3ZWVuIGEgc291cmNlICYgYSB0YXJnZXQuYFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZWRnZSBtYXRjaGluZyBzb3VyY2UgJiB0YXJnZXQgaW4gYSBkaXJlY3RlZCBmYXNoaW9uLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9IHNvdXJjZSAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKiBAcGFyYW0gIHthbnl9IHRhcmdldCAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAcmV0dXJuIHthbnl8dW5kZWZpbmVkfVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBncmFwaCBpcyBtdWx0aS5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBzb3VyY2Ugb3IgdGFyZ2V0IGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkaXJlY3RlZEVkZ2Uoc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybjtcblxuICAgIHNvdXJjZSA9ICcnICsgc291cmNlO1xuICAgIHRhcmdldCA9ICcnICsgdGFyZ2V0O1xuXG4gICAgaWYgKHRoaXMubXVsdGkpXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZGlyZWN0ZWRFZGdlOiB0aGlzIG1ldGhvZCBpcyBpcnJlbGV2YW50IHdpdGggbXVsdGlncmFwaHMgc2luY2UgdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgZWRnZXMgYmV0d2VlbiBzb3VyY2UgJiB0YXJnZXQuIFNlZSAjLmRpcmVjdGVkRWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHt0YXJnZXR9XCIgdGFyZ2V0IG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IChzb3VyY2VEYXRhLm91dCAmJiBzb3VyY2VEYXRhLm91dFt0YXJnZXRdKSB8fCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoZWRnZURhdGEpIHJldHVybiBlZGdlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZWRnZSBtYXRjaGluZyBzb3VyY2UgJiB0YXJnZXQgaW4gYSB1bmRpcmVjdGVkIGZhc2hpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gc291cmNlIC0gVGhlIGVkZ2UncyBzb3VyY2UuXG4gICAqIEBwYXJhbSAge2FueX0gdGFyZ2V0IC0gVGhlIGVkZ2UncyB0YXJnZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge2FueXx1bmRlZmluZWR9XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdyYXBoIGlzIG11bHRpLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHNvdXJjZSBvciB0YXJnZXQgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHVuZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBpZiAodGhpcy5tdWx0aSlcbiAgICAgIHRocm93IG5ldyBVc2FnZUdyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51bmRpcmVjdGVkRWRnZTogdGhpcyBtZXRob2QgaXMgaXJyZWxldmFudCB3aXRoIG11bHRpZ3JhcGhzIHNpbmNlIHRoZXJlIG1pZ2h0IGJlIG11bHRpcGxlIGVkZ2VzIGJldHdlZW4gc291cmNlICYgdGFyZ2V0LiBTZWUgIy51bmRpcmVjdGVkRWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgY29uc3Qgc291cmNlRGF0YSA9IHRoaXMuX25vZGVzLmdldChzb3VyY2UpO1xuXG4gICAgaWYgKCFzb3VyY2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke3NvdXJjZX1cIiBzb3VyY2Ugbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICghdGhpcy5fbm9kZXMuaGFzKHRhcmdldCkpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPVxuICAgICAgKHNvdXJjZURhdGEudW5kaXJlY3RlZCAmJiBzb3VyY2VEYXRhLnVuZGlyZWN0ZWRbdGFyZ2V0XSkgfHwgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGVkZ2UgbWF0Y2hpbmcgc291cmNlICYgdGFyZ2V0IGluIGEgbWl4ZWQgZmFzaGlvbi5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBzb3VyY2UgLSBUaGUgZWRnZSdzIHNvdXJjZS5cbiAgICogQHBhcmFtICB7YW55fSB0YXJnZXQgLSBUaGUgZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHJldHVybiB7YW55fHVuZGVmaW5lZH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ3JhcGggaXMgbXVsdGkuXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgc291cmNlIG9yIHRhcmdldCBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZWRnZShzb3VyY2UsIHRhcmdldCkge1xuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmVkZ2U6IHRoaXMgbWV0aG9kIGlzIGlycmVsZXZhbnQgd2l0aCBtdWx0aWdyYXBocyBzaW5jZSB0aGVyZSBtaWdodCBiZSBtdWx0aXBsZSBlZGdlcyBiZXR3ZWVuIHNvdXJjZSAmIHRhcmdldC4gU2VlICMuZWRnZXMgaW5zdGVhZC4nXG4gICAgICApO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBjb25zdCBzb3VyY2VEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KHNvdXJjZSk7XG5cbiAgICBpZiAoIXNvdXJjZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZWRnZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtzb3VyY2V9XCIgc291cmNlIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAoIXRoaXMuX25vZGVzLmhhcyh0YXJnZXQpKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7dGFyZ2V0fVwiIHRhcmdldCBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgY29uc3QgZWRnZURhdGEgPVxuICAgICAgKHNvdXJjZURhdGEub3V0ICYmIHNvdXJjZURhdGEub3V0W3RhcmdldF0pIHx8XG4gICAgICAoc291cmNlRGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZURhdGEudW5kaXJlY3RlZFt0YXJnZXRdKSB8fFxuICAgICAgdW5kZWZpbmVkO1xuXG4gICAgaWYgKGVkZ2VEYXRhKSByZXR1cm4gZWRnZURhdGEua2V5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIGRpcmVjdGVkIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlRGlyZWN0ZWROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVEaXJlY3RlZE5laWdoYm9yczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS5pbiB8fCBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQ7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgb3V0IG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlT3V0TmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlT3V0TmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgcmV0dXJuIG5laWdoYm9yIGluIG5vZGVEYXRhLm91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBpbiBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZUluTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlSW5OZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ3VuZGlyZWN0ZWQnKSByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gbmVpZ2hib3IgaW4gbm9kZURhdGEuaW47XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgdW5kaXJlY3RlZCBuZWlnaGJvcnMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgICAgIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5laWdoYm9yIC0gVGhlIG5laWdoYm9yJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGFyZVVuZGlyZWN0ZWROZWlnaGJvcnMobm9kZSwgbmVpZ2hib3IpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIG5laWdoYm9yID0gJycgKyBuZWlnaGJvcjtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5hcmVVbmRpcmVjdGVkTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICdkaXJlY3RlZCcpIHJldHVybiBmYWxzZTtcblxuICAgIHJldHVybiBuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0d28gbm9kZXMgYXJlIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlTmVpZ2hib3JzKG5vZGUsIG5laWdoYm9yKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcbiAgICBuZWlnaGJvciA9ICcnICsgbmVpZ2hib3I7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguYXJlTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLmluIHx8IG5laWdoYm9yIGluIG5vZGVEYXRhLm91dCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdHdvIG5vZGVzIGFyZSBpbmJvdW5kIG5laWdoYm9ycy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAgICAgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHBhcmFtICB7YW55fSAgICAgbmVpZ2hib3IgLSBUaGUgbmVpZ2hib3IncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgYXJlSW5ib3VuZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZUluYm91bmROZWlnaGJvcnM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBpZiAobmVpZ2hib3IgaW4gbm9kZURhdGEuaW4pIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGlmIChuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIHR3byBub2RlcyBhcmUgb3V0Ym91bmQgbmVpZ2hib3JzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlICAgICAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBuZWlnaGJvciAtIFRoZSBuZWlnaGJvcidzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBhcmVPdXRib3VuZE5laWdoYm9ycyhub2RlLCBuZWlnaGJvcikge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG4gICAgbmVpZ2hib3IgPSAnJyArIG5laWdoYm9yO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmFyZU91dGJvdW5kTmVpZ2hib3JzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLm91dCkgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgaWYgKG5laWdoYm9yIGluIG5vZGVEYXRhLnVuZGlyZWN0ZWQpIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbkRlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbkRlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXREZWdyZWUobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgub3V0RGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEub3V0RGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW4gZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRpcmVjdGVkRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWU7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIHVuZGlyZWN0ZWQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICB1bmRpcmVjdGVkRGVncmVlKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLnVuZGlyZWN0ZWREZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgaW5ib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgaW5ib3VuZCBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5ib3VuZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbmJvdW5kRGVncmVlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZ3JlZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIG91dGJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBvdXRib3VuZERlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXRib3VuZERlZ3JlZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBkaXJlY3RlZCBkZWdyZWUuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3MgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGRlZ3JlZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kZWdyZWU6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5pbkRlZ3JlZSArIG5vZGVEYXRhLm91dERlZ3JlZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBpbiBkZWdyZWUgd2l0aG91dCBjb25zaWRlcmluZyBzZWxmIGxvb3BzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge251bWJlcn0gICAgICAgLSBUaGUgbm9kZSdzIGluIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbkRlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaW5EZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEuaW5EZWdyZWUgLSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdpdmVuIG5vZGUncyBvdXQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgb3V0RGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXREZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEub3V0RGVncmVlIC0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGlyZWN0ZWREZWdyZWVXaXRob3V0U2VsZkxvb3BzKG5vZGUpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuXG4gICAgY29uc3Qgbm9kZURhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoIW5vZGVEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRpcmVjdGVkRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBpZiAodGhpcy50eXBlID09PSAndW5kaXJlY3RlZCcpIHJldHVybiAwO1xuXG4gICAgcmV0dXJuIG5vZGVEYXRhLmluRGVncmVlICsgbm9kZURhdGEub3V0RGVncmVlIC0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcyAqIDI7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIHVuZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbiBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgdW5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHMobm9kZSkge1xuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICBjb25zdCBub2RlRGF0YSA9IHRoaXMuX25vZGVzLmdldChub2RlKTtcblxuICAgIGlmICghbm9kZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudW5kaXJlY3RlZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ2RpcmVjdGVkJykgcmV0dXJuIDA7XG5cbiAgICByZXR1cm4gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZSAtIG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIGluYm91bmQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBpbmJvdW5kIGRlZ3JlZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgbm9kZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpbmJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pbmJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wczogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZGVncmVlID0gMDtcbiAgICBsZXQgbG9vcHMgPSAwO1xuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS51bmRpcmVjdGVkTG9vcHMgKiAyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZGVncmVlICs9IG5vZGVEYXRhLmluRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEuZGlyZWN0ZWRMb29wcztcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlIC0gbG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gbm9kZSdzIG91dGJvdW5kIGRlZ3JlZSB3aXRob3V0IGNvbnNpZGVyaW5nIHNlbGYgbG9vcHMuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIG5vZGUgLSBUaGUgbm9kZSdzIGtleS5cbiAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAtIFRoZSBub2RlJ3Mgb3V0Ym91bmQgZGVncmVlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIG91dGJvdW5kRGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5vdXRib3VuZERlZ3JlZVdpdGhvdXRTZWxmTG9vcHM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7bm9kZX1cIiBub2RlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgbGV0IGRlZ3JlZSA9IDA7XG4gICAgbGV0IGxvb3BzID0gMDtcblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICdkaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS51bmRpcmVjdGVkRGVncmVlO1xuICAgICAgbG9vcHMgKz0gbm9kZURhdGEudW5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAndW5kaXJlY3RlZCcpIHtcbiAgICAgIGRlZ3JlZSArPSBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS5kaXJlY3RlZExvb3BzO1xuICAgIH1cblxuICAgIHJldHVybiBkZWdyZWUgLSBsb29wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBnaXZlbiBub2RlJ3MgZGlyZWN0ZWQgZGVncmVlIHdpdGhvdXQgY29uc2lkZXJpbmcgc2VsZiBsb29wcy5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgbm9kZSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9ICAgICAgIC0gVGhlIG5vZGUncyBkZWdyZWUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIG5vZGUgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZGVncmVlV2l0aG91dFNlbGZMb29wcyhub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kZWdyZWVXaXRob3V0U2VsZkxvb3BzOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke25vZGV9XCIgbm9kZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGxldCBkZWdyZWUgPSAwO1xuICAgIGxldCBsb29wcyA9IDA7XG5cbiAgICBpZiAodGhpcy50eXBlICE9PSAnZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEudW5kaXJlY3RlZERlZ3JlZTtcbiAgICAgIGxvb3BzICs9IG5vZGVEYXRhLnVuZGlyZWN0ZWRMb29wcyAqIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKSB7XG4gICAgICBkZWdyZWUgKz0gbm9kZURhdGEuaW5EZWdyZWUgKyBub2RlRGF0YS5vdXREZWdyZWU7XG4gICAgICBsb29wcyArPSBub2RlRGF0YS5kaXJlY3RlZExvb3BzICogMjtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVncmVlIC0gbG9vcHM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIHNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAtIFRoZSBlZGdlJ3Mgc291cmNlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHNvdXJjZShlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguc291cmNlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnNvdXJjZS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIHRhcmdldC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAtIFRoZSBlZGdlJ3MgdGFyZ2V0LlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIHRhcmdldChlZGdlKSB7XG4gICAgZWRnZSA9ICcnICsgZWRnZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudGFyZ2V0OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnRhcmdldC5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ2l2ZW4gZWRnZSdzIGV4dHJlbWl0aWVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHthcnJheX0gICAgICAtIFRoZSBlZGdlJ3MgZXh0cmVtaXRpZXMuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgZXh0cmVtaXRpZXMoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZXh0cmVtaXRpZXM6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIFtlZGdlRGF0YS5zb3VyY2Uua2V5LCBlZGdlRGF0YS50YXJnZXQua2V5XTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG5vZGUgJiBhbiBlZGdlLCByZXR1cm5zIHRoZSBvdGhlciBleHRyZW1pdHkgb2YgdGhlIGVkZ2UuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEBwYXJhbSAge2FueX0gICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgIC0gVGhlIHJlbGF0ZWQgbm9kZS5cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGggb3IgaWYgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgIGVkZ2UgJiBub2RlIGFyZSBub3QgcmVsYXRlZC5cbiAgICovXG4gIG9wcG9zaXRlKG5vZGUsIGVkZ2UpIHtcbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLm9wcG9zaXRlOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGNvbnN0IHNvdXJjZSA9IGRhdGEuc291cmNlLmtleTtcbiAgICBjb25zdCB0YXJnZXQgPSBkYXRhLnRhcmdldC5rZXk7XG5cbiAgICBpZiAobm9kZSA9PT0gc291cmNlKSByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChub2RlID09PSB0YXJnZXQpIHJldHVybiBzb3VyY2U7XG5cbiAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgYEdyYXBoLm9wcG9zaXRlOiB0aGUgXCIke25vZGV9XCIgbm9kZSBpcyBub3QgYXR0YWNoZWQgdG8gdGhlIFwiJHtlZGdlfVwiIGVkZ2UgKCR7c291cmNlfSwgJHt0YXJnZXR9KS5gXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaGFzIHRoZSBnaXZlbiBub2RlIGFzIGV4dHJlbWl0eS5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBub2RlIC0gVGhlIG5vZGUncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59ICAgICAgLSBUaGUgcmVsYXRlZCBub2RlLlxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIGVpdGhlciB0aGUgbm9kZSBvciB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBoYXNFeHRyZW1pdHkoZWRnZSwgbm9kZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IGRhdGEgPSB0aGlzLl9lZGdlcy5nZXQoZWRnZSk7XG5cbiAgICBpZiAoIWRhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguaGFzRXh0cmVtaXR5OiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiBkYXRhLnNvdXJjZS5rZXkgPT09IG5vZGUgfHwgZGF0YS50YXJnZXQua2V5ID09PSBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyB1bmRpcmVjdGVkLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICBlZGdlIC0gVGhlIGVkZ2UncyBrZXkuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGVkZ2UgaXNuJ3QgaW4gdGhlIGdyYXBoLlxuICAgKi9cbiAgaXNVbmRpcmVjdGVkKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pc1VuZGlyZWN0ZWQ6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEudW5kaXJlY3RlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHdoZXRoZXIgdGhlIGdpdmVuIGVkZ2UgaXMgZGlyZWN0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgIGVkZ2UgLSBUaGUgZWRnZSdzIGtleS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBpc24ndCBpbiB0aGUgZ3JhcGguXG4gICAqL1xuICBpc0RpcmVjdGVkKGVkZ2UpIHtcbiAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgY29uc3QgZGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgIGlmICghZGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5pc0RpcmVjdGVkOiBjb3VsZCBub3QgZmluZCB0aGUgXCIke2VkZ2V9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIHJldHVybiAhZGF0YS51bmRpcmVjdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ2l2ZW4gZWRnZSBpcyBhIHNlbGYgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICAgZWRnZSAtIFRoZSBlZGdlJ3Mga2V5LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGlzbid0IGluIHRoZSBncmFwaC5cbiAgICovXG4gIGlzU2VsZkxvb3AoZWRnZSkge1xuICAgIGVkZ2UgPSAnJyArIGVkZ2U7XG5cbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZWRnZXMuZ2V0KGVkZ2UpO1xuXG4gICAgaWYgKCFkYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmlzU2VsZkxvb3A6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgcmV0dXJuIGRhdGEuc291cmNlID09PSBkYXRhLnRhcmdldDtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBNdXRhdGlvblxuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGFkZCBhIG5vZGUgdG8gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIG5vZGUgICAgICAgICAtIFRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFdpbGwgdGhyb3cgaWYgdGhlIGdpdmVuIG5vZGUgYWxyZWFkeSBleGlzdC5cbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZ2l2ZW4gYXR0cmlidXRlcyBhcmUgbm90IGFuIG9iamVjdC5cbiAgICovXG4gIGFkZE5vZGUobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gYWRkTm9kZSh0aGlzLCBub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAgIHJldHVybiBub2RlRGF0YS5rZXk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gbWVyZ2UgYSBub2RlIGludG8gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIG5vZGUgICAgICAgICAtIFRoZSBub2RlLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IFthdHRyaWJ1dGVzXSAtIE9wdGlvbmFsIGF0dHJpYnV0ZXMuXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgIC0gVGhlIG5vZGUuXG4gICAqL1xuICBtZXJnZU5vZGUobm9kZSwgYXR0cmlidXRlcykge1xuICAgIGlmIChhdHRyaWJ1dGVzICYmICFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgubWVyZ2VOb2RlOiBpbnZhbGlkIGF0dHJpYnV0ZXMuIEV4cGVjdGluZyBhbiBvYmplY3QgYnV0IGdvdCBcIiR7YXR0cmlidXRlc31cImBcbiAgICAgICk7XG5cbiAgICAvLyBTdHJpbmcgY29lcmNpb25cbiAgICBub2RlID0gJycgKyBub2RlO1xuICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgLy8gSWYgdGhlIG5vZGUgYWxyZWFkeSBleGlzdHMsIHdlIG1lcmdlIHRoZSBhdHRyaWJ1dGVzXG4gICAgbGV0IGRhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXNzaWduKGRhdGEuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAgICAgdGhpcy5lbWl0KCdub2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICAgICAgdHlwZTogJ21lcmdlJyxcbiAgICAgICAgICBrZXk6IG5vZGUsXG4gICAgICAgICAgYXR0cmlidXRlczogZGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25vZGUsIGZhbHNlXTtcbiAgICB9XG5cbiAgICBkYXRhID0gbmV3IHRoaXMuTm9kZURhdGFDbGFzcyhub2RlLCBhdHRyaWJ1dGVzKTtcblxuICAgIC8vIEFkZGluZyB0aGUgbm9kZSB0byBpbnRlcm5hbCByZWdpc3RlclxuICAgIHRoaXMuX25vZGVzLnNldChub2RlLCBkYXRhKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdub2RlQWRkZWQnLCB7XG4gICAgICBrZXk6IG5vZGUsXG4gICAgICBhdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gW25vZGUsIHRydWVdO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGFkZCBhIG5vZGUgaWYgaXQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGdyYXBoIG9yIGVsc2UgdG9cbiAgICogdXBkYXRlIGl0cyBhdHRyaWJ1dGVzIHVzaW5nIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgICBub2RlICAgICAgLSBUaGUgbm9kZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IFt1cGRhdGVyXSAtIE9wdGlvbmFsIHVwZGF0ZXIgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge2FueX0gICAgICAgICAgICAgICAgLSBUaGUgbm9kZS5cbiAgICovXG4gIHVwZGF0ZU5vZGUobm9kZSwgdXBkYXRlcikge1xuICAgIGlmICh1cGRhdGVyICYmIHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGgudXBkYXRlTm9kZTogaW52YWxpZCB1cGRhdGVyIGZ1bmN0aW9uLiBFeHBlY3RpbmcgYSBmdW5jdGlvbiBidXQgZ290IFwiJHt1cGRhdGVyfVwiYFxuICAgICAgKTtcblxuICAgIC8vIFN0cmluZyBjb2VyY2lvblxuICAgIG5vZGUgPSAnJyArIG5vZGU7XG5cbiAgICAvLyBJZiB0aGUgbm9kZSBhbHJlYWR5IGV4aXN0cywgd2UgdXBkYXRlIHRoZSBhdHRyaWJ1dGVzXG4gICAgbGV0IGRhdGEgPSB0aGlzLl9ub2Rlcy5nZXQobm9kZSk7XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgaWYgKHVwZGF0ZXIpIHtcbiAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IGRhdGEuYXR0cmlidXRlcztcbiAgICAgICAgZGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihvbGRBdHRyaWJ1dGVzKTtcblxuICAgICAgICB0aGlzLmVtaXQoJ25vZGVBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICAgICAga2V5OiBub2RlLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IGRhdGEuYXR0cmlidXRlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbm9kZSwgZmFsc2VdO1xuICAgIH1cblxuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB1cGRhdGVyID8gdXBkYXRlcih7fSkgOiB7fTtcblxuICAgIGRhdGEgPSBuZXcgdGhpcy5Ob2RlRGF0YUNsYXNzKG5vZGUsIGF0dHJpYnV0ZXMpO1xuXG4gICAgLy8gQWRkaW5nIHRoZSBub2RlIHRvIGludGVybmFsIHJlZ2lzdGVyXG4gICAgdGhpcy5fbm9kZXMuc2V0KG5vZGUsIGRhdGEpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVBZGRlZCcsIHtcbiAgICAgIGtleTogbm9kZSxcbiAgICAgIGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiBbbm9kZSwgdHJ1ZV07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZHJvcCBhIHNpbmdsZSBub2RlICYgYWxsIGl0cyBhdHRhY2hlZCBlZGdlcyBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQHBhcmFtICB7YW55fSAgICBub2RlIC0gVGhlIG5vZGUuXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBub2RlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wTm9kZShub2RlKSB7XG4gICAgbm9kZSA9ICcnICsgbm9kZTtcblxuICAgIGNvbnN0IG5vZGVEYXRhID0gdGhpcy5fbm9kZXMuZ2V0KG5vZGUpO1xuXG4gICAgaWYgKCFub2RlRGF0YSlcbiAgICAgIHRocm93IG5ldyBOb3RGb3VuZEdyYXBoRXJyb3IoXG4gICAgICAgIGBHcmFwaC5kcm9wTm9kZTogY291bGQgbm90IGZpbmQgdGhlIFwiJHtub2RlfVwiIG5vZGUgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBsZXQgZWRnZURhdGE7XG5cbiAgICAvLyBSZW1vdmluZyBhdHRhY2hlZCBlZGdlc1xuICAgIC8vIE5PVEU6IHdlIGNvdWxkIGJlIGZhc3RlciBoZXJlLCBidXQgdGhpcyBpcyBzdWNoIGEgcGFpbiB0byBtYWludGFpblxuICAgIGlmICh0aGlzLnR5cGUgIT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS5vdXQpIHtcbiAgICAgICAgZWRnZURhdGEgPSBub2RlRGF0YS5vdXRbbmVpZ2hib3JdO1xuXG4gICAgICAgIGRvIHtcbiAgICAgICAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcbiAgICAgICAgICBlZGdlRGF0YSA9IGVkZ2VEYXRhLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKGVkZ2VEYXRhKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS5pbikge1xuICAgICAgICBlZGdlRGF0YSA9IG5vZGVEYXRhLmluW25laWdoYm9yXTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG4gICAgICAgICAgZWRnZURhdGEgPSBlZGdlRGF0YS5uZXh0O1xuICAgICAgICB9IHdoaWxlIChlZGdlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ2RpcmVjdGVkJykge1xuICAgICAgZm9yIChjb25zdCBuZWlnaGJvciBpbiBub2RlRGF0YS51bmRpcmVjdGVkKSB7XG4gICAgICAgIGVkZ2VEYXRhID0gbm9kZURhdGEudW5kaXJlY3RlZFtuZWlnaGJvcl07XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGRyb3BFZGdlRnJvbURhdGEodGhpcywgZWRnZURhdGEpO1xuICAgICAgICAgIGVkZ2VEYXRhID0gZWRnZURhdGEubmV4dDtcbiAgICAgICAgfSB3aGlsZSAoZWRnZURhdGEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERyb3BwaW5nIHRoZSBub2RlIGZyb20gdGhlIHJlZ2lzdGVyXG4gICAgdGhpcy5fbm9kZXMuZGVsZXRlKG5vZGUpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ25vZGVEcm9wcGVkJywge1xuICAgICAga2V5OiBub2RlLFxuICAgICAgYXR0cmlidXRlczogbm9kZURhdGEuYXR0cmlidXRlc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgZWRnZSBmcm9tIHRoZSBncmFwaC5cbiAgICpcbiAgICogQXJpdHkgMTpcbiAgICogQHBhcmFtICB7YW55fSAgICBlZGdlIC0gVGhlIGVkZ2UuXG4gICAqXG4gICAqIEFyaXR5IDI6XG4gICAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wRWRnZShlZGdlKSB7XG4gICAgbGV0IGVkZ2VEYXRhO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBzb3VyY2UgPSAnJyArIGFyZ3VtZW50c1swXTtcbiAgICAgIGNvbnN0IHRhcmdldCA9ICcnICsgYXJndW1lbnRzWzFdO1xuXG4gICAgICBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgdGhpcy50eXBlKTtcblxuICAgICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguZHJvcEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7c291cmNlfVwiIC0+IFwiJHt0YXJnZXR9XCIgZWRnZSBpbiB0aGUgZ3JhcGguYFxuICAgICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGdlID0gJycgKyBlZGdlO1xuXG4gICAgICBlZGdlRGF0YSA9IHRoaXMuX2VkZ2VzLmdldChlZGdlKTtcblxuICAgICAgaWYgKCFlZGdlRGF0YSlcbiAgICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgICBgR3JhcGguZHJvcEVkZ2U6IGNvdWxkIG5vdCBmaW5kIHRoZSBcIiR7ZWRnZX1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byBkcm9wIGEgc2luZ2xlIGRpcmVjdGVkIGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge2FueX0gICAgc291cmNlIC0gU291cmNlIG5vZGUuXG4gICAqIEBwYXJhbSAge2FueX0gICAgdGFyZ2V0IC0gVGFyZ2V0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBXaWxsIHRocm93IGlmIHRoZSBlZGdlIGRvZXNuJ3QgZXhpc3QuXG4gICAqL1xuICBkcm9wRGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGl0IGRvZXMgbm90IG1ha2Ugc2Vuc2UgdG8gdHJ5IGFuZCBkcm9wIGEgZGlyZWN0ZWQgZWRnZSBieSBrZXkuIFdoYXQgaWYgdGhlIGVkZ2Ugd2l0aCB0aGlzIGtleSBpcyB1bmRpcmVjdGVkPyBVc2UgIy5kcm9wRWRnZSBmb3IgdGhpcyBwdXJwb3NlIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNhbm5vdCB1c2UgYSB7c291cmNlLHRhcmdldH0gY29tYm8gd2hlbiBkcm9wcGluZyBhbiBlZGdlIGluIGEgTXVsdGlHcmFwaCBzaW5jZSB3ZSBjYW5ub3QgaW5mZXIgdGhlIG9uZSB5b3Ugd2FudCB0byBkZWxldGUgYXMgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgb25lcy4nXG4gICAgICApO1xuXG4gICAgc291cmNlID0gJycgKyBzb3VyY2U7XG4gICAgdGFyZ2V0ID0gJycgKyB0YXJnZXQ7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgJ2RpcmVjdGVkJyk7XG5cbiAgICBpZiAoIWVkZ2VEYXRhKVxuICAgICAgdGhyb3cgbmV3IE5vdEZvdW5kR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmRyb3BEaXJlY3RlZEVkZ2U6IGNvdWxkIG5vdCBmaW5kIGEgXCIke3NvdXJjZX1cIiAtPiBcIiR7dGFyZ2V0fVwiIGVkZ2UgaW4gdGhlIGdyYXBoLmBcbiAgICAgICk7XG5cbiAgICBkcm9wRWRnZUZyb21EYXRhKHRoaXMsIGVkZ2VEYXRhKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGRyb3AgYSBzaW5nbGUgdW5kaXJlY3RlZCBlZGdlIGZyb20gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHNvdXJjZSAtIFNvdXJjZSBub2RlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgIHRhcmdldCAtIFRhcmdldCBub2RlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiB0aGUgZWRnZSBkb2Vzbid0IGV4aXN0LlxuICAgKi9cbiAgZHJvcFVuZGlyZWN0ZWRFZGdlKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BVbmRpcmVjdGVkRWRnZTogaXQgZG9lcyBub3QgbWFrZSBzZW5zZSB0byBkcm9wIGEgZGlyZWN0ZWQgZWRnZSBieSBrZXkuIFdoYXQgaWYgdGhlIGVkZ2Ugd2l0aCB0aGlzIGtleSBpcyB1bmRpcmVjdGVkPyBVc2UgIy5kcm9wRWRnZSBmb3IgdGhpcyBwdXJwb3NlIGluc3RlYWQuJ1xuICAgICAgKTtcblxuICAgIGlmICh0aGlzLm11bHRpKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmRyb3BVbmRpcmVjdGVkRWRnZTogY2Fubm90IHVzZSBhIHtzb3VyY2UsdGFyZ2V0fSBjb21ibyB3aGVuIGRyb3BwaW5nIGFuIGVkZ2UgaW4gYSBNdWx0aUdyYXBoIHNpbmNlIHdlIGNhbm5vdCBpbmZlciB0aGUgb25lIHlvdSB3YW50IHRvIGRlbGV0ZSBhcyB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBvbmVzLidcbiAgICAgICk7XG5cbiAgICBjb25zdCBlZGdlRGF0YSA9IGdldE1hdGNoaW5nRWRnZSh0aGlzLCBzb3VyY2UsIHRhcmdldCwgJ3VuZGlyZWN0ZWQnKTtcblxuICAgIGlmICghZWRnZURhdGEpXG4gICAgICB0aHJvdyBuZXcgTm90Rm91bmRHcmFwaEVycm9yKFxuICAgICAgICBgR3JhcGguZHJvcFVuZGlyZWN0ZWRFZGdlOiBjb3VsZCBub3QgZmluZCBhIFwiJHtzb3VyY2V9XCIgLT4gXCIke3RhcmdldH1cIiBlZGdlIGluIHRoZSBncmFwaC5gXG4gICAgICApO1xuXG4gICAgZHJvcEVkZ2VGcm9tRGF0YSh0aGlzLCBlZGdlRGF0YSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byByZW1vdmUgZXZlcnkgZWRnZSAmIGV2ZXJ5IG5vZGUgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgLy8gQ2xlYXJpbmcgZWRnZXNcbiAgICB0aGlzLl9lZGdlcy5jbGVhcigpO1xuXG4gICAgLy8gQ2xlYXJpbmcgbm9kZXNcbiAgICB0aGlzLl9ub2Rlcy5jbGVhcigpO1xuXG4gICAgLy8gUmVzZXQgY291bnRlcnNcbiAgICB0aGlzLl9yZXNldEluc3RhbmNlQ291bnRlcnMoKTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdjbGVhcmVkJyk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gcmVtb3ZlIGV2ZXJ5IGVkZ2UgZnJvbSB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEByZXR1cm4ge0dyYXBofVxuICAgKi9cbiAgY2xlYXJFZGdlcygpIHtcbiAgICAvLyBDbGVhcmluZyBzdHJ1Y3R1cmUgaW5kZXhcbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX25vZGVzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXA7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgc3RlcC52YWx1ZS5jbGVhcigpO1xuICAgIH1cblxuICAgIC8vIENsZWFyaW5nIGVkZ2VzXG4gICAgdGhpcy5fZWRnZXMuY2xlYXIoKTtcblxuICAgIC8vIFJlc2V0IGNvdW50ZXJzXG4gICAgdGhpcy5fcmVzZXRJbnN0YW5jZUNvdW50ZXJzKCk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnZWRnZXNDbGVhcmVkJyk7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQXR0cmlidXRlcy1yZWxhdGVkIG1ldGhvZHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIGdldEF0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiB0aGlzLl9hdHRyaWJ1dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciB0aGUgZ3JhcGggaGFzIHRoZSBkZXNpcmVkIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHBhcmFtICB7c3RyaW5nfSAgbmFtZSAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0F0dHJpYnV0ZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkobmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHNldHRpbmcgYSB2YWx1ZSBmb3IgdGhlIGRlc2lyZWQgZ3JhcGgncyBhdHRyaWJ1dGUuXG4gICAqXG4gICAqIEBwYXJhbSAge3N0cmluZ30gIG5hbWUgIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcGFyYW0gIHthbnl9ICAgICB2YWx1ZSAtIFZhbHVlIGZvciB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblxuICAgIC8vIEVtaXR0aW5nXG4gICAgdGhpcy5lbWl0KCdhdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIHR5cGU6ICdzZXQnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIG5hbWVcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2luZyBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSB0aGUgZGVzaXJlZCBncmFwaCdzIGF0dHJpYnV0ZSdzIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9ICAgbmFtZSAgICAtIE5hbWUgb2YgdGhlIGF0dHJpYnV0ZS5cbiAgICogQHBhcmFtICB7ZnVuY3Rpb259IHVwZGF0ZXIgLSBGdW5jdGlvbiB1c2UgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGUncyB2YWx1ZS5cbiAgICogQHJldHVybiB7R3JhcGh9XG4gICAqL1xuICB1cGRhdGVBdHRyaWJ1dGUobmFtZSwgdXBkYXRlcikge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUF0dHJpYnV0ZTogdXBkYXRlciBzaG91bGQgYmUgYSBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHVwZGF0ZXIodmFsdWUpO1xuXG4gICAgLy8gRW1pdHRpbmdcbiAgICB0aGlzLmVtaXQoJ2F0dHJpYnV0ZXNVcGRhdGVkJywge1xuICAgICAgdHlwZTogJ3NldCcsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgbmFtZVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJlbW92aW5nIHRoZSBkZXNpcmVkIGdyYXBoJ3MgYXR0cmlidXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtzdHJpbmd9IG5hbWUgIC0gTmFtZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgZGVsZXRlIHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAncmVtb3ZlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXMsXG4gICAgICBuYW1lXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmVwbGFjaW5nIHRoZSBncmFwaCdzIGF0dHJpYnV0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gYXR0cmlidXRlcyAtIE5ldyBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXG4gICAqL1xuICByZXBsYWNlQXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGF0dHJpYnV0ZXMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgucmVwbGFjZUF0dHJpYnV0ZXM6IHByb3ZpZGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCBhIHBsYWluIG9iamVjdC4nXG4gICAgICApO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAncmVwbGFjZScsXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzXG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgbWVyZ2luZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IGF0dHJpYnV0ZXMgLSBBdHRyaWJ1dGVzIHRvIG1lcmdlLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiBhdHRyaWJ1dGVzIGFyZSBub3QgYSBwbGFpbiBvYmplY3QuXG4gICAqL1xuICBtZXJnZUF0dHJpYnV0ZXMoYXR0cmlidXRlcykge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChhdHRyaWJ1dGVzKSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLm1lcmdlQXR0cmlidXRlczogcHJvdmlkZWQgYXR0cmlidXRlcyBhcmUgbm90IGEgcGxhaW4gb2JqZWN0LidcbiAgICAgICk7XG5cbiAgICBhc3NpZ24odGhpcy5fYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAnbWVyZ2UnLFxuICAgICAgYXR0cmlidXRlczogdGhpcy5fYXR0cmlidXRlcyxcbiAgICAgIGRhdGE6IGF0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1cGRhdGluZyB0aGUgZ3JhcGgncyBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIEZ1bmN0aW9uIHVzZWQgdG8gdXBkYXRlIHRoZSBhdHRyaWJ1dGVzLlxuICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IC0gV2lsbCB0aHJvdyBpZiBnaXZlbiB1cGRhdGVyIGlzIG5vdCBhIGZ1bmN0aW9uLlxuICAgKi9cbiAgdXBkYXRlQXR0cmlidXRlcyh1cGRhdGVyKSB7XG4gICAgaWYgKHR5cGVvZiB1cGRhdGVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlQXR0cmlidXRlczogcHJvdmlkZWQgdXBkYXRlciBpcyBub3QgYSBmdW5jdGlvbi4nXG4gICAgICApO1xuXG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IHVwZGF0ZXIodGhpcy5fYXR0cmlidXRlcyk7XG5cbiAgICAvLyBFbWl0dGluZ1xuICAgIHRoaXMuZW1pdCgnYXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICB0eXBlOiAndXBkYXRlJyxcbiAgICAgIGF0dHJpYnV0ZXM6IHRoaXMuX2F0dHJpYnV0ZXNcbiAgICB9KTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIHVwZGF0ZSBlYWNoIG5vZGUncyBhdHRyaWJ1dGVzIHVzaW5nIHRoZSBnaXZlbiBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gIHVwZGF0ZXIgLSBVcGRhdGVyIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICogQHBhcmFtIHtvYmplY3R9ICAgIFtoaW50c10gLSBPcHRpb25hbCBoaW50cy5cbiAgICovXG4gIHVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyh1cGRhdGVyLCBoaW50cykge1xuICAgIGlmICh0eXBlb2YgdXBkYXRlciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlczogZXhwZWN0aW5nIGFuIHVwZGF0ZXIgZnVuY3Rpb24uJ1xuICAgICAgKTtcblxuICAgIGlmIChoaW50cyAmJiAhdmFsaWRhdGVIaW50cyhoaW50cykpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoTm9kZUF0dHJpYnV0ZXM6IGludmFsaWQgaGludHMuIEV4cGVjdGluZyBhbiBvYmplY3QgaGF2aW5nIHRoZSBmb2xsb3dpbmcgc2hhcGU6IHthdHRyaWJ1dGVzPzogW3N0cmluZ119J1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgbm9kZURhdGEuYXR0cmlidXRlcyA9IHVwZGF0ZXIobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICB0aGlzLmVtaXQoJ2VhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWQnLCB7XG4gICAgICBoaW50czogaGludHMgPyBoaW50cyA6IG51bGxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCB0byB1cGRhdGUgZWFjaCBlZGdlJ3MgYXR0cmlidXRlcyB1c2luZyB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259ICB1cGRhdGVyIC0gVXBkYXRlciBmdW5jdGlvbiB0byB1c2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICBbaGludHNdIC0gT3B0aW9uYWwgaGludHMuXG4gICAqL1xuICB1cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXModXBkYXRlciwgaGludHMpIHtcbiAgICBpZiAodHlwZW9mIHVwZGF0ZXIgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC51cGRhdGVFYWNoRWRnZUF0dHJpYnV0ZXM6IGV4cGVjdGluZyBhbiB1cGRhdGVyIGZ1bmN0aW9uLidcbiAgICAgICk7XG5cbiAgICBpZiAoaGludHMgJiYgIXZhbGlkYXRlSGludHMoaGludHMpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgudXBkYXRlRWFjaEVkZ2VBdHRyaWJ1dGVzOiBpbnZhbGlkIGhpbnRzLiBFeHBlY3RpbmcgYW4gb2JqZWN0IGhhdmluZyB0aGUgZm9sbG93aW5nIHNoYXBlOiB7YXR0cmlidXRlcz86IFtzdHJpbmddfSdcbiAgICAgICk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2VkZ2VzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIGVkZ2VEYXRhLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIGVkZ2VEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIHNvdXJjZURhdGEgPSBlZGdlRGF0YS5zb3VyY2U7XG4gICAgICB0YXJnZXREYXRhID0gZWRnZURhdGEudGFyZ2V0O1xuXG4gICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzID0gdXBkYXRlcihcbiAgICAgICAgZWRnZURhdGEua2V5LFxuICAgICAgICBlZGdlRGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBzb3VyY2VEYXRhLmtleSxcbiAgICAgICAgdGFyZ2V0RGF0YS5rZXksXG4gICAgICAgIHNvdXJjZURhdGEuYXR0cmlidXRlcyxcbiAgICAgICAgdGFyZ2V0RGF0YS5hdHRyaWJ1dGVzLFxuICAgICAgICBlZGdlRGF0YS51bmRpcmVjdGVkXG4gICAgICApO1xuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZCcsIHtcbiAgICAgIGhpbnRzOiBoaW50cyA/IGhpbnRzIDogbnVsbFxuICAgIH0pO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEl0ZXJhdGlvbi1yZWxhdGVkIG1ldGhvZHNcbiAgICoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBNZXRob2QgaXRlcmF0aW5nIG92ZXIgdGhlIGdyYXBoJ3MgYWRqYWNlbmN5IHVzaW5nIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICovXG4gIGZvckVhY2hBZGphY2VuY3lFbnRyeShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQWRqYWNlbmN5RW50cnk6IGV4cGVjdGluZyBhIGNhbGxiYWNrLidcbiAgICAgICk7XG5cbiAgICBmb3JFYWNoQWRqYWNlbmN5KGZhbHNlLCBmYWxzZSwgZmFsc2UsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuICBmb3JFYWNoQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFucyhjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFuczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIGZhbHNlLCB0cnVlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBvdmVyIHRoZSBncmFwaCdzIGFzc3ltZXRyaWMgYWRqYWNlbmN5IHVzaW5nIHRoZSBnaXZlbiBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIHRvIHVzZS5cbiAgICovXG4gIGZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnkoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIHRydWUsIGZhbHNlLCB0aGlzLCBjYWxsYmFjayk7XG4gIH1cbiAgZm9yRWFjaEFzc3ltZXRyaWNBZGphY2VuY3lFbnRyeVdpdGhPcnBoYW5zKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZvckVhY2hBc3N5bWV0cmljQWRqYWNlbmN5RW50cnlXaXRoT3JwaGFuczogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGZvckVhY2hBZGphY2VuY3koZmFsc2UsIHRydWUsIHRydWUsIHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBsaXN0IG9mIHRoZSBncmFwaCdzIG5vZGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHthcnJheX0gLSBUaGUgbm9kZXMuXG4gICAqL1xuICBub2RlcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLl9ub2Rlcy5rZXlzKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBpdGVyYXRpbmcgb3ZlciB0aGUgZ3JhcGgncyBub2RlcyB1c2luZyB0aGUgZ2l2ZW4gY2FsbGJhY2suXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzLCBpbmRleCkuXG4gICAqL1xuICBmb3JFYWNoTm9kZShjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdHcmFwaC5mb3JFYWNoTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICB3aGlsZSAoKChzdGVwID0gaXRlcmF0b3IubmV4dCgpKSwgc3RlcC5kb25lICE9PSB0cnVlKSkge1xuICAgICAgbm9kZURhdGEgPSBzdGVwLnZhbHVlO1xuICAgICAgY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGl0ZXJhdGluZyBhdHRlbXB0aW5nIHRvIGZpbmQgYSBub2RlIG1hdGNoaW5nIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAgICogZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIGZpbmROb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZpbmROb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKSByZXR1cm4gbm9kZURhdGEua2V5O1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgbWFwcGluZyBub2Rlcy5cbiAgICpcbiAgICogQHBhcmFtICB7ZnVuY3Rpb259ICBjYWxsYmFjayAtIENhbGxiYWNrIChrZXksIGF0dHJpYnV0ZXMpLlxuICAgKi9cbiAgbWFwTm9kZXMoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgubWFwTm9kZTogZXhwZWN0aW5nIGEgY2FsbGJhY2suJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICBsZXQgc3RlcCwgbm9kZURhdGE7XG5cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkodGhpcy5vcmRlcik7XG4gICAgbGV0IGkgPSAwO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgIHJlc3VsdFtpKytdID0gY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgd2hldGhlciBzb21lIG5vZGUgdmVyaWZ5IHRoZSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIHNvbWVOb2RlKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnNvbWVOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmIChjYWxsYmFjayhub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyB3aGV0aGVyIGFsbCBub2RlIHZlcmlmeSB0aGUgZ2l2ZW4gcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gIGNhbGxiYWNrIC0gQ2FsbGJhY2sgKGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICBldmVyeU5vZGUoY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguZXZlcnlOb2RlOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghY2FsbGJhY2sobm9kZURhdGEua2V5LCBub2RlRGF0YS5hdHRyaWJ1dGVzKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBmaWx0ZXJpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoa2V5LCBhdHRyaWJ1dGVzKS5cbiAgICovXG4gIGZpbHRlck5vZGVzKGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLmZpbHRlck5vZGVzOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIG5vZGVEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgaWYgKGNhbGxiYWNrKG5vZGVEYXRhLmtleSwgbm9kZURhdGEuYXR0cmlidXRlcykpXG4gICAgICAgIHJlc3VsdC5wdXNoKG5vZGVEYXRhLmtleSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmVkdWNpbmcgbm9kZXMuXG4gICAqXG4gICAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgY2FsbGJhY2sgLSBDYWxsYmFjayAoYWNjdW11bGF0b3IsIGtleSwgYXR0cmlidXRlcykuXG4gICAqL1xuICByZWR1Y2VOb2RlcyhjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ0dyYXBoLnJlZHVjZU5vZGVzOiBleHBlY3RpbmcgYSBjYWxsYmFjay4nXG4gICAgICApO1xuXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGgucmVkdWNlTm9kZXM6IG1pc3NpbmcgaW5pdGlhbCB2YWx1ZS4gWW91IG11c3QgcHJvdmlkZSBpdCBiZWNhdXNlIHRoZSBjYWxsYmFjayB0YWtlcyBtb3JlIHRoYW4gb25lIGFyZ3VtZW50IGFuZCB3ZSBjYW5ub3QgaW5mZXIgdGhlIGluaXRpYWwgdmFsdWUgZnJvbSB0aGUgZmlyc3QgaXRlcmF0aW9uLCBhcyB5b3UgY291bGQgd2l0aCBhIHNpbXBsZSBhcnJheS4nXG4gICAgICApO1xuXG4gICAgbGV0IGFjY3VtdWxhdG9yID0gaW5pdGlhbFZhbHVlO1xuXG4gICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLl9ub2Rlcy52YWx1ZXMoKTtcblxuICAgIGxldCBzdGVwLCBub2RlRGF0YTtcblxuICAgIHdoaWxlICgoKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLCBzdGVwLmRvbmUgIT09IHRydWUpKSB7XG4gICAgICBub2RlRGF0YSA9IHN0ZXAudmFsdWU7XG4gICAgICBhY2N1bXVsYXRvciA9IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCBub2RlRGF0YS5rZXksIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuICAgIH1cblxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG92ZXIgdGhlIGdyYXBoJ3Mgbm9kZSBlbnRyaWVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYXRvcn1cbiAgICovXG4gIG5vZGVFbnRyaWVzKCkge1xuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5fbm9kZXMudmFsdWVzKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHN0ZXAgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChzdGVwLmRvbmUpIHJldHVybiBzdGVwO1xuICAgICAgICBjb25zdCBkYXRhID0gc3RlcC52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2YWx1ZToge25vZGU6IGRhdGEua2V5LCBhdHRyaWJ1dGVzOiBkYXRhLmF0dHJpYnV0ZXN9LFxuICAgICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBTZXJpYWxpemF0aW9uXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgdG8gZXhwb3J0IHRoZSB3aG9sZSBncmFwaC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIFRoZSBzZXJpYWxpemVkIGdyYXBoLlxuICAgKi9cbiAgZXhwb3J0KCkge1xuICAgIGNvbnN0IG5vZGVzID0gbmV3IEFycmF5KHRoaXMuX25vZGVzLnNpemUpO1xuXG4gICAgbGV0IGkgPSAwO1xuXG4gICAgdGhpcy5fbm9kZXMuZm9yRWFjaCgoZGF0YSwga2V5KSA9PiB7XG4gICAgICBub2Rlc1tpKytdID0gc2VyaWFsaXplTm9kZShrZXksIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZWRnZXMgPSBuZXcgQXJyYXkodGhpcy5fZWRnZXMuc2l6ZSk7XG5cbiAgICBpID0gMDtcblxuICAgIHRoaXMuX2VkZ2VzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgZWRnZXNbaSsrXSA9IHNlcmlhbGl6ZUVkZ2UodGhpcy50eXBlLCBrZXksIGRhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICBtdWx0aTogdGhpcy5tdWx0aSxcbiAgICAgICAgYWxsb3dTZWxmTG9vcHM6IHRoaXMuYWxsb3dTZWxmTG9vcHNcbiAgICAgIH0sXG4gICAgICBhdHRyaWJ1dGVzOiB0aGlzLmdldEF0dHJpYnV0ZXMoKSxcbiAgICAgIG5vZGVzLFxuICAgICAgZWRnZXNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIHRvIGltcG9ydCBhIHNlcmlhbGl6ZWQgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdHxHcmFwaH0gZGF0YSAgLSBUaGUgc2VyaWFsaXplZCBncmFwaC5cbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gICAgICBtZXJnZSAtIFdoZXRoZXIgdG8gbWVyZ2UgZGF0YS5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgICAgICAtIFJldHVybnMgaXRzZWxmIGZvciBjaGFpbmluZy5cbiAgICovXG4gIGltcG9ydChkYXRhLCBtZXJnZSA9IGZhbHNlKSB7XG4gICAgLy8gSW1wb3J0aW5nIGEgR3JhcGggaW5zdGFuY2UgZGlyZWN0bHlcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEdyYXBoKSB7XG4gICAgICAvLyBOb2Rlc1xuICAgICAgZGF0YS5mb3JFYWNoTm9kZSgobiwgYSkgPT4ge1xuICAgICAgICBpZiAobWVyZ2UpIHRoaXMubWVyZ2VOb2RlKG4sIGEpO1xuICAgICAgICBlbHNlIHRoaXMuYWRkTm9kZShuLCBhKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBFZGdlc1xuICAgICAgZGF0YS5mb3JFYWNoRWRnZSgoZSwgYSwgcywgdCwgX3NhLCBfdGEsIHUpID0+IHtcbiAgICAgICAgaWYgKG1lcmdlKSB7XG4gICAgICAgICAgaWYgKHUpIHRoaXMubWVyZ2VVbmRpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgICAgZWxzZSB0aGlzLm1lcmdlRGlyZWN0ZWRFZGdlV2l0aEtleShlLCBzLCB0LCBhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodSkgdGhpcy5hZGRVbmRpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgICAgZWxzZSB0aGlzLmFkZERpcmVjdGVkRWRnZVdpdGhLZXkoZSwgcywgdCwgYSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBJbXBvcnRpbmcgYSBzZXJpYWxpemVkIGdyYXBoXG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KGRhdGEpKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguaW1wb3J0OiBpbnZhbGlkIGFyZ3VtZW50LiBFeHBlY3RpbmcgYSBzZXJpYWxpemVkIGdyYXBoIG9yLCBhbHRlcm5hdGl2ZWx5LCBhIEdyYXBoIGluc3RhbmNlLidcbiAgICAgICk7XG5cbiAgICBpZiAoZGF0YS5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoIWlzUGxhaW5PYmplY3QoZGF0YS5hdHRyaWJ1dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgYXR0cmlidXRlcy4gRXhwZWN0aW5nIGEgcGxhaW4gb2JqZWN0LidcbiAgICAgICAgKTtcblxuICAgICAgaWYgKG1lcmdlKSB0aGlzLm1lcmdlQXR0cmlidXRlcyhkYXRhLmF0dHJpYnV0ZXMpO1xuICAgICAgZWxzZSB0aGlzLnJlcGxhY2VBdHRyaWJ1dGVzKGRhdGEuYXR0cmlidXRlcyk7XG4gICAgfVxuXG4gICAgbGV0IGksIGwsIGxpc3QsIG5vZGUsIGVkZ2U7XG5cbiAgICBpZiAoZGF0YS5ub2Rlcykge1xuICAgICAgbGlzdCA9IGRhdGEubm9kZXM7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgbm9kZXMuIEV4cGVjdGluZyBhbiBhcnJheS4nXG4gICAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBub2RlID0gbGlzdFtpXTtcblxuICAgICAgICAvLyBWYWxpZGF0aW5nXG4gICAgICAgIHZhbGlkYXRlU2VyaWFsaXplZE5vZGUobm9kZSk7XG5cbiAgICAgICAgLy8gQWRkaW5nIHRoZSBub2RlXG4gICAgICAgIGNvbnN0IHtrZXksIGF0dHJpYnV0ZXN9ID0gbm9kZTtcblxuICAgICAgICBpZiAobWVyZ2UpIHRoaXMubWVyZ2VOb2RlKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICAgIGVsc2UgdGhpcy5hZGROb2RlKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuZWRnZXMpIHtcbiAgICAgIGxldCB1bmRpcmVjdGVkQnlEZWZhdWx0ID0gZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICd1bmRpcmVjdGVkJykge1xuICAgICAgICB1bmRpcmVjdGVkQnlEZWZhdWx0ID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbGlzdCA9IGRhdGEuZWRnZXM7XG5cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSlcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAgICdHcmFwaC5pbXBvcnQ6IGludmFsaWQgZWRnZXMuIEV4cGVjdGluZyBhbiBhcnJheS4nXG4gICAgICAgICk7XG5cbiAgICAgIGZvciAoaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBlZGdlID0gbGlzdFtpXTtcblxuICAgICAgICAvLyBWYWxpZGF0aW5nXG4gICAgICAgIHZhbGlkYXRlU2VyaWFsaXplZEVkZ2UoZWRnZSk7XG5cbiAgICAgICAgLy8gQWRkaW5nIHRoZSBlZGdlXG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBzb3VyY2UsXG4gICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgIGF0dHJpYnV0ZXMsXG4gICAgICAgICAgdW5kaXJlY3RlZCA9IHVuZGlyZWN0ZWRCeURlZmF1bHRcbiAgICAgICAgfSA9IGVkZ2U7XG5cbiAgICAgICAgbGV0IG1ldGhvZDtcblxuICAgICAgICBpZiAoJ2tleScgaW4gZWRnZSkge1xuICAgICAgICAgIG1ldGhvZCA9IG1lcmdlXG4gICAgICAgICAgICA/IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgICAgPyB0aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VXaXRoS2V5XG4gICAgICAgICAgICAgIDogdGhpcy5tZXJnZURpcmVjdGVkRWRnZVdpdGhLZXlcbiAgICAgICAgICAgIDogdW5kaXJlY3RlZFxuICAgICAgICAgICAgPyB0aGlzLmFkZFVuZGlyZWN0ZWRFZGdlV2l0aEtleVxuICAgICAgICAgICAgOiB0aGlzLmFkZERpcmVjdGVkRWRnZVdpdGhLZXk7XG5cbiAgICAgICAgICBtZXRob2QuY2FsbCh0aGlzLCBlZGdlLmtleSwgc291cmNlLCB0YXJnZXQsIGF0dHJpYnV0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1ldGhvZCA9IG1lcmdlXG4gICAgICAgICAgICA/IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgICAgPyB0aGlzLm1lcmdlVW5kaXJlY3RlZEVkZ2VcbiAgICAgICAgICAgICAgOiB0aGlzLm1lcmdlRGlyZWN0ZWRFZGdlXG4gICAgICAgICAgICA6IHVuZGlyZWN0ZWRcbiAgICAgICAgICAgID8gdGhpcy5hZGRVbmRpcmVjdGVkRWRnZVxuICAgICAgICAgICAgOiB0aGlzLmFkZERpcmVjdGVkRWRnZTtcblxuICAgICAgICAgIG1ldGhvZC5jYWxsKHRoaXMsIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIFV0aWxzXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBhIG51bGwgY29weSBvZiB0aGUgZ3JhcGgsIGkuZS4gYSBncmFwaCB3aXRob3V0IG5vZGVzXG4gICAqICYgZWRnZXMgYnV0IHdpdGggdGhlIGV4YWN0IHNhbWUgb3B0aW9ucy5cbiAgICpcbiAgICogQHBhcmFtICB7b2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBtZXJnZSB3aXRoIHRoZSBjdXJyZW50IG9uZXMuXG4gICAqIEByZXR1cm4ge0dyYXBofSAgICAgICAgICAtIFRoZSBudWxsIGNvcHkuXG4gICAqL1xuICBudWxsQ29weShvcHRpb25zKSB7XG4gICAgY29uc3QgZ3JhcGggPSBuZXcgR3JhcGgoYXNzaWduKHt9LCB0aGlzLl9vcHRpb25zLCBvcHRpb25zKSk7XG4gICAgZ3JhcGgucmVwbGFjZUF0dHJpYnV0ZXMoYXNzaWduKHt9LCB0aGlzLmdldEF0dHJpYnV0ZXMoKSkpO1xuICAgIHJldHVybiBncmFwaDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIGFuIGVtcHR5IGNvcHkgb2YgdGhlIGdyYXBoLCBpLmUuIGEgZ3JhcGggd2l0aG91dCBlZGdlcyBidXRcbiAgICogd2l0aCB0aGUgZXhhY3Qgc2FtZSBvcHRpb25zLlxuICAgKlxuICAgKiBAcGFyYW0gIHtvYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIG1lcmdlIHdpdGggdGhlIGN1cnJlbnQgb25lcy5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gVGhlIGVtcHR5IGNvcHkuXG4gICAqL1xuICBlbXB0eUNvcHkob3B0aW9ucykge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5udWxsQ29weShvcHRpb25zKTtcblxuICAgIHRoaXMuX25vZGVzLmZvckVhY2goKG5vZGVEYXRhLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBhc3NpZ24oe30sIG5vZGVEYXRhLmF0dHJpYnV0ZXMpO1xuXG4gICAgICAvLyBOT1RFOiBubyBuZWVkIHRvIGVtaXQgZXZlbnRzIHNpbmNlIHVzZXIgY2Fubm90IGFjY2VzcyB0aGUgaW5zdGFuY2UgeWV0XG4gICAgICBub2RlRGF0YSA9IG5ldyBncmFwaC5Ob2RlRGF0YUNsYXNzKGtleSwgYXR0cmlidXRlcyk7XG4gICAgICBncmFwaC5fbm9kZXMuc2V0KGtleSwgbm9kZURhdGEpO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCByZXR1cm5pbmcgYW4gZXhhY3QgY29weSBvZiB0aGUgZ3JhcGguXG4gICAqXG4gICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAtIFVwZ3JhZGUgb3B0aW9ucy5cbiAgICogQHJldHVybiB7R3JhcGh9ICAgICAgICAgIC0gVGhlIGNvcHkuXG4gICAqL1xuICBjb3B5KG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLnR5cGUgPT09ICdzdHJpbmcnICYmXG4gICAgICBvcHRpb25zLnR5cGUgIT09IHRoaXMudHlwZSAmJlxuICAgICAgb3B0aW9ucy50eXBlICE9PSAnbWl4ZWQnXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IFVzYWdlR3JhcGhFcnJvcihcbiAgICAgICAgYEdyYXBoLmNvcHk6IGNhbm5vdCBjcmVhdGUgYW4gaW5jb21wYXRpYmxlIGNvcHkgZnJvbSBcIiR7dGhpcy50eXBlfVwiIHR5cGUgdG8gXCIke29wdGlvbnMudHlwZX1cIiBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguYFxuICAgICAgKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLm11bHRpID09PSAnYm9vbGVhbicgJiZcbiAgICAgIG9wdGlvbnMubXVsdGkgIT09IHRoaXMubXVsdGkgJiZcbiAgICAgIG9wdGlvbnMubXVsdGkgIT09IHRydWVcbiAgICApXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguY29weTogY2Fubm90IGNyZWF0ZSBhbiBpbmNvbXBhdGlibGUgY29weSBieSBkb3duZ3JhZGluZyBhIG11bHRpIGdyYXBoIHRvIGEgc2ltcGxlIG9uZSBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguJ1xuICAgICAgKTtcblxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBvcHRpb25zLmFsbG93U2VsZkxvb3BzID09PSAnYm9vbGVhbicgJiZcbiAgICAgIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgIT09IHRoaXMuYWxsb3dTZWxmTG9vcHMgJiZcbiAgICAgIG9wdGlvbnMuYWxsb3dTZWxmTG9vcHMgIT09IHRydWVcbiAgICApXG4gICAgICB0aHJvdyBuZXcgVXNhZ2VHcmFwaEVycm9yKFxuICAgICAgICAnR3JhcGguY29weTogY2Fubm90IGNyZWF0ZSBhbiBpbmNvbXBhdGlibGUgY29weSBmcm9tIGEgZ3JhcGggYWxsb3dpbmcgc2VsZiBsb29wcyB0byBvbmUgdGhhdCBkb2VzIG5vdCBiZWNhdXNlIHRoaXMgd291bGQgbWVhbiBsb3NpbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgZ3JhcGguJ1xuICAgICAgKTtcblxuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5lbXB0eUNvcHkob3B0aW9ucyk7XG5cbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuX2VkZ2VzLnZhbHVlcygpO1xuXG4gICAgbGV0IHN0ZXAsIGVkZ2VEYXRhO1xuXG4gICAgd2hpbGUgKCgoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSksIHN0ZXAuZG9uZSAhPT0gdHJ1ZSkpIHtcbiAgICAgIGVkZ2VEYXRhID0gc3RlcC52YWx1ZTtcblxuICAgICAgLy8gTk9URTogbm8gbmVlZCB0byBlbWl0IGV2ZW50cyBzaW5jZSB1c2VyIGNhbm5vdCBhY2Nlc3MgdGhlIGluc3RhbmNlIHlldFxuICAgICAgYWRkRWRnZShcbiAgICAgICAgZ3JhcGgsXG4gICAgICAgICdjb3B5JyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGVkZ2VEYXRhLnVuZGlyZWN0ZWQsXG4gICAgICAgIGVkZ2VEYXRhLmtleSxcbiAgICAgICAgZWRnZURhdGEuc291cmNlLmtleSxcbiAgICAgICAgZWRnZURhdGEudGFyZ2V0LmtleSxcbiAgICAgICAgYXNzaWduKHt9LCBlZGdlRGF0YS5hdHRyaWJ1dGVzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZ3JhcGg7XG4gIH1cblxuICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogS25vd24gbWV0aG9kc1xuICAgKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgLyoqXG4gICAqIE1ldGhvZCB1c2VkIGJ5IEphdmFTY3JpcHQgdG8gcGVyZm9ybSBKU09OIHNlcmlhbGl6YXRpb24uXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBUaGUgc2VyaWFsaXplZCBncmFwaC5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gdGhpcy5leHBvcnQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgcmV0dXJuaW5nIFtvYmplY3QgR3JhcGhdLlxuICAgKi9cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdbb2JqZWN0IEdyYXBoXSc7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIHVzZWQgaW50ZXJuYWxseSBieSBub2RlJ3MgY29uc29sZSB0byBkaXNwbGF5IGEgY3VzdG9tIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybiB7b2JqZWN0fSAtIEZvcm1hdHRlZCBvYmplY3QgcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYXBoLlxuICAgKi9cbiAgaW5zcGVjdCgpIHtcbiAgICBjb25zdCBub2RlcyA9IHt9O1xuICAgIHRoaXMuX25vZGVzLmZvckVhY2goKGRhdGEsIGtleSkgPT4ge1xuICAgICAgbm9kZXNba2V5XSA9IGRhdGEuYXR0cmlidXRlcztcbiAgICB9KTtcblxuICAgIGNvbnN0IGVkZ2VzID0ge30sXG4gICAgICBtdWx0aUluZGV4ID0ge307XG5cbiAgICB0aGlzLl9lZGdlcy5mb3JFYWNoKChkYXRhLCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGRhdGEudW5kaXJlY3RlZCA/ICctLScgOiAnLT4nO1xuXG4gICAgICBsZXQgbGFiZWwgPSAnJztcblxuICAgICAgbGV0IHNvdXJjZSA9IGRhdGEuc291cmNlLmtleTtcbiAgICAgIGxldCB0YXJnZXQgPSBkYXRhLnRhcmdldC5rZXk7XG4gICAgICBsZXQgdG1wO1xuXG4gICAgICBpZiAoZGF0YS51bmRpcmVjdGVkICYmIHNvdXJjZSA+IHRhcmdldCkge1xuICAgICAgICB0bXAgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IHRhcmdldDtcbiAgICAgICAgdGFyZ2V0ID0gdG1wO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXNjID0gYCgke3NvdXJjZX0pJHtkaXJlY3Rpb259KCR7dGFyZ2V0fSlgO1xuXG4gICAgICBpZiAoIWtleS5zdGFydHNXaXRoKCdnZWlkXycpKSB7XG4gICAgICAgIGxhYmVsICs9IGBbJHtrZXl9XTogYDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICBpZiAodHlwZW9mIG11bHRpSW5kZXhbZGVzY10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgbXVsdGlJbmRleFtkZXNjXSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXVsdGlJbmRleFtkZXNjXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFiZWwgKz0gYCR7bXVsdGlJbmRleFtkZXNjXX0uIGA7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsICs9IGRlc2M7XG5cbiAgICAgIGVkZ2VzW2xhYmVsXSA9IGRhdGEuYXR0cmlidXRlcztcbiAgICB9KTtcblxuICAgIGNvbnN0IGR1bW15ID0ge307XG5cbiAgICBmb3IgKGNvbnN0IGsgaW4gdGhpcykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLmhhc093blByb3BlcnR5KGspICYmXG4gICAgICAgICFFTUlUVEVSX1BST1BTLmhhcyhrKSAmJlxuICAgICAgICB0eXBlb2YgdGhpc1trXSAhPT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICB0eXBlb2YgayAhPT0gJ3N5bWJvbCdcbiAgICAgIClcbiAgICAgICAgZHVtbXlba10gPSB0aGlzW2tdO1xuICAgIH1cblxuICAgIGR1bW15LmF0dHJpYnV0ZXMgPSB0aGlzLl9hdHRyaWJ1dGVzO1xuICAgIGR1bW15Lm5vZGVzID0gbm9kZXM7XG4gICAgZHVtbXkuZWRnZXMgPSBlZGdlcztcblxuICAgIHByaXZhdGVQcm9wZXJ0eShkdW1teSwgJ2NvbnN0cnVjdG9yJywgdGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgICByZXR1cm4gZHVtbXk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2hpbmcgbWV0aG9kcyB0byB0aGUgcHJvdG90eXBlLlxuICpcbiAqIEhlcmUsIHdlIGFyZSBhdHRhY2hpbmcgYSB3aWRlIHZhcmlldHkgb2YgbWV0aG9kcyB0byB0aGUgR3JhcGggY2xhc3MnXG4gKiBwcm90b3R5cGUgd2hlbiB0aG9zZSBhcmUgdmVyeSBudW1lcm91cyBhbmQgd2hlbiB0aGVpciBjcmVhdGlvbiBpc1xuICogYWJzdHJhY3RlZC5cbiAqL1xuXG4vKipcbiAqIEF0dGFjaGluZyBjdXN0b20gaW5zcGVjdCBtZXRob2QgZm9yIG5vZGUgPj0gMTAuXG4gKi9cbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJylcbiAgR3JhcGgucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID1cbiAgICBHcmFwaC5wcm90b3R5cGUuaW5zcGVjdDtcblxuLyoqXG4gKiBSZWxhdGVkIHRvIGVkZ2UgYWRkaXRpb24uXG4gKi9cbkVER0VfQUREX01FVEhPRFMuZm9yRWFjaChtZXRob2QgPT4ge1xuICBbJ2FkZCcsICdtZXJnZScsICd1cGRhdGUnXS5mb3JFYWNoKHZlcmIgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBtZXRob2QubmFtZSh2ZXJiKTtcbiAgICBjb25zdCBmbiA9IHZlcmIgPT09ICdhZGQnID8gYWRkRWRnZSA6IG1lcmdlRWRnZTtcblxuICAgIGlmIChtZXRob2QuZ2VuZXJhdGVLZXkpIHtcbiAgICAgIEdyYXBoLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uIChzb3VyY2UsIHRhcmdldCwgYXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gZm4oXG4gICAgICAgICAgdGhpcyxcbiAgICAgICAgICBuYW1lLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgKG1ldGhvZC50eXBlIHx8IHRoaXMudHlwZSkgPT09ICd1bmRpcmVjdGVkJyxcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB2ZXJiID09PSAndXBkYXRlJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgR3JhcGgucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gKGVkZ2UsIHNvdXJjZSwgdGFyZ2V0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBmbihcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgKG1ldGhvZC50eXBlIHx8IHRoaXMudHlwZSkgPT09ICd1bmRpcmVjdGVkJyxcbiAgICAgICAgICBlZGdlLFxuICAgICAgICAgIHNvdXJjZSxcbiAgICAgICAgICB0YXJnZXQsXG4gICAgICAgICAgYXR0cmlidXRlcyxcbiAgICAgICAgICB2ZXJiID09PSAndXBkYXRlJ1xuICAgICAgICApO1xuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbi8qKlxuICogQXR0cmlidXRlcy1yZWxhdGVkLlxuICovXG5hdHRhY2hOb2RlQXR0cmlidXRlc01ldGhvZHMoR3JhcGgpO1xuYXR0YWNoRWRnZUF0dHJpYnV0ZXNNZXRob2RzKEdyYXBoKTtcblxuLyoqXG4gKiBFZGdlIGl0ZXJhdGlvbi1yZWxhdGVkLlxuICovXG5hdHRhY2hFZGdlSXRlcmF0aW9uTWV0aG9kcyhHcmFwaCk7XG5cbi8qKlxuICogTmVpZ2hib3IgaXRlcmF0aW9uLXJlbGF0ZWQuXG4gKi9cbmF0dGFjaE5laWdoYm9ySXRlcmF0aW9uTWV0aG9kcyhHcmFwaCk7XG5cbi8qKlxuICogR3JhcGhvbG9neSBIZWxwZXIgQ2xhc3Nlc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBCdWlsZGluZyBzb21lIGhpZ2hlci1vcmRlciBjbGFzc2VzIGluc3RhbnRpYXRpbmcgdGhlIGdyYXBoIHdpdGhcbiAqIHByZWRlZmluaXRlIG9wdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBBbHRlcm5hdGl2ZSBjb25zdHJ1Y3RvcnMuXG4gKi9cbmNsYXNzIERpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICdkaXJlY3RlZCd9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgbXVsdGkgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgaWYgKGZpbmFsT3B0aW9ucy50eXBlICE9PSAnZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgVW5kaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAndW5kaXJlY3RlZCd9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IGZhbHNlKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnVW5kaXJlY3RlZEdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBtdWx0aSBpbiBnaXZlbiBvcHRpb25zISdcbiAgICAgICk7XG5cbiAgICBpZiAoZmluYWxPcHRpb25zLnR5cGUgIT09ICd1bmRpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ1VuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlHcmFwaCBleHRlbmRzIEdyYXBoIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIGNvbnN0IGZpbmFsT3B0aW9ucyA9IGFzc2lnbih7bXVsdGk6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aUdyYXBoLmZyb206IGluY29uc2lzdGVudCBpbmRpY2F0aW9uIHRoYXQgdGhlIGdyYXBoIHNob3VsZCBiZSBzaW1wbGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlEaXJlY3RlZEdyYXBoIGV4dGVuZHMgR3JhcGgge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt0eXBlOiAnZGlyZWN0ZWQnLCBtdWx0aTogdHJ1ZX0sIG9wdGlvbnMpO1xuXG4gICAgaWYgKCdtdWx0aScgaW4gZmluYWxPcHRpb25zICYmIGZpbmFsT3B0aW9ucy5tdWx0aSAhPT0gdHJ1ZSlcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ2RpcmVjdGVkJylcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvcihcbiAgICAgICAgJ011bHRpRGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgXCInICtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMudHlwZSArXG4gICAgICAgICAgJ1wiIHR5cGUgaW4gZ2l2ZW4gb3B0aW9ucyEnXG4gICAgICApO1xuXG4gICAgc3VwZXIoZmluYWxPcHRpb25zKTtcbiAgfVxufVxuY2xhc3MgTXVsdGlVbmRpcmVjdGVkR3JhcGggZXh0ZW5kcyBHcmFwaCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaW5hbE9wdGlvbnMgPSBhc3NpZ24oe3R5cGU6ICd1bmRpcmVjdGVkJywgbXVsdGk6IHRydWV9LCBvcHRpb25zKTtcblxuICAgIGlmICgnbXVsdGknIGluIGZpbmFsT3B0aW9ucyAmJiBmaW5hbE9wdGlvbnMubXVsdGkgIT09IHRydWUpXG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IoXG4gICAgICAgICdNdWx0aVVuZGlyZWN0ZWRHcmFwaC5mcm9tOiBpbmNvbnNpc3RlbnQgaW5kaWNhdGlvbiB0aGF0IHRoZSBncmFwaCBzaG91bGQgYmUgc2ltcGxlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIGlmIChmaW5hbE9wdGlvbnMudHlwZSAhPT0gJ3VuZGlyZWN0ZWQnKVxuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yKFxuICAgICAgICAnTXVsdGlVbmRpcmVjdGVkR3JhcGguZnJvbTogaW5jb25zaXN0ZW50IFwiJyArXG4gICAgICAgICAgZmluYWxPcHRpb25zLnR5cGUgK1xuICAgICAgICAgICdcIiB0eXBlIGluIGdpdmVuIG9wdGlvbnMhJ1xuICAgICAgKTtcblxuICAgIHN1cGVyKGZpbmFsT3B0aW9ucyk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRhY2hpbmcgc3RhdGljICMuZnJvbSBtZXRob2QgdG8gZWFjaCBvZiB0aGUgY29uc3RydWN0b3JzLlxuICovXG5mdW5jdGlvbiBhdHRhY2hTdGF0aWNGcm9tTWV0aG9kKENsYXNzKSB7XG4gIC8qKlxuICAgKiBCdWlsZHMgYSBncmFwaCBmcm9tIHNlcmlhbGl6ZWQgZGF0YSBvciBhbm90aGVyIGdyYXBoJ3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtICB7R3JhcGh8U2VyaWFsaXplZEdyYXBofSBkYXRhICAgICAgLSBIeWRyYXRhdGlvbiBkYXRhLlxuICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgIFtvcHRpb25zXSAtIE9wdGlvbnMuXG4gICAqIEByZXR1cm4ge0NsYXNzfVxuICAgKi9cbiAgQ2xhc3MuZnJvbSA9IGZ1bmN0aW9uIChkYXRhLCBvcHRpb25zKSB7XG4gICAgLy8gTWVyZ2luZyBnaXZlbiBvcHRpb25zIHdpdGggc2VyaWFsaXplZCBvbmVzXG4gICAgY29uc3QgZmluYWxPcHRpb25zID0gYXNzaWduKHt9LCBkYXRhLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgQ2xhc3MoZmluYWxPcHRpb25zKTtcbiAgICBpbnN0YW5jZS5pbXBvcnQoZGF0YSk7XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH07XG59XG5cbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoR3JhcGgpO1xuYXR0YWNoU3RhdGljRnJvbU1ldGhvZChEaXJlY3RlZEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoVW5kaXJlY3RlZEdyYXBoKTtcbmF0dGFjaFN0YXRpY0Zyb21NZXRob2QoTXVsdGlHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKE11bHRpRGlyZWN0ZWRHcmFwaCk7XG5hdHRhY2hTdGF0aWNGcm9tTWV0aG9kKE11bHRpVW5kaXJlY3RlZEdyYXBoKTtcblxuR3JhcGguR3JhcGggPSBHcmFwaDtcbkdyYXBoLkRpcmVjdGVkR3JhcGggPSBEaXJlY3RlZEdyYXBoO1xuR3JhcGguVW5kaXJlY3RlZEdyYXBoID0gVW5kaXJlY3RlZEdyYXBoO1xuR3JhcGguTXVsdGlHcmFwaCA9IE11bHRpR3JhcGg7XG5HcmFwaC5NdWx0aURpcmVjdGVkR3JhcGggPSBNdWx0aURpcmVjdGVkR3JhcGg7XG5HcmFwaC5NdWx0aVVuZGlyZWN0ZWRHcmFwaCA9IE11bHRpVW5kaXJlY3RlZEdyYXBoO1xuXG5HcmFwaC5JbnZhbGlkQXJndW1lbnRzR3JhcGhFcnJvciA9IEludmFsaWRBcmd1bWVudHNHcmFwaEVycm9yO1xuR3JhcGguTm90Rm91bmRHcmFwaEVycm9yID0gTm90Rm91bmRHcmFwaEVycm9yO1xuR3JhcGguVXNhZ2VHcmFwaEVycm9yID0gVXNhZ2VHcmFwaEVycm9yO1xuXG4vKipcbiAqIEdyYXBob2xvZ3kgRVNNIEVuZG9pbnRcbiAqID09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogRW5kcG9pbnQgZm9yIEVTTSBtb2R1bGVzIGNvbnN1bWVycy5cbiAqL1xuXG5leHBvcnQgeyBEaXJlY3RlZEdyYXBoLCBHcmFwaCwgSW52YWxpZEFyZ3VtZW50c0dyYXBoRXJyb3IsIE11bHRpRGlyZWN0ZWRHcmFwaCwgTXVsdGlHcmFwaCwgTXVsdGlVbmRpcmVjdGVkR3JhcGgsIE5vdEZvdW5kR3JhcGhFcnJvciwgVW5kaXJlY3RlZEdyYXBoLCBVc2FnZUdyYXBoRXJyb3IsIEdyYXBoIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdyYXBob2xvZ3kubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/graphology/dist/graphology.mjs\n"));

/***/ })

}]);